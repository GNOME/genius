# Miscellaneous number theory functions

function IsOdd(n) = (
 if not IsValue(n) or not IsInteger(n) then
 (
  error("IsOdd: argument must be an integer");
  bailout;
 );
 (n % 2)
)
SetHelp("IsOdd","number_theory","Tests if an integer is odd")
protect("IsOdd")

function IsEven(n) = not IsOdd(n)
SetHelp("IsEven","number_theory","Tests if an integer is even")
protect("IsEven")

# FIXME: This should be done internally perhaps
function IsNthPower(n,k) =
 (
  if not IsRational (n) then
	# Only integers/rationals can be perfect powers
	0
  else if k == 2 then
	IsPerfectSquare(n)
  else if not IsPerfectPower(n) then
	# We know this won't work
	0
  else if IsInteger(n) then
	(floor((n)^(1/k))^k==n)
# FIXME: should add some ``analytic'' testing, i.e., if the
# fractional part is non-zero (or more that precision?), it can't
# be a square

  # Since rational numbers are in reduced form, by unique factorization it
  # suffices to check if the numerator and denominator are Nth powers
  else
	(IsNthPower(Numerator(n),k)) and IsNthPower(Denominator(n),k)
 )
SetHelp("IsNthPower","number_theory","Tests if a rational number is a perfect power");
protect("IsNthPower");

# FIXME: this is just a hack until we get a real symbolic mode
function SymbolicNthRoot(n,k) =
 (
  if IsRational(n) and k == 2 then
	sqrt (n)
  else if IsNthPower(n,k) then
	return IntegerPart(n^(1/k))
  else
  	return n^(1/k);
 )
SetHelp("SymbolicNthRoot","number_theory","If nth root is integer, then return as integer, else standard nth root.");
protect("SymbolicNthRoot");

function Divides(m,n) = not n % m;
SetHelp("Divides","number_theory","Checks divisibility (if m divides n)");
protect("Divides");

# Returns the highest power of p that divides n, where n is rational.
# FIXME: This is only a valuation if p is prime, so this is an abuse
# of language.
function PadicValuation(n,p) =
 (
  if IsRational(n) and not IsInteger(n) then
    return PadicValuation(Numerator(n))-PadicValuation(Denominator(n));
  if not IsInteger(n) then
   (
    error("PadicValuation: argument must be rational or integer");
    bailout;
   );
#  if (n==0) then return Infinity; # FIXME: Infinity not yet implemented
  if (n==0) then return null;

  valuation=0;
  while Divides(p,n) do
   (
    valuation=valuation+1;
    n=n/p;
   );
  return valuation;
 )
SetHelp("PadicValuation","number_theory","Returns the padic valuation (number of trailing zeros in base p).");
protect("PadicValuation");

function RemoveFactor(n,m) =
 (
  if not IsInteger(n) or not IsInteger(m) then
   (
    error("RemoveFactor: arguments must be integers");
    bailout;
   );
  if (n==0) then return 0;

  while Divides(m,n) do
   (
    n=n/m;
   );
  return n;
 )
SetHelp("RemoveFactor","number_theory","Removes all instances of the factor m from the number n");
protect("RemoveFactor");

function PowerMod(a,b,m) = a^b mod m
SetHelp("PowerMod","number_theory","Compute a^b mod m");
protect("PowerMod");
