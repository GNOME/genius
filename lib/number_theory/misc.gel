# Miscellaneous number theory functions

function IsOdd(n) = (n % 2);
SetHelp("IsOdd","number_theory","Tests if an integer is odd");
protect("IsOdd");

function IsEven(n) = not(IsOdd(n));
SetHelp("IsEven","number_theory","Tests if an integer is even");
protect("IsEven");

# FIXME: This should be done internally perhaps
function IsNthPower(n,k) =
 (
  if not IsRational (n) then
	# Only integers/rationals can be perfect powers
	0
  else if k == 2 then
	IsPerfectSquare(n)
  else if not IsPerfectPower(n) then
	# We know this won't work
	0
  else if IsInteger(n) then
	(floor((n)^(1/k))^k==n)
# FIXME: should add some ``analytic'' testing, i.e., if the
# fractional part is non-zero (or more that precision?), it can't
# be a square

  # Since rational numbers are in reduced form, by unique factorization it
  # suffices to check if the numerator and denominator are Nth powers
  else
	(IsNthPower(Numerator(n),k)) and IsNthPower(Denominator(n),k)
 )
SetHelp("IsNthPower","number_theory","Tests if a rational number is a perfect power");
protect("IsNthPower");

SetHelp("SymbolicSquareRoot","number_theory","If square root is integer, then return as integer, else standard square root. (note sqrt behaves the same way)");
SymbolicSquareRoot = sqrt;
protect("SymbolicSquareRoot");

# FIXME: this is just a hack until we get a real symbolic mode
function SymbolicNthRoot(n,k) =
 (
  if IsRational(n) and k == 2 then
	sqrt (n)
  else if IsNthPower(n,k) then
	return IntegerPart(n^(1/k))
  else
  	return n^(1/k);
 )
SetHelp("SymbolicNthRoot","number_theory","If nth root is integer, then return as integer, else standard nth root.");
protect("SymbolicNthRoot");

function Divides(m,n) = not(n % m);
SetHelp("Divides","number_theory","Checks divisibility");
protect("Divides");

# Returns the highest power of p that divides n, where n is rational.
# FIXME: This is only a valuation if p is prime, so this is an abuse
# of language.
function PadicValuation(n,p) =
 (
  if IsRational(n) and not IsInteger(n) then
    return PadicValuation(Numerator(n))-PadicValuation(Denominator(n));
  if not(IsInteger(n)) then
   (
    error("PadicValuation: argument must be rational or integer");
    bailout;
   );
#  if (n==0) then return Infinity; # FIXME: Infinity not yet implemented
  if (n==0) then return null;

  valuation=0;
  while Divides(p,n) do
   (
    valuation=valuation+1;
    n=n/p;
   );
  return valuation;
 )
SetHelp("PadicValuation","number_theory","Returns the padic valuation (number of trailing zeros in base p).");
protect("PadicValuation");

#FIXME: This should also be built-in to modular arithmatic,
# though it is slightly more complicated
# Computes a^b mod m
function PowerMod(a,b,m) =
 (
  n=1;
  while (b != 0) do
   (
    if IsOdd(b) then n=(n*a) % m;
    b=floor(b/2);
    a=(a*a) % m;
   );
  return n;
 )
SetHelp("PowerMod","number_theory","Compute #1^#2 mod #3");
protect("PowerMod");
