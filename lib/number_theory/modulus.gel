# GEL routines for working in Z/n (the integer modulo n)

# phi(n), the Euler phi function, i.e., the number of integers between
# 1 and n that are relatively prime to n
# Note that if the prime factorization of n is p_1^a_1 * ... p_r^a_r,
# then EulerPhi(n)=n*(1-1/p_1)*...*(1-1/p_r). We use this to calculate
SetHelp("EulerPhi","number_theory","Compute phi(n), the Euler phi function, that is the number of integers between 1 and n relatively prime to n");
function EulerPhi(n) =
(
	if not IsPositiveInteger(n) then
		(error("EulerPhi: argument not an integer larger then 0");bailout);
	n * (prod p in PrimeFactors(n) do (1-(1/p)))
)
protect("EulerPhi");

# Silver-Pohlig-Hellman as described in
# Neil Koblitz, A Course in Number Theory and Cryptography, Springer, 1987
# page 102-103
SetHelp("DiscreteLog", "number_theory", "Find discrete log of n base b in F_q where q is a prime using the Silver-Pohlig-Hellman algoritm");
function DiscreteLog(n,b,q) = (
  if not IsPositiveInteger(n) or
     not IsPositiveInteger(b) or
     not IsPositiveInteger(q) or q < 2 or b < 2 then
    (error("DiscreteLog: Bad arguments");bailout);

  f = Factorize(q-1);

  # Run the precalculation of the pth roots of unity
  # for each p in the factorization of q-1
  r = null;
  for i = 2 to columns(f) do (
    p = f@(1,i);
    for j = 0 to p-1 do
      r@(i-1,j+1) = b^(j*(q-1)/p) mod q;
  );

  # utility function to find the root in the table
  function FindRoot(rt,p,i) = (
    for j = 1 to p do
      if r@(i-1,j) == rt then return j-1;
    (error("DiscreteLog: Error finding log, probably bogus arguments");bailout);
  );

  # This will be our vector of moduli for the ChineseRemainder
  m = null;
  # this will be our vector of results for the ChineseRemainder
  x = null;

  # loop through all the prime factors of q-1
  for i = 2 to columns(f) do (
    p = f@(1,i); alpha = f@(2,i);
    m@(i-1) = p^alpha;

    xx = 0;
    for l = 0 to alpha-1 do (
      y = n/(b^xx);
      rt = y^((q-1)/p^(l+1)) mod q;
      xx = xx + FindRoot(rt,p,i) * p^l;
    );
    x@(i-1) = xx;
  );

  # Now return the chinese remainder of the system
  ChineseRemainder(x,m)
)
protect ("DiscreteLog")

SetHelp("IsPrimitiveMod", "number_theory", "Check if g is primitive in F_q, where q is a prime.  If q is not prime results are bogus.");
function IsPrimitiveMod(g,q) = (
  if not IsPositiveInteger(g) or
     not IsPositiveInteger(q) or q < 2 or g < 2 then
    (error("IsPrimitiveMod: Bad arguments");bailout);
  for p in PrimeFactors (q-1) do (
    if g^((q-1)/p) == 1 mod q then return 0
  );
  1
)
protect ("IsPrimitiveMod")
