# Primes and Primality

# All algorithms come from Bressoud, Factorization and Primality
# Testing (see Dr. Genius bibliography)

# FIXME: This is a simple sieve. It should include caching (i.e.,
# store what every 10'th (or 20'th, or 100'th) prime is, up to a
# certain amount. This would make it MUCH faster for small values.
# For large values, it would be nice to do something like invert PrimePi(x).

# FIXME:
# Actually, much better would be good code to deal with ALL sequences,
# not just the sequence of primes.
# For example, linear recursive sequences could be either computed
# recursively (if those values are cached), or solved in closed form
# (and caching could be done intelligently etc.)

# There's a stupid built in function for this
# function Prime(n) =
#  (
#   x=1;
#   for loop=1 to n do x=NextPrime(x);
#   return x;
#  )

SetHelp("IsPrime","number_theory","Tests primality of integers, for numbers greater then 25*10^9 false positive is with probability of less then PrimeProbabilityEpsilon");
function IsPrime(n) =
  (
    if not IsInteger(n) then
	(error("IsPrime: argument not an integer");bailout);
    ### Part 0: Preparations/small numbers
    if (n<0) then n=|n|; # Make sure n is non-negative

    # First check if it's a small prime (the loop below doesn't like small primes)
    # or a special case
    if (n==0) or (n==1) then return 0;
    if (n==2) or (n==3) or (n==5) or (n==7) or (n==11) then return 1;

    # Then check if divisible by 2 or 3
    if Divides(2,n) or Divides(3,n) then return 0;

    ### Part I: Trial Division
    # Trial division up to (at most) the square root of n, but stop once you get too high
    loop_max=min(IsPrimeLoopMax,floor(sqrt(n)));

    # Now loop through all numbers up to loop_max that are not divisible by 2 or 3
    loop=5;
    do
     (
      if Divides(loop,n) and (loop < n) then return 0;
      loop=loop+2;
      if Divides(loop,n) then return 0;
      loop=loop+4;
     ) while (loop<=loop_max);
# If it's a small number, then we've tried all possible prime divisors, so
# it's prime:
    if (n<=IsPrimeLoopMax^2) then return 1;

    # Find t and a satisfying n-1=2^a*t, t odd
    t = n-1;
    a = 0;
    while IsEven(t) do
     (
      t=t/2;
      a=a+1;
     );

    ### Part II: Strong Pseudoprime Tests
    if not(StrongPseudoprimeTestSub(n,a,t,2)) then return 0;
    if not(StrongPseudoprimeTestSub(n,a,t,3)) then return 0;
    if not(StrongPseudoprimeTestSub(n,a,t,5)) then return 0;
    if not(StrongPseudoprimeTestSub(n,a,t,7)) then return 0;
    # If it passes the pseudoprime test for base 2,3,5,7 and doesn't
    # have small divisors, then it's probably prime. It definitely is
    # if it's less than 25*10^9.
    if n<25*10^9 then return 1;

    ### Part III: Other things ... Lucas Sequences?
    ## At this point we're pretty sure that n is prime, so we'd like to prove it.
    ### FIXME: Lucas sequences/test
      # according to m9a docs, good up to 10^16.

    ### Part IV: Last try, then give up
      # If Lucas sequences fail too, I don't know what to do -- I guess
      # continue to try pseudoprime tests or do some fancy elliptic curve
      # thing

    return MillerRabinTest(n,PrimeProbabilityEpsilon);
   

    # error("Cannot determine primality. Probably prime, but not sure.");
    # return null;
  )
protect("IsPrime");

SetHelp("IsPrimeLoopMax","parameters", "Maximum number which IsPrime uses in trial division");
parameter IsPrimeLoopMax = 5000;           # IsPrime configuration variable

SetHelp("PrimeProbabilityEpsilon","parameters", "The epsilon used for the MillerRabinTest from within IsPrime");
parameter PrimeProbabilityEpsilon = 10.0^-100;  # IsPrime configuration variable

#####################################
#### (Strong) Pseudoprime tests #####
#####################################
# FIXME: references and definitions!

# The ``pseudoprime test'':
# Returns true iff b^(n-1) == 1 (mod n).
# FIXME: Should we take abs(n) if n is negative?
# FIXME: is there a good name for an integer that is EITHER a pseudoprime OR a prime?
SetHelp("PseudoprimeTest","number_theory","Pseudoprime test, true iff b^(n-1) == 1 (mod n)");
function PseudoprimeTest(n,b) =
 (
  return (PowerMod(b,abs(n)-1,n) == 1);
 )
protect("PseudoprimeTest");

# An integer is said to be a PseudoPrime with base b iff it is:
# odd, composite, and satisfies b^(n-1) == 1 (mod n).
# We rearrange the order below to take advantage of lazy evaluation
# (IsOdd and PseudoprimeTest are MUCH faster than IsPrime)
function IsPseudoprime(n,b) =
 (
  return (IsOdd(n) and PseudoprimeTest(n,b) and not(IsPrime(n)));
 )
SetHelp("IsPseudoprime","number_theory","If n is a pseudoprime base b but not a prime, that is if b^(n-1) == 1 mod n");
protect("IsPseudoprime");

function StrongPseudoprimeTestSub(n,a,t,b) =
 (
  test = b^t mod n;
  if (test==1) or (test==n-1) then return 1;
  for loop = 1 to a-1 do
   (
    test=(test*test) % n;
    if (test==1) or (test==n-1) then return 1;
   );
  return 0;
 )
SetHelp("StrongPseudoprimeTestSub","number_theory","Run the strong pseudoprime test base b on n where n-1=2^a*t, t odd");
protect("StrongPseudoprimeTestSub");

function StrongPseudoprimeTest(n,b) =
 (
  # Find t and a satisfying n-1=2^a*t, t odd
  t = n-1;
  a = 0;
  while IsEven(t) do
   (
    t=t/2;
    a=a+1;
   );

  StrongPseudoprimeTestSub(n,a,t,b)
 )
SetHelp("StrongPseudoprimeTest","number_theory","Run the strong pseudoprime test base b on n");
protect("StrongPseudoprimeTest");

function IsStrongPseudoprime(n,b) =
 (
  return (IsOdd(n) and AreRelativelyPrime(n,b) and StrongPseudoprimeTest(n,b) and not (IsPrime(n)));
 )
SetHelp("IsStrongPseudoprime","number_theory","Test if n is a strong pseudoprime to base b but not a prime");
protect("IsStrongPseudoprime");

function MillerRabinTest(n,epsilon) =
(
  if not IsInteger(n) or not IsValue(epsilon) or epsilon <= 0 or n <= 2 then
    (error("MillerRabinTest: n not an odd positive integer or epsilon not greater then 0"); bailout);

  epsilon = float(epsilon);

  # Find t and a satisfying n-1=2^a*t, t odd
  t = n-1;
  a = 0;
  while IsEven(t) do
   (
    t=t/2;
    a=a+1;
   );

  p = 1;

  do (
    b = randint(n-2)+2;
    if gcd (b, n) != 1 then return 0;
    if not StrongPseudoprimeTestSub (n, a, t, b) then return 0;
    p = p*0.25;
  ) while p > epsilon;
  1
)
SetHelp("MillerRabinTest", "number_theory", "Use the Miller-Rabin test on n, such that the probability of false positive is less then epsilon");
protect("MillerRabinTest")

function MillerRabinTestSure(n) =
(
  if not IsInteger(n) or n <= 2 then
    (error("MillerRabinTestSure: n not an odd positive integer"); bailout);

  # Find t and a satisfying n-1=2^a*t, t odd
  t = n-1;
  a = 0;
  while IsEven(t) do
   (
    t=t/2;
    a=a+1;
   );

  m = floor(2*log(n,2)^2);

  b = 2;
  do (
    if gcd (b, n) != 1 then return 0;
    if not StrongPseudoprimeTestSub (n, a, t, b) then return 0;
    b = b+1;
  ) while b <= m;
  1
)
SetHelp("MillerRabinTestSure", "number_theory", "Use the Miller-Rabin test on n, assuming the Generalized Reimann Hypothesis so the result is deterministic");
protect("MillerRabinTestSure")

#################################################
#### FIXME: Certify primality/compositeness #####
#################################################
# 



#######################################
############## Misc ###################
#######################################

SetHelp("LucasLehmer","number_theory","Test if Mp is a Mersenne prime using the Lucas-Lehmer test");
function LucasLehmer(p) = (
        if IsMatrix(p) then
                return ApplyOverMatrix(p, LucasLehmer)
	else if not IsPositiveInteger(p) then
		(error("LucasLehmer: argument not an integer larger then 0");bailout);
	if p==1 then return 0
	else if p==2 then return 1;
	S = 4;
	n = 1;
	Mp = (2^p) - 1;
	while n<p-1 do (
		S = ((S^2) - 2) % Mp;
		n = n+1
	);
	if S == 0 then
		return 1
	else
		return 0
);
protect("LucasLehmer")
