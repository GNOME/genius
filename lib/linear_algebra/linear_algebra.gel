# Some linear algebra functions

# Transpose of a matrix
SetHelp ("Transpose", "linear_algebra", "Transpose of a matrix")
function Transpose(M)=M.'
protect ("Transpose")

# Conjugate Transpose of a matrix
SetHelp ("ConjugateTranspose", "linear_algebra", "Conjugate transpose of a matrix (adjoint)")
function ConjugateTranspose(M)=M'
protect ("Conjugate Transpose")

#FIXME: We'll need more sophisticated tools for Tensors

# Pivot Columns
# Given a matrix in rref form, the columns which have a leading 1
# in some row are the pivot columns.
# (also returns in which row they occur)
function PivotColumns(M) =
  (
    N=rref(M);
    col_dim_N=columns(N);
    pivot_columns=[0];
    for loop=1 to min(rows(N),col_dim_N) do
     (
       for inner_loop=loop to col_dim_N do
         if N@(loop,inner_loop) != 0 then
          (pivot_columns=[pivot_columns,[inner_loop;loop]];break;);
     );
   DeleteColumn(pivot_columns,1)
  )
protect ("PivotColumns")

# Non-pivot columns
function NonPivotColumns(M) =
  (
#FIXME: this should be a separate function
#(actually, we should have a sequence construct!)
    non_pivot=[0];
    for loop=1 to columns(M) do
      non_pivot=[non_pivot,loop];
    non_pivot=DeleteColumn(non_pivot,1);
    SetMinus(non_pivot,PivotColumns(M)@(1,))
  )
protect ("NonPivotColumns")

# Delete a row from a matrix
# Shamelessly copied from DeleteRowColumn
SetHelp("DeleteRow", "matrix", "Delete a row of a matrix")
function DeleteRow(M,row) = (
        row_dim_M=rows(M);
        if row_dim_M==1 then return null;   # if delete the only row...
	     if row==1         then M@(2..row_dim_M,)
        else if row==row_dim_M then M@(1..row_dim_M-1,)
        else                       [M@(1..row-1,);M@(row+1..row_dim_M,)]
)
protect ("DeleteRow")

# Delete a column from a matrix
# Also shamelessly copied from DeleteRowColumn
SetHelp("DeleteColumn", "matrix", "Delete a column of a matrix")
function DeleteColumn(M,col) = (
        col_dim_M=columns(M);
        if col_dim_M==1 then return null;   # if delete the only column...
	     if col==1         then M@(,2..col_dim_M)
        else if col==col_dim_M then M@(,1..col_dim_M-1)
        else                       [M@(,1..col-1),M@(,col+1..col_dim_M)]
)
protect ("DeleteColumn")

# Column Reduced Echelon Form
SetHelp("cref", "linear_algebra", "Compute the Column Reduced Echelon Form")
function cref(M)=Transpose(rref(Transpose(M)))
protect ("cref")
SetHelpAlias ("cref", "CREF")
CREF = cref
protect ("CREF")
SetHelpAlias ("cref", "ColumnReducedEchelonForm")
ColumnReducedEchelonForm = cref
protect ("ColumnReducedEchelonForm")

#This removes any all-zero columns of M
SetHelp ("StripZeroColumns", "matrix", "Removes any all-zero columns of M")
function StripZeroColumns (M) =
 (
  if not IsMatrix (M) then
    (error("StripZeroColumns: argument not a matrix");bailout);
  row_dim_M=rows(M);
  N=[0];
  for loop=1 to columns(M) do
  (
#FIXME: this could be made more efficient
   zero_flag=1;
   for inner_loop=1 to row_dim_M do
#    if M@(inner_loop,loop)!=0 then (zero_flag=0;break;);
    zero_flag=(zero_flag and (M@(inner_loop,loop)==0));
   if not(zero_flag) then N=[N,M@(,loop)];
  );
  DeleteColumn(N,1)
 )
protect ("StripZeroColumns")

SetHelp ("StripZeroRows", "matrix", "Removes any all-zero rows of M")
function StripZeroRows (M) =
(
  if not IsMatrix (M) then
    (error("StripZeroColumns: argument not a matrix");bailout);
  Transpose (StripZeroColumns (Transpose (M)))
)
protect ("StripZeroRows")

# Cross product of two vectors (in R^3)
##<refentry id="fun-linear-algebra-cross-product">
##<indexterm zone="fun-linear-algebra-cross-product">
##<primary>CrossProduct</primary>
##</indexterm>
##<indexterm>
##<primary>cross product</primary>
##<see>CrossProduct</see>
##</indexterm>
##
##  <refmeta>
##    <refentrytitle>CrossProduct</refentrytitle>
##  </refmeta>
##
##  <refnamediv>
##    <refname>CrossProduct</refname>
##    <refpurpose>compute the cross product of two vectors</refpurpose>
##  </refnamediv>
##
##      <funcprototype>
##        <funcdef>Vector <function>CrossProduct</function></funcdef>
##        <paramdef>Vector <parameter>v</parameter></paramdef>
##        <paramdef>Vector <parameter>w</parameter></paramdef>
##      </funcprototype>
##    </funcsynopsis>
##  </refsynopsisdiv>
##
##  <refsect1>
##    <title>Description</title>
##    <para><function>CrossProduct</function> computes the cross product
##    of the vectors <parameter>v</parameter> and <parameter>w</parameter>,
##    which need to be vectors in R<sup>3</sup>. FIXME: generalize to n-1
##    vectors in R<sup>n</sup>.</para>
##    <para>FIXME: define it, talk about it</para>
##  </refsect1>
##  <refsect1>
##    <title>Examples</title>
##    <para>Some examples...FIXME</para>
##  </refsect1>
##</refentry>
SetHelp ("CrossProduct", "linear_algebra", "CrossProduct of two vectors in R^3")
function CrossProduct(v,w) =
 (
  M=[v;w;1,1,1];
  [Minor(M,3,1),Minor(M,3,2),Minor(M,3,3)]
 )
protect ("CrossProduct")

# Direct sum of a vector of matrices
SetHelp ("DirectSumMatrixVector", "linear_algebra", "Direct sum of a vector of matrices")
function DirectSumMatrixVector(v) = (
  if not IsMatrix (v) or rows (v) > 1 then
    (error("DirectSumMatrixVector: argument not a horizontal vector");bailout);
  if columns (v) == 1 then
    [v@(1)]
  else if columns (v) == 2 then
    [v@(1),0;0,v@(2)]
  else
    [v@(1),0;0,DirectSumMatrixVector(v@(1,2..columns(v)))] 
)
protect ("DirectSumMatrixVector");

# Direct sum of matrices
SetHelp ("DirectSum", "linear_algebra", "Direct sum of matrices")
function DirectSum(M,N...) = (
  if IsNull (N) then
    [M] 
  else if columns(N) == 1 then
    [M,0;0,N@(1)] 
  else
    [M,0;0,DirectSumMatrixVector(N)] 
)
protect ("DirectSum");

# (Kronecker) Tensor product of two matrices
#FIXME!
# function KroneckerProduct(M,N) = TensorProduct(M,N)
# function TensorProduct(M,N) = Null

# Checks to see if a matrix/value is invertible
# Note that given an integer matrix, returns true iff it is invertible OVER THE INTEGERS,
# so for instance [2,0;0,1] is not invertible
# FIXME: We need good coercion rules!
function IsInvertible(n) =
(
 if (IsInteger(n)) then return (|n|==1)     # Only invertible integers are 1, -1
 else if (IsValue(n)) then return (n!=0)    # Elements of fields (Q,R,C) are invertible iff != 0
 else if (IsMatrix(n)) then (if IsMatrixSquare(n) then return (IsInvertible(det(n))) else return 0);
                                             # Matrices are invertible iff they are square and their
                                             #  determinant is a unit
 error ("IsInvertible: argument not a value or matrix");bailout
)
protect ("IsInvertible")

function IsInvertibleField(n) =
(
 if (IsValue(n)) then return (n!=0)    # Elements of fields (Q,R,C) are invertible iff != 0
 else if (IsMatrix(n)) then (if IsMatrixSquare(n) then return (IsInvertible(det(n))) else return 0);
                                             # Matrices are invertible iff they are square and their
                                             #  determinant is a unit
 error ("IsInvertibleField: argument not a value or matrix");bailout
)
protect ("IsInvertibleField")

# Hermite Form for fields (will end up with 1's on the diagonal)
SetHelp("HermiteFormField", "linear_algebra", "Hermite Form for fields (will end up with 1's on the diagonal)")
function HermiteFormField(A) =
(
  Transpose (ref (Transpose (ref (A))))
)
protect ("HerminteFormField")

# AuxilliaryUnitMatrix
SetHelp("AuxilliaryUnitMatrix", "linear_algebra", "Get the auxilliary unit matrix of size n")
function AuxilliaryUnitMatrix(n) =
(
  if not IsInteger (n) or n < 2 then
    (error ("AuxilliaryUnitMatrix: n must be an integer greater then 1");bailout)
  else
    [0,I(n-1);0,0]
)
protect ("AuxilliaryUnitMatrix")
SetHelpAlias("AuxilliaryUnitMatrix", "U")
function U(n) = AxilliaryUnitMatrix(n)
protect ("U")

# AuxilliaryUnitMatrix
SetHelp("JordanBlock", "linear_algebra", "Get the jordan block corresponding to lambda and n")
function JordanBlock(lambda,n) =
(
  if not IsInteger (n) or n < 1 then
    (error ("JordanBlock: n must be an integer greater then 0");bailout)
  else if not IsValue (n) or n < 1 then
    (error ("JordanBlock: lambda must be a value");bailout)
  else if n == 1 then
    [lambda]
  else
    lambda * I(n) + AuxilliaryUnitMatrix(n)
)
protect ("JordanBlock")
SetHelpAlias("JordanBlock", "J")
function J(lambda,n) = JordanBlock(lambda,n)
protect ("J")

# Dot product
SetHelp("DotProduct", "matrix", "Get the dot product of two vectors")
function DotProduct(u,v) =
(
  if not IsVector (u) or not IsVector (v) then
    (error ("DotProduct: u,v must be vectors");bailout)
  else if columns (u) == 1 and columns (v) == 1 then
    ( u .' * v )@(1)
  else if rows (u) == 1 and columns (v) == 1 then
    ( u * v )@(1)
  else if rows (u) == 1 and rows (v) == 1 then
    ( u * ( v .' ) )@(1)
  else # if columns (u) == 1 and rows (v) == 1 then
    ( ( u .' ) * ( v .' ) )@(1)
)
protect ("DotProduct")

# Norms
SetHelp("L2Norm", "linear_algebra", "Get the L-2 Norm of a vector");
function L2Norm(v) = (
  if not IsVector (v) then
    (error ("L2Norm: v must be a vector");bailout)
  else
    sqrt (DotProduct (v,v))
)
protect("L2Norm")
SetHelpAlias ("L2Norm", "Norm")
Norm = L2Norm
protect("Norm")

SetHelp("LInfNorm", "linear_algebra", "Get the L-Inf Norm of a vector");
function LInfNorm(v) = (
  if not IsVector (v) then
    (error ("LInfNorm: v must be a vector");bailout)
  else
    max (|v|)
)
protect("LInfNorm")

SetHelp("LpNorm", "linear_algebra", "Get the L-p Norm of a vector");
function LpNorm(v,p) = (
  if not IsVector (v) then
    (error ("LpNorm: v must be a vector");bailout)
  else
    (sum k in v do (|k|^p))^(1/p)
)
protect("LpNorm")

SetHelp ("CharacteristicPolynomial", "linear_algebra", "Get the characteristic polynomial as a vector")
function CharacteristicPolynomial(M) = (
	if not IsMatrix (M) or not IsMatrixSquare(M) then
		(error ("CharacteristicPolynomial: M must be a square matrix");bailout);

	n = columns(M);
	v = [ det (M) ];
	for i=2 to n-1 do
		v@(i) = (-1) ^ (i-1) * sum gamma in GAMMA(n-i+1,n) do det (Submatrix (M, gamma, gamma));
	v@(n) = (-1) ^ (n-1) * trace (M);
	v@(n+1) = (-1) ^ n;
	v
)
protect("CharacteristicPolynomial")
SetHelpAlias ("CharacteristicPolynomial", "CharPoly")
CharPoly = CharacteristicPolynomial
protect("CharPoly")

SetHelp ("CharacteristicPolynomialFunction", "linear_algebra", "Get the characteristic polynomial as a function")
function CharacteristicPolynomialFunction(M) = PolyToFunction (CharacteristicPolynomial (M))
protect("CharacteristicPolynomialFunction")
