#FIXME: This should be catalogued a bit better.

function ApplyOverMatrix(a,func) = (
	if(not IsMatrix(a)) then
		(error("ApplyOverMatrix: argument 1 must be a matrix");bailout)
	else if(not IsFunction(func)) then
		(error("ApplyOverMatrix: argument 2 must be a function");bailout);
	for i = 1 to rows(a) do (
		for j = 1 to columns(a) do (
			r@(i,j) = func(a@(i,j))
		)
	);
	r
);
protect("ApplyOverMatrix")

function ApplyOverMatrix2(a,b,func) = (
	if(not IsMatrix(a) and not IsMatrix(b)) then
		(error("ApplyOverMatrix2: argument 1 or 2 must be a matrix");bailout)
	else if(not IsFunction(func)) then
		(error("ApplyOverMatrix2: argument 3 must be a function");bailout)

	else if(IsMatrix(a) and IsMatrix(b) and
		(rows(a)!=rows(b) or columns(a)!=columns(b))) then
		(error("ApplyOverMatrix2: cannot apply a function over two matrixes of different sizes");bailout);
	
	for i = 1 to rows(a) do (
		for j = 1 to columns(a) do (
			if(IsMatrix(a)) then
				aa = a@(i,j)
			else
				aa = a;
			if(IsMatrix(b)) then
				bb = b@(i,j)
			else
				bb = b;
			r@(i,j) = func(aa,bb)
		)
	);
	r
);
protect("ApplyOverMatrix2")

#calculate a trace function
SetHelp("Trace", "linear_algebra","Calculate the trace of a matrix");
function Trace(m) = (
	if(not IsMatrix(m) or not IsValueOnly(m)) then
		(error("Trace: argument not a value only matrix");bailout)
	else if(rows(m)!=columns(m)) then
		(error("Trace: matrix not a square");bailout);
	a=0;
	for i = 1 to rows(m) do (a=a+m@(i,i))
);
protect("Trace")
SetHelpAlias("Trace", "trace")
trace = Trace
protect("trace")

#calculate convolution of two horizontal vectors
SetHelp("Convolution", "linear_algebra","Calculate convolution of two horizontal vectors");
function Convolution(a,b) = (
	if(not IsMatrix(a) or not IsValueOnly(a) or
	   not IsMatrix(b) or not IsValueOnly(b) or
	   rows(a)>1 or rows(b)>1) then
		(error("Convolution: arguments not value only horizontal vectors");bailout)
	else if(columns(a)!=columns(b)) then
		(error("Convolution: arguments must be identical vectors");bailout);
	s = 0;
	for i = 1 to columns(a) do (
		s = s + a@(1,i)*b@(1,columns(a)-i+1)
	)
);
protect("Convolution")
SetHelpAlias("Convolution", "convolution")
convol = Convolution
protect("convol")

#calculate convolution of two horizontal vectors and return the result
#not added together but in a vector
SetHelp("ConvolutionVector", "linear_algebra","Calculate convolution of two horizontal vectors");
function ConvolutionVector(a,b) = (
	if(not IsMatrix(a) or not IsValueOnly(a) or
	   not IsMatrix(b) or not IsValueOnly(b) or
	   rows(a)>1 or rows(b)>1) then
		(error("ConvolutionVector: arguments not value only horizontal vectors");bailout)
	else if(columns(a)!=columns(b)) then
		(error("ConvolutionVector: arguments must be identical vectors");bailout);
	r = SetMatrixSize ([0],1,columns(a));
	for i = 1 to columns(a) do (
		r@(1,i) = a@(1,i)*b@(1,columns(a)-i+1)
	);
	r
);
protect("ConvolutionVector")

#calculate the sum of all elements in a matrix
SetHelp("MatrixSum", "matrix","Calculate the sum of all elements in a matrix");
function MatrixSum(a) = (
	if(not IsMatrix(a) or not IsValueOnly(a)) then
		(error("MatrixSum: argument not a value only matrix");bailout);
	sum n in a do n
);
protect("MatrixSum")

SetHelp("MatrixSumSquares", "matrix","Calculate the sum of squares of all elements in a matrix");
function MatrixSumSquares(a) = (
	if(not IsMatrix(a) or not IsValueOnly(a)) then
		(error("MatrixSumSquares: argument not a value only matrix");bailout);
	sum n in a do n^2
);
protect("MatrixSumSquares")

#calculate the product of all elements in a matrix
SetHelp("MatrixProduct","matrix", "Calculate the product of all elements in a matrix")
function MatrixProduct(a) = (
	if(not IsMatrix(a) or not IsValueOnly(a)) then
		(error("matprod: argument not a value only matrix");bailout);
	prod n in a do n
);
protect("MatrixProduct")

SetHelp("Submatrix", "matrix", "Return column(s) and row(s) from a matrix")
function Submatrix(m,r,c) = (
	if not IsMatrix(m) or
	   (not IsInteger(r) and not IsVector (r)) or
	   (not IsInteger(c) and not IsVector (r)) then
		(error("Submatrix: arguments are not the right type");bailout);
	if not IsVector (r) then
		r = [r];
	if not IsVector (c) then
		c = [c];
	ret = SetMatrixSize ([0], elements (r), elements (c));
	for i=1 to elements(r) do
		for j=1 to elements(c) do
			ret@(i,j) = m@(r@(i),c@(j));
	ret
)
protect ("Submatrix")

SetHelp ("IndexComplement", "matrix", "Return the index complement of a vector of indexes (must be sorted)")
function IndexComplement (v, n) = (
	if not IsVector(v) then
		(error("IndexComplement: arguments are not the right type");bailout);
	r = [0];
	j=1;
	k=1;
	for i=1 to n do (
		if j <= elements(v) and v@(j) == i then (
			j = j+1
		) else (
			r@(k) = i;
			k = k+1
		)
	);
	r
)
protect ("IndexComplement")

SetHelp("DeleteRowColumn", "matrix", "Remove column and row from a matrix");
function DeleteRowColumn(m,row,col) = (
	if(not IsMatrix(m) or not IsInteger(row) or not IsInteger(col)) then
		(error("DeleteRowColumn: arguments are not the right type");bailout)
	else if(row>rows(m) or col>columns(m)) then
		(error("DeleteRowColumn: arguments out of range");bailout);
	if row==1 then (
		if col==1 then
			m@(2..rows(m),2..columns(m))
		else if col==columns(m) then
			m@(2..rows(m),1..columns(m)-1)
		else
			[m@(2..rows(m),1..col-1),\
			 m@(2..rows(m),col+1..columns(m))]
	) else if row==rows(m) then (
		if col==1 then
			m@(1..rows(m)-1,2..columns(m))
		else if col==columns(m) then
			m@(1..rows(m)-1,1..columns(m)-1)
		else
			[m@(1..rows(m)-1,1..col-1),\
			 m@(1..rows(m)-1,col+1..columns(m))]
	) else (
		if col==1 then
			[m@(1..row-1,2..columns(m))
			 m@(row+1..rows(m),2..columns(m))]
		else if col==columns(m) then
			[m@(1..row-1,1..columns(m)-1)
			 m@(row+1..rows(m),1..columns(m)-1)]
		else
			[m@(1..row-1,1..col-1),m@(1..row-1,col+1..columns(m))
			 m@(row+1..rows(m),1..col-1),\
			 m@(row+1..rows(m),col+1..columns(m))]
	)
);
protect("DeleteRowColumn")

SetHelp("ComplementSubmatrix", "matrix", "Remove column(s) and row(s) from a matrix");
function ComplementSubmatrix(m,r,c) = (
	if IsInteger(r) and IsInteger(c) then
		DeleteRowColumn (m, r, c)
	else
		Submatrix (m, IndexComplement (r, rows(m)), IndexComplement (c, columns(m)))
)
protect ("ComplementSubmatrix")

# Minor of a matrix (determinant of a submatrix given by deleting
# one row and one column)
SetHelp("Minor","linear_algebra", "Get the i-j minor of a matrix")
function Minor(M,i,j) = det (ComplementSubmatrix (M, i, j))
protect("Minor");

#classical adjoint (adjugate) of a matrix
SetHelp("adj","linear_algebra", "Get the classical adjoint (adjugate) of a matrix");
function adj(m) = (
	if(not IsMatrix(m) or not IsValueOnly(m)) then
		(error("adj: argument not a value-only matrix");bailout)
	else if(rows(m)!=columns(m)) then
		(error("adj: argument not a square matrix");bailout)
	else if(rows(m)<2) then
		(error("adj: argument cannot be 1x1 matrix");bailout);

	a = SetMatrixSize ([0],rows(m),rows(m));
	for i = 1 to rows(m) do (
		for j = 1 to rows(m) do (
			a@(j,i) = ((-1)^(i+j))*Minor(m,i,j);
		);
	);
	a
);
protect("adj")
SetHelpAlias ("adj", "Adjugate")
Adjugate = adj
protect("Adjugate")

SetHelp("MinimizeFunction","functions","Find the first value where f(x)=0");
function MinimizeFunction(func,x,incr) = (
	if(not IsValue(x) or not IsValue(incr)) then
		(error("MinimizeFunction: x,incr arguments not values");bailout)
	else if(not IsFunction(func)) then
		(error("MinimizeFunction: func argument not a function");bailout);
	while(func(x)>0) do x=x+incr;
	x
);
protect("MinimizeFunction")

SetHelp("MakeDiagonal","matrix","Make diagonal matrix from a vector");
function MakeDiagonal(v,arg...) = (
	if IsValue (v) and IsNull (arg) then
		return [v]
	else if IsMatrix (v) and IsNull (arg) then
		m = v
	else if IsValue (v) and IsMatrix (arg) then
		m = [v,arg]
	else
		(error("MakeDiagonal: arguments not a vector or a list of values");bailout);
	r = SetMatrixSize ([0],elements(m),elements(m));
	for i = 1 to elements(m) do (
		r@(i,i) = m@(i)
	);
	r
);
protect("MakeDiagonal")
SetHelpAlias("MakeDiagonal","diag")
diag = MakeDiagonal
protect("diag")

SetHelp("SwapRows","matrix","Swap two rows in a matrix");
function SwapRows(m,row1,row2) = (
	if(not IsMatrix(m) or not IsInteger(row1) or
	   not IsInteger(row2)) then
		(error("SwapRows: arguments are not the right type");bailout)
	else if(row1>rows(m) or row2>rows(m)) then
		(error("SwapRows: argument out of range");bailout)
	else if(row1 != row2) then (
		tmp = m@(row1,);
		m@(row1,) = m@(row2,);
		m@(row2,) = tmp
	);
	m
);
protect("SwapRows")

SetHelp("RowSum","matrix","Calculate sum of each row in a matrix");
function RowSum(m) = (
	if not IsMatrix(m) then
		(error("RowSum: argument not matrix");bailout);
	r = SetMatrixSize ([0],rows(m),1);
	for i = 1 to rows(m) do (
		for j = 1 to columns(m) do
			r@(i,1) = r@(i,1) + m@(i,j)
	);
	r
);
protect("RowSum")

SetHelp("RowSumSquares","matrix","Calculate sum of squares of each row in a matrix");
function RowSumSquares(m) = (
	if not IsMatrix(m) then
		(error("RowSumSquares: argument not matrix");bailout);
	r = SetMatrixSize ([0],rows(m),1);
	for i = 1 to rows(m) do (
		for j = 1 to columns(m) do
			r@(i,1) = r@(i,1) + m@(i,j)^2
	);
	r
);
protect("RowSumSquares")

#sort a horizontal vector
SetHelp("SortVector","matrix","Sort vector elements");
function SortVector(v) = (
	if not IsVector(v) then
		(error("SortVector: argument not a vector");bailout);
	j = 1;
	do (
		sorted = 1;
		for i = 1 to elements(v)-j do (
			if v@(i)>v@(i+1) then (
				t = v@(i);
				v@(i) = v@(i+1);
				v@(i+1) = t;
				sorted = 0
			)
		);
		j=j+1
	) while not sorted;
	v
);
protect("SortVector")

SetHelp("ReverseVector","matrix","Reverse elements in a vector");
function ReverseVector(v) = (
	if not IsVector(v) then
		(error("ReverseVector: argument not a vector");bailout);
	r = SetMatrixSize ([0],rows(v),columns(v));
	for i = 1 to elements(v) do
		r@(i) = v@(elements(v)-i+1);
	r
);
protect("ReverseVector")

SetHelp("IsVector", "matrix", "Is argument a horizontal or a vertical vector")
function IsVector(v) = (IsMatrix(v) and (columns(v) == 1 or rows(v) == 1))
protect("IsVector")

SetHelp("UpperTriangular", "matrix", "Zero out entries below the diagonal")
function UpperTriangular(M) = (
	if not IsMatrix(M) or not IsMatrixSquare(M) then
		(error("UpperTriangular: argument not a square matrix");bailout);
	for i=2 to rows(M) do (
		for j=1 to i-1 do (
			M@(i,j) = 0
		)
	);
	M
)
protect ("UpperTriangular")

SetHelp("LowerTriangular", "matrix", "Zero out entries above the diagonal")
function LowerTriangular(M) = (
	if not IsMatrix(M) or not IsMatrixSquare(M) then
		(error("LowerTriangular: argument not a square matrix");bailout);
	UpperTriangular (M.').'
)
protect ("LowerTriangular")

SetHelp("NextIndexVectorCombination", "matrix", "Next combination of index vectors")
function NextIndexVectorCombination(v,n) = (
	i = elements(v);
	while i > 0 and v@(i) == n-(elements(v)-i) do
		i = i-1;
	if i == 0 then
		null
	else (
		v@(i) = v@(i) + 1;
		for j=i+1 to elements(v) do
			v@(j) = v@(j-1)+1;
		v
	)
)
protect ("NextIndexVectorCombination")

SetHelp("GAMMA", "matrix", "Get all combinations of index vectors of size k up to n")
function GAMMA(k,n) = (
	if not IsInteger(k) or not IsInteger(n) then
		(error("GAMMA: arguments not integers");bailout)
	else if k < 1 or n < 1 or k > n then
		(error("GAMMA: arguments out of range");bailout);
	v=[0];
	for i=1 to k do
		v@(i) = i;
	ret = [0];
	i=1;
	do (
		# Makes this a column vector for nice display
		ret@(i,1) = v;
		i = i+1;
		v = NextIndexVectorCombination (v, n)
	) while not IsNull(v);
	ret
)
protect ("GAMMA")

SetHelp("CompoundMatrix", "matrix", "Calculate the kth compund matrix of A")
function CompoundMatrix(k,A) = (
	if not IsInteger(k) or k < 1 or k > min(columns(A),rows(A)) or not IsMatrix(A) then
		(error("CompoundMatrix: arguments of right type/size");bailout);
	C=[0];
	gamma = GAMMA(k,rows(A));
	omega = GAMMA(k,columns(A));
	for i=1 to elements(gamma) do
		for j=1 to elements(omega) do
			C@(i,j) = det (Submatrix (A, gamma@(i),omega@(j)));
	C
)
protect ("CompoundMatrix")
