char *fake = N_("Compose two functions");
char *fake = N_("Compose a function with itself n times, passing x as argument, and returning x if n == 0");
char *fake = N_("Print a table of values for f(n) for numbers from vector v, or if v is a number for integers from 1 to v");
char *fake = N_("Make a string");
char *fake = N_("Tolerance of the Chop function");
char *fake = N_("How many iterations to try to find the limit for continuity and limits");
char *fake = N_("How many successive steps to be within tolerance for calculation of continuity");
char *fake = N_("Tolerance for continuity of functions and for calculating the limit");
char *fake = N_("How many iterations to try to find the limit for derivative");
char *fake = N_("How many successive steps to be within tolerance for calculation of derivative");
char *fake = N_("Tolerance for calculating the derivatives of functions");
char *fake = N_("Tolerance of the ErrorFunction (used for complex values only)");
char *fake = N_("Tolerance of the GaussDistribution function");
char *fake = N_("The function used for numerical integration in NumericalIntegral (by default CompositeSimpsonsRule)");
char *fake = N_("Steps to perform in NumericalIntegral");
char *fake = N_("How many iterations to try for InfiniteSum and InfiniteProduct");
char *fake = N_("How many successive steps to be within tolerance for InfiniteSum and InfiniteProduct");
char *fake = N_("Tolerance for InfiniteSum and InfiniteProduct");
char *fake = N_("Absolute value");
char *fake = N_("Replace very small number with zero");
char *fake = N_("Return the fractional part of a number");
char *fake = N_("Return the sign (-1,0,1)");
char *fake = N_("Logarithm of any base (calls DiscreteLog if in modulo mode), if base is not given, e is used");
char *fake = N_("The arccos (inverse cos) function");
char *fake = N_("The arccosh (inverse cosh) function");
char *fake = N_("The arccot (inverse cot) function");
char *fake = N_("The arccoth (inverse coth) function");
char *fake = N_("The inverse cosecant function");
char *fake = N_("The inverse hyperbolic cosecant function");
char *fake = N_("The inverse secant function");
char *fake = N_("The inverse hyperbolic secant function");
char *fake = N_("The arcsin (inverse sin) function");
char *fake = N_("The arcsinh (inverse sinh) function");
char *fake = N_("The arctanh (inverse tanh) function");
char *fake = N_("The cotangent function");
char *fake = N_("The hyperbolic cotangent function");
char *fake = N_("The cosecant function");
char *fake = N_("The hyperbolic cosecant function");
char *fake = N_("The secant function");
char *fake = N_("The hyperbolic secant function");
char *fake = N_("The hyperbolic tangent function");
char *fake = N_("Are a and b relatively prime?");
char *fake = N_("Return the nth Bernoulli number");
char *fake = N_("Find the x that solves the system given by the vector a and modulo the elements of m, using the Chinese Remainder Theorem");
char *fake = N_("Given two factorizations, give the factorization of the product, see Factorize");
char *fake = N_("Convert a vector of values indicating powers of b to a number");
char *fake = N_("Convert a number to a vector of powers for elements in base b");
char *fake = N_("Find discrete log of n base b in F_q where q is a prime using the Silver-Pohlig-Hellman algorithm");
char *fake = N_("Compute phi(n), the Euler phi function, that is the number of integers between 1 and n relatively prime to n");
char *fake = N_("Return all factors of a number");
char *fake = N_("Attempt Fermat factorization of n into (t-s)*(t+s), returns t and s as a vector if possible, null otherwise");
char *fake = N_("Find the first primitive element in F_q (q must be a prime)");
char *fake = N_("Find a random primitive element in F_q (q must be a prime)");
char *fake = N_("Compute discrete log base b of n in F_q (q a prime) using the factor base S.  S should be a column of primes possibly with second column precalculated by IndexCalculusPrecalculation.");
char *fake = N_("Run the precalculation step of IndexCalculus for logarithms base b in F_q (q a prime) for the factor base S (where S is a column vector of primes).  The logs will be precalculated and returned in the second column.");
char *fake = N_("Test if Mp is a Mersenne prime using a table");
char *fake = N_("Tests if a rational number is a perfect power");
char *fake = N_("Check if g is primitive in F_q, where q is a prime.  If q is not prime results are bogus.");
char *fake = N_("Check if g is primitive in F_q, where q is a prime and f is a vector of prime factors of q-1.  If q is not prime results are bogus.");
char *fake = N_("If n is a pseudoprime base b but not a prime, that is if b^(n-1) == 1 mod n");
char *fake = N_("Test if n is a strong pseudoprime to base b but not a prime");
char *fake = N_("Return the residue of a mod n with the least absolute value (in the interval -n/2 to n/2)");
char *fake = N_("Test if Mp is a Mersenne prime using the Lucas-Lehmer test");
char *fake = N_("Return all maximal prime power factors of a number");
char *fake = N_("Vector with the known Mersenne prime exponents");
char *fake = N_("Return the Moebius mu function evaluated in n");
char *fake = N_("Returns the p-adic valuation (number of trailing zeros in base p).");
char *fake = N_("Compute a^b mod m");
char *fake = N_("Return all prime factors of a number");
char *fake = N_("Pseudoprime test, true if and only if b^(n-1) == 1 (mod n)");
char *fake = N_("Removes all instances of the factor m from the number n");
char *fake = N_("Find discrete log of n base b in F_q where q is a prime using the Silver-Pohlig-Hellman algorithm, given f being the factorization of q-1");
char *fake = N_("Find square root of n mod p (a prime). Null is returned if not a quadratic residue.");
char *fake = N_("Apply a function over all entries of a matrix and return a matrix of the results");
char *fake = N_("Apply a function over all entries of 2 matrices (or 1 value and 1 matrix) and return a matrix of the results");
char *fake = N_("Remove column(s) and row(s) from a matrix");
char *fake = N_("Calculate the kth compound matrix of A");
char *fake = N_("Delete a column of a matrix");
char *fake = N_("Delete a row of a matrix");
char *fake = N_("Get the dot product of two vectors (no conjugates)");
char *fake = N_("Zero out entries above the diagonal");
char *fake = N_("Make diagonal matrix from a vector");
char *fake = N_("Make column vector out of matrix by putting rows after each other");
char *fake = N_("Make column vector out of matrix by putting columns above each other");
char *fake = N_("Calculate the product of all elements in a matrix");
char *fake = N_("Calculate the sum of all elements in a matrix");
char *fake = N_("Calculate the sum of squares of all elements in a matrix");
char *fake = N_("Get the outer product of two vectors");
char *fake = N_("Reverse elements in a vector");
char *fake = N_("Calculate sum of each row in a matrix");
char *fake = N_("Calculate sum of squares of each row in a matrix");
char *fake = N_("Shuffle elements in a vector");
char *fake = N_("Sort vector elements");
char *fake = N_("Removes any all-zero rows of M");
char *fake = N_("Return column(s) and row(s) from a matrix");
char *fake = N_("Swap two rows in a matrix");
char *fake = N_("Zero out entries below the diagonal");
char *fake = N_("Get the auxiliary unit matrix of size n");
char *fake = N_("Evaluate (v,w) with respect to the bilinear form given by the matrix A");
char *fake = N_("Return a function that evaluates two vectors with respect to the bilinear form given by A");
char *fake = N_("Get the characteristic polynomial as a vector");
char *fake = N_("Get the characteristic polynomial as a function");
char *fake = N_("Get a basis matrix for the columnspace of a matrix");
char *fake = N_("Return the commutation matrix K(m,n) which is the unique m*n by m*n matrix such that K(m,n) * MakeVector(A) = MakeVector(A.') for all m by n matrices A.");
char *fake = N_("Companion matrix of a polynomial (as vector)");
char *fake = N_("Conjugate transpose of a matrix (adjoint)");
char *fake = N_("Calculate convolution of two horizontal vectors");
char *fake = N_("Calculate convolution of two horizontal vectors");
char *fake = N_("CrossProduct of two vectors in R^3");
char *fake = N_("Get the determinantal divisors of an integer matrix");
char *fake = N_("Direct sum of matrices");
char *fake = N_("Direct sum of a vector of matrices");
char *fake = N_("Get the eigenvalues of a matrix (Currently only for up to 4x4 or triangular matrices)");
char *fake = N_("Get the eigenvalues and eigenvectors of a matrix (Currently only for up to 2x2 matrices)");
char *fake = N_("Apply the Gram-Schmidt process (to the columns) with respect to inner product given by B (if not given use Hermitian product)");
char *fake = N_("Hankel matrix");
char *fake = N_("Hilbert matrix of order n");
char *fake = N_("Get the image (columnspace) of a linear transform");
char *fake = N_("Get the Inf Norm of a vector");
char *fake = N_("Get the invariant factors of a square integer matrix");
char *fake = N_("Inverse Hilbert matrix of order n");
char *fake = N_("Is a matrix Hermitian");
char *fake = N_("Test if a vector is in a subspace");
char *fake = N_("Is a matrix (or number) invertible (Integer matrix is invertible if and only if it is invertible over the integers)");
char *fake = N_("Is a matrix (or number) invertible over a field");
char *fake = N_("Is a matrix normal");
char *fake = N_("Is a matrix positive definite");
char *fake = N_("Is a matrix positive semidefinite");
char *fake = N_("Is a matrix skew-Hermitian");
char *fake = N_("Is a matrix unitary");
char *fake = N_("Get the Jordan block corresponding to lambda and n");
char *fake = N_("Get the kernel (nullspace) of a linear transform");
char *fake = N_("Compute the Kronecker product of two matrices");
char *fake = N_("Get the LU decomposition of A and store the result in the L and U which should be references.  If not possible returns false.");
char *fake = N_("Get the i-j minor of a matrix");
char *fake = N_("Return the columns that are not the pivot columns of a matrix");
char *fake = N_("Get the p Norm (or 2 Norm if no p is supplied) of a vector");
char *fake = N_("Get the nullity of a matrix");
char *fake = N_("Get the orthogonal complement of the columnspace");
char *fake = N_("Projection of vector v onto subspace W given a sesquilinear form B (if not given use Hermitian product)");
char *fake = N_("Get the QR decomposition of A, returns R and Q can be a reference");
char *fake = N_("Get the rank of a matrix");
char *fake = N_("Return the Rayleigh quotient of a matrix and a vector");
char *fake = N_("Compute an eigenvalue using the Rayleigh Quotient Iteration method until we are epsilon from eigenvalue or for maxiter iterations");
char *fake = N_("Rosser matrix, a classic symmetric eigenvalue test problem");
char *fake = N_("Rotation around origin in R^2");
char *fake = N_("Rotation around origin in R^3 about the x-axis");
char *fake = N_("Rotation around origin in R^3 about the y-axis");
char *fake = N_("Rotation around origin in R^3 about the z-axis");
char *fake = N_("Get a basis matrix for the rowspace of a matrix");
char *fake = N_("Evaluate (v,w) with respect to the sesquilinear form given by the matrix A");
char *fake = N_("Return a function that evaluates two vectors with respect to the sesquilinear form given by A");
char *fake = N_("Smith Normal Form for fields (will end up with 1's on the diagonal)");
char *fake = N_("Smith Normal Form for square integer matrices");
char *fake = N_("Return the Toeplitz matrix constructed given the first column c and (optionally) the first row r.");
char *fake = N_("Calculate the trace of a matrix");
char *fake = N_("Transpose of a matrix");
char *fake = N_("Return the Vandermonde matrix");
char *fake = N_("The angle of two vectors, given an inner product");
char *fake = N_("The direct sum of the vector spaces M and N");
char *fake = N_("Intersection of the subspaces given by M and N");
char *fake = N_("The sum of the vector spaces M and N, that is {w | w=m+n, m in M, n in N}");
char *fake = N_("Get the classical adjoint (adjugate) of a matrix");
char *fake = N_("Compute the Column Reduced Echelon Form");
char *fake = N_("Get nth Catalan number");
char *fake = N_("Double factorial: n(n-2)(n-4)...");
char *fake = N_("Factorial: n(n-1)(n-2)...");
char *fake = N_("Falling factorial: (n)_k = n(n-1)...(n-(k-1))");
char *fake = N_("Calculate nth Fibonacci number");
char *fake = N_("Calculate the Frobenius number for a coin problem");
char *fake = N_("Galois matrix given a linear combining rule (a_1*x_1+...+a_n*x_n=x_(n+1))");
char *fake = N_("Use greedy algorithm to find c, for c . v = n.  (v must be sorted)");
char *fake = N_("Harmonic Number, the nth harmonic number of order r");
char *fake = N_("Hofstadter's function q(n) defined by q(1)=1, q(2)=1, q(n)=q(n-q(n-1))+q(n-q(n-2))");
char *fake = N_("Compute linear recursive sequence using Galois stepping");
char *fake = N_("Calculate multinomial coefficients");
char *fake = N_("Get the Pascal's triangle as a matrix");
char *fake = N_("(Pochhammer) Rising factorial: (n)_k = n(n+1)...(n+(k-1))");
char *fake = N_("Stirling number of the first kind");
char *fake = N_("Stirling number of the second kind");
char *fake = N_("Subfactorial: n! times sum_{k=0}^n (-1)^k/k!");
char *fake = N_("Calculate the nth triangular number");
char *fake = N_("Calculate permutations");
char *fake = N_("Integration of f by Composite Simpson's Rule on the interval [a,b] with the number of steps calculated by the fourth derivative bound and the desired tolerance");
char *fake = N_("Attempt to calculate derivative by trying first symbolically and then numerically");
char *fake = N_("Return a function which is the even periodic extension of f defined on the interval [0,L]");
char *fake = N_("Return a function which is a Fourier series with the coefficients given by the vectors a (sines) and b (cosines).  Note that a@(1) is the constant coefficient!");
char *fake = N_("Try to calculate an infinite product for a single parameter function");
char *fake = N_("Try to calculate an infinite product for a double parameter function with func(arg,n)");
char *fake = N_("Try to calculate an infinite sum for a single parameter function");
char *fake = N_("Try to calculate an infinite sum for a double parameter function with func(arg,n)");
char *fake = N_("Try and see if a real-valued function is continuous at x0 by calculating the limit there");
char *fake = N_("Test for differentiability by approximating the left and right limits and comparing");
char *fake = N_("Integration by left hand rule");
char *fake = N_("Calculate the left limit of a real-valued function at x0");
char *fake = N_("Calculate the limit of a real-valued function at x0.  Tries to calculate both left and right limits.");
char *fake = N_("Integration by midpoint rule");
char *fake = N_("Attempt to calculate numerical derivative");
char *fake = N_("Numerically compute the coefficients for a cosine Fourier series for a function on [0,L] up to the Nth coefficient.");
char *fake = N_("Return a function which is the Fourier cosine series of f on [0,L] with coefficients up to N computed numerically");
char *fake = N_("Numerically compute the coefficients for a Fourier series with half-period L up to the Nth coefficient.");
char *fake = N_("Return a function which is the Fourier series of f with half-period L with coefficients up to N computed numerically");
char *fake = N_("Numerically compute the coefficients for a sine Fourier series for a function on [0,L] up to the Nth coefficient.");
char *fake = N_("Return a function which is the Fourier sine series of f on [0,L] with coefficients up to N computed numerically");
char *fake = N_("Integration by rule set in NumericalIntegralFunction of f from a to b using NumericalIntegralSteps steps");
char *fake = N_("Attempt to calculate numerical left derivative");
char *fake = N_("Attempt to calculate the limit of f(step_fun(i)) as i goes from 1 to N");
char *fake = N_("Attempt to calculate numerical right derivative");
char *fake = N_("Return a function which is the odd periodic extension of f defined on the interval [0,L]");
char *fake = N_("Compute one-sided derivative using five point formula");
char *fake = N_("Compute one-sided derivative using three-point formula");
char *fake = N_("Return a function which is the periodic extension of f defined on the interval [a,b]");
char *fake = N_("Integration by right hand rule");
char *fake = N_("Calculate the right limit of a real-valued function at x0");
char *fake = N_("Integration by trapezoid rule");
char *fake = N_("Compute two-sided derivative using five-point formula");
char *fake = N_("Compute two-sided derivative using three-point formula");
char *fake = N_("argument (angle) of complex number");
char *fake = N_("Dirichlet kernel of order n");
char *fake = N_("Returns 1 if and only if all elements are zero");
char *fake = N_("Fejer kernel of order n");
char *fake = N_("Returns 1 if and only if all elements are equal");
char *fake = N_("Principal branch of the Lambert W function for real values greater than or equal to -1/e");
char *fake = N_("The minus-one branch of the Lambert W function for real values between -1/e and 0");
char *fake = N_("Find the first value where f(x)=0");
char *fake = N_("Moebius mapping of the disk to itself mapping a to 0");
char *fake = N_("Moebius mapping using the cross ratio taking z2,z3,z4 to 1,0, and infinity respectively");
char *fake = N_("Moebius mapping using the cross ratio taking infinity to infinity and z2,z3 to 1 and 0 respectively");
char *fake = N_("Moebius mapping using the cross ratio taking infinity to 1 and z3,z4 to 0 and infinity respectively");
char *fake = N_("Moebius mapping using the cross ratio taking infinity to 0 and z2,z4 to 1 and infinity respectively");
char *fake = N_("Poisson kernel on D(0,1) (not normalized to 1, that is integral of this is 2pi)");
char *fake = N_("Poisson kernel on D(0,R) (not normalized to 1)");
char *fake = N_("The unit step function = 0 for x<0, 1 otherwise.  This is the integral of the Dirac Delta function.");
char *fake = N_("The cis function, that is cos(x)+i*sin(x)");
char *fake = N_("Convert degrees to radians");
char *fake = N_("Convert radians to degrees");
char *fake = N_("Find roots of a cubic polynomial (given as vector of coefficients)");
char *fake = N_("Use classical Euler's method to numerically solve y'=f(x,y) for initial x0,y0 going to x1 with n increments, returns y at x1");
char *fake = N_("Use classical Euler's method to numerically solve y'=f(x,y) for initial x0,y0 going to x1 with n increments, returns an n+1 by 2 matrix of values");
char *fake = N_("Find root of a function using the bisection method to within TOL tolerance in up to N iterations.  f(a) and f(b) must have opposite signs.");
char *fake = N_("Find root of a function using the method of false position to within TOL tolerance in up to N iterations.  f(a) and f(b) must have opposite signs.");
char *fake = N_("Find root of a function using the Muller's method");
char *fake = N_("Find root of a function using the secant method to within TOL tolerance in up to N iterations.  f(a) and f(b) must have opposite signs.");
char *fake = N_("Attempt to find a zero of a function f with derivative df and second derivative ddf using Halley's method, returning after two successive values are within epsilon or after maxn tries (then returns null)");
char *fake = N_("Attempt to find a zero of a function f with derivative df using Newton's method, returning after two successive values are within epsilon or after maxn tries (then returns null)");
char *fake = N_("Find roots of a polynomial (given as vector of coefficients)");
char *fake = N_("Find roots of a quartic polynomial (given as vector of coefficients)");
char *fake = N_("Use classical non-adaptive Runge-Kutta of fourth order method to numerically solve y'=f(x,y) for initial x0,y0 going to x1 with n increments, returns y at x1");
char *fake = N_("Use classical non-adaptive Runge-Kutta of fourth order method to numerically solve y'=f(x,y) for initial x0,y0 going to x1 with n increments, returns an n+1 by 2 matrix of values");
char *fake = N_("Calculate average of an entire matrix");
char *fake = N_("Integral of the GaussFunction from 0 to x (area under the normal curve)");
char *fake = N_("The normalized Gauss distribution function (the normal curve)");
char *fake = N_("Calculate median of an entire matrix");
char *fake = N_("Calculate the population standard deviation of a whole matrix");
char *fake = N_("Calculate average of each row in a matrix");
char *fake = N_("Calculate median of each row in a matrix");
char *fake = N_("Calculate the population standard deviations of rows of a matrix and return a vertical vector");
char *fake = N_("Calculate the standard deviations of rows of a matrix and return a vertical vector");
char *fake = N_("Calculate the standard deviation of a whole matrix");
char *fake = N_("Attempt to find a root of a polynomial using Newton's method, returning after two successive values are within epsilon or after maxn tries (then returns null)");
char *fake = N_("Returns a set where every element of X appears only once");
char *fake = N_("Returns a set theoretic union of X and Y (X and Y are vectors pretending to be sets)");
char *fake = N_("For a Hilbert function that is c for degree d, given the Macaulay bound for the Hilbert function of degree d+1 (The c^<d> operator from Green's proof)");
char *fake = N_("The c_<d> operator from Green's proof of Macaulay's Theorem");
char *fake = N_("Return the dth Macaulay representation of a positive integer c");
char *fake = N_("Attempt to symbolically differentiate a function n times");
char *fake = N_("Attempt to symbolically differentiate a function n times quietly and return null on failure");
char *fake = N_("Attempt to construct the Taylor approximation function around x0 to the nth degree.");
