char *fake = N_("Compose two functions");
char *fake = N_("Compose a function with itself n times, passing x as argument, and returning x if n == 0");
char *fake = N_("Make a string");
char *fake = N_("Tolerance of the Chop function");
char *fake = N_("How many iterations to try to find the limit for continuity and limits");
char *fake = N_("How many successive steps to be within tolerance for calculation of continuity");
char *fake = N_("Tolerance for continuity of functions and for calculating the limit");
char *fake = N_("How many iterations to try to find the limit for derivative");
char *fake = N_("How many successive steps to be within tolerance for calculation of derivative");
char *fake = N_("Tolerance for calculating the derivatives of functions");
char *fake = N_("Tolerance of the ErrorFunction");
char *fake = N_("Tolerance of the GaussDistribution function");
char *fake = N_("The function used for numerical integration in NumericalIntegral");
char *fake = N_("Steps to perform in NumericalIntegral");
char *fake = N_("How many iterations to try for InfiniteSum and InfiniteProduct");
char *fake = N_("How many successive steps to be within tolerance for InfiniteSum and InfiniteProduct");
char *fake = N_("Tolerance for InfiniteSum and InfiniteProduct");
char *fake = N_("Absolute value");
char *fake = N_("Replace very small number with zero");
char *fake = N_("Return the fractional part of a number");
char *fake = N_("Division w/o remainder");
char *fake = N_("Check if argument is a gaussian integer");
char *fake = N_("Return the sign (-1,0,1)");
char *fake = N_("Logarithm of any base (calls DiscreteLog if in modulo mode), if base is not given, e is used");
char *fake = N_("The arccos (reverse cos) function");
char *fake = N_("The arccosh (reverse cosh) function");
char *fake = N_("The arccot (reverse cot) function");
char *fake = N_("The arccoth (reverse coth) function");
char *fake = N_("The reverse cosecant function");
char *fake = N_("The reverse hyperbolic cosecant function");
char *fake = N_("The reverse secant function");
char *fake = N_("The reverse hyperbolic secant function");
char *fake = N_("The arcsin (reverse sin) function");
char *fake = N_("The arcsinh (reverse sinh) function");
char *fake = N_("The arctanh (reverse tanh) function");
char *fake = N_("The cotangent function");
char *fake = N_("The hyperbolic cotangent function");
char *fake = N_("The cosecant function");
char *fake = N_("The hyperbolic cosecant function");
char *fake = N_("The secant function");
char *fake = N_("The hyperbolic secant function");
char *fake = N_("The hyperbolic tangent function");
char *fake = N_("Are a and b relatively prime?");
char *fake = N_("Return the nth Bernoulli number");
char *fake = N_("Find the x that solves the system given by the vector a and modulo the elements of m, using the Chinese Remainder Theorem");
char *fake = N_("Given two factorizations, give the factorization of the product, see Factorize");
char *fake = N_("Convert a vector of values indicating powers of b to a number");
char *fake = N_("Convert a number to a vector of powers for elements in base b");
char *fake = N_("Find discrete log of n base b in F_q where q is a prime using the Silver-Pohlig-Hellman algoritm");
char *fake = N_("Compute phi(n), the Euler phi function, that is the number of integers between 1 and n relatively prime to n");
char *fake = N_("Return all factors of a number");
char *fake = N_("Attempt fermat factorization of n into (t-s)*(t+s), returns t and s as a vector if possible, null otherwise");
char *fake = N_("Find the first primitive element in F_q (q must be a prime)");
char *fake = N_("Find a random primitive element in F_q (q must be a prime)");
char *fake = N_("Compute discrete log base b of n in F_q (q a prime) using the factor base S.  S should be a column of primes possibly with second column precalculated by IndexCalculusPrecalculation.");
char *fake = N_("Run the precalculation step of IndexCalculus for logarithms base b in F_q (q a prime) for the factor base S (where S is a column vector of primes).  The logs will be precalculated and returned in the second column.");
char *fake = N_("Tests if a rational number is a perfect power");
char *fake = N_("Check if g is primitive in F_q, where q is a prime.  If q is not prime results are bogus.");
char *fake = N_("Check if g is primitive in F_q, where q is a prime and f is a vector of prime factors of q-1.  If q is not prime results are bogus.");
char *fake = N_("If n is a pseudoprime base b but not a prime, that is if b^(n-1) == 1 mod n");
char *fake = N_("Test if n is a strong pseudoprime to base b but not a prime");
char *fake = N_("Return the residue of a mod n with the least absolute value (in the interval -n/2 to n/2)");
char *fake = N_("Test if Mp is a Mersenne prime using the Lucas-Lehmer test");
char *fake = N_("Return all maximal prime power factors of a number");
char *fake = N_("Return the Moebius mu function evaluated in n");
char *fake = N_("Returns the padic valuation (number of trailing zeros in base p).");
char *fake = N_("Compute a^b mod m");
char *fake = N_("Return all prime factors of a number");
char *fake = N_("Pseudoprime test, true iff b^(n-1) == 1 (mod n)");
char *fake = N_("Removes all instances of the factor m from the number n");
char *fake = N_("Find discrete log of n base b in F_q where q is a prime using the Silver-Pohlig-Hellman algoritm, given f being the factorization of q-1");
char *fake = N_("Find square root of n mod p (a prime). Null is returned if not a quadratic residue.");
char *fake = N_("Apply a function over all entries of a matrix and return a matrix of the results");
char *fake = N_("Apply a function over all entries of 2 matrices (or 1 value and 1 matrix) and return a matrix of the results");
char *fake = N_("Remove column(s) and row(s) from a matrix");
char *fake = N_("Calculate the kth compund matrix of A");
char *fake = N_("Delete a column of a matrix");
char *fake = N_("Delete a row of a matrix");
char *fake = N_("Get the dot product of two vectors");
char *fake = N_("Is a matrix diagonal");
char *fake = N_("Is a matrix lower triangular");
char *fake = N_("Is a matrix upper triangular");
char *fake = N_("Is argument a horizontal or a vertical vector");
char *fake = N_("Zero out entries above the diagonal");
char *fake = N_("Make diagonal matrix from a vector");
char *fake = N_("Calculate the product of all elements in a matrix");
char *fake = N_("Calculate the sum of all elements in a matrix");
char *fake = N_("Calculate the sum of squares of all elements in a matrix");
char *fake = N_("Get the outer product of two vectors");
char *fake = N_("Reverse elements in a vector");
char *fake = N_("Calculate sum of each row in a matrix");
char *fake = N_("Calculate sum of squares of each row in a matrix");
char *fake = N_("Sort vector elements");
char *fake = N_("Removes any all-zero columns of M");
char *fake = N_("Removes any all-zero rows of M");
char *fake = N_("Return column(s) and row(s) from a matrix");
char *fake = N_("Swap two rows in a matrix");
char *fake = N_("Zero out entries below the diagonal");
char *fake = N_("Get the auxilliary unit matrix of size n");
char *fake = N_("Evaluate (v,w) with respect to the bilinear form given by the matrix A");
char *fake = N_("Return a function that evaluates two vectors with respect to the bilinear form given by A");
char *fake = N_("Get the characteristic polynomial as a vector");
char *fake = N_("Get the characteristic polynomial as a function");
char *fake = N_("Get a basis matrix for the columnspace of a matrix");
char *fake = N_("Companion matrix of a polynomial (as vector)");
char *fake = N_("Conjugate transpose of a matrix (adjoint)");
char *fake = N_("Calculate convolution of two horizontal vectors");
char *fake = N_("Calculate convolution of two horizontal vectors");
char *fake = N_("CrossProduct of two vectors in R^3");
char *fake = N_("Get the determinantal divisors of an integer matrix (not its characteristic)");
char *fake = N_("Direct sum of matrices");
char *fake = N_("Direct sum of a vector of matrices");
char *fake = N_("Get the eigenvalues of a matrix (Currently only for 2x2 and triangular matrices)");
char *fake = N_("Apply the Gram-Schmidt process (to the columns) with respect to innter product given by #2");
char *fake = N_("Apply the Gram-Schmidt process (to the columns) using the dot product");
char *fake = N_("Hankel matrix");
char *fake = N_("Hilbert matrix of order n");
char *fake = N_("Get the image (columnspace) of a linear transform");
char *fake = N_("Get the Inf Norm of a vector");
char *fake = N_("Get the invariant factors of a square integer matrix (not its characteristic)");
char *fake = N_("Inverse Hilbert matrix of order n");
char *fake = N_("Is a matrix hermitian");
char *fake = N_("Test if a vector is in a subspace");
char *fake = N_("Is a matrix (or number) invertible (Integer matrix is invertible iff it's invertible over the integers)");
char *fake = N_("Is a matrix (or number) invertible over a field");
char *fake = N_("Is a matrix normal");
char *fake = N_("Is a matrix skew-hermitian");
char *fake = N_("Is a matrix unitary");
char *fake = N_("Get the jordan block corresponding to lambda and n");
char *fake = N_("Get the kernel (nullspace) of a linear transform");
char *fake = N_("Get the LU decomposition of A and store the result in the L and U which should be references.  If not possible returns false.");
char *fake = N_("Get the i-j minor of a matrix");
char *fake = N_("Return the columns that are not the pivot columns of a matrix");
char *fake = N_("Get the p Norm (or 2 Norm if no p is supplied) of a vector");
char *fake = N_("Get the nullspace of a matrix");
char *fake = N_("Get the nullity of a matrix");
char *fake = N_("Get the orthogonal complement of the columnspace");
char *fake = N_("Return pivot columns of a matrix, that is columns which have a leading 1 in rref form, also returns the row where they occur");
char *fake = N_("Projection of vector v onto subspace W given a bilinear form B");
char *fake = N_("Return the Raleigh Quotient of a matrix and a vector");
char *fake = N_("Get the rank of a matrix");
char *fake = N_("Rosser matrix, a classic symmetric eigenvalue test problem");
char *fake = N_("Rotation around origin in R^2");
char *fake = N_("Rotation around origin in R^3 about the x-axis");
char *fake = N_("Rotation around origin in R^3 about the y-axis");
char *fake = N_("Rotation around origin in R^3 about the z-axis");
char *fake = N_("Get a basis matrix for the rowspace of a matrix");
char *fake = N_("Smith Normal Form for fields (will end up with 1's on the diagonal)");
char *fake = N_("Smith Normal Form for square integer matrices (not its characteristic)");
char *fake = N_("Calculate the trace of a matrix");
char *fake = N_("Transpose of a matrix");
char *fake = N_("Return the Vandermonde matrix");
char *fake = N_("The angle of two vectors, given an inner product");
char *fake = N_("The direct sum of the vector spaces M and N");
char *fake = N_("Intersection of the subspaces given by M and N");
char *fake = N_("The sum of the vector spaces M and N, that is {w | w=m+n, m in M, n in N}");
char *fake = N_("Get the classical adjoint (adjugate) of a matrix");
char *fake = N_("Compute the Column Reduced Echelon Form");
char *fake = N_("Get n'th catalan number");
char *fake = N_("Double factorial: n(n-2)(n-4)...");
char *fake = N_("Factorial: n(n-1)(n-2)...");
char *fake = N_("Falling factorial: (n)_k = n(n-1)...(n-(k-1))");
char *fake = N_("Calculate n'th fibbonachi number");
char *fake = N_("Galois matrix given a linear combining rule (a_1*x_+...+a_n*x_n=x_(n+1))");
char *fake = N_("Harmonic Number, the nth harmonic number of order r");
char *fake = N_("Hofstadter's function q(n) defined by q(1)=1, q(2)=1, q(n)=q(n-q(n-1))+q(n-q(n-2))");
char *fake = N_("Compute linear recursive sequence using galois stepping");
char *fake = N_("Calculate multinomial coefficients");
char *fake = N_("Get the pascal's triangle as a matrix");
char *fake = N_("(Puchhammer) Rising factorial: (n)_k = n(n+1)...(n+(k-1))");
char *fake = N_("Subfactorial: n! times sum_{k=1}^n (-1)^k/k!");
char *fake = N_("Calculate the nth triangular number");
char *fake = N_("Calculate combinations (binomial coefficient)");
char *fake = N_("Calculate permutations");
char *fake = N_("Integration of f by Composite Simpson's Rule on the interval [a,b] with the number of steps calculated by the fourth derivative bound and the desired tolerance");
char *fake = N_("Attempt to calculate derivative by trying first symbolically and then numerically");
char *fake = N_("Try to calculate an infinite product for a single parameter function");
char *fake = N_("Try to calculate an infinite product for a double parameter function with func(arg,n)");
char *fake = N_("Try to calculate an infinite sum for a single parameter function");
char *fake = N_("Try to calculate an infinite sum for a double parameter function with func(arg,n)");
char *fake = N_("Try and see if a real-valued function is continuous at x0 by calculating the limit there");
char *fake = N_("Test for differentiability by approximating the left and right limits and comparing");
char *fake = N_("Calculate the left limit of a real-valued function at x0");
char *fake = N_("Calculate the limit of a real-valued function at x0.  Tries to calculate both left and right limits.");
char *fake = N_("Integration by midpoint rule");
char *fake = N_("Attempt to calculate numerical derivative");
char *fake = N_("Integration by rule set in NumericalIntegralFunction of f from a to b using NumericalIntegralSteps steps");
char *fake = N_("Attempt to calculate numerical left derivative");
char *fake = N_("Attempt to calculate the limit of f(step_fun(i)) as i goes from 1 to N");
char *fake = N_("Attempt to calculate numerical right derivative");
char *fake = N_("Compute one-sided derivative using five point formula");
char *fake = N_("Compute one-sided derivative using three-point formula");
char *fake = N_("Calculate the right limit of a real-valued function at x0");
char *fake = N_("Compute two-sided derivative using five-point formula");
char *fake = N_("Compute two-sided derivative using three-point formula");
char *fake = N_("argument (angle) of complex number");
char *fake = N_("Dirichlet kernel of order n");
char *fake = N_("Returns 1 iff all elements are zero");
char *fake = N_("The error function, 2/sqrt(pi) * int_0^x e^(-t^2) dt");
char *fake = N_("Fejer kernel of order n");
char *fake = N_("Returns 1 iff all elements are equal");
char *fake = N_("Find the first value where f(x)=0");
char *fake = N_("Moebius mapping of the disk to itself mapping a to 0");
char *fake = N_("Moebius mapping using the cross ratio taking z2,z3,z4 to 1,0, and infinity respectively");
char *fake = N_("Moebius mapping using the cross ratio taking infinity to infinity and z2,z3 to 1 and 0 respectively");
char *fake = N_("Moebius mapping using the cross ratio taking infinity to 1 and z3,z4 to 0 and infinity respectively");
char *fake = N_("Moebius mapping using the cross ratio taking infinity to 0 and z2,z4 to 1 and infinity respectively");
char *fake = N_("Poisson kernel on D(0,1) (not normalized to 1, that is integral of this is 2pi)");
char *fake = N_("Poisson kernel on D(0,R) (not normalized to 1)");
char *fake = N_("The unit step function = 0 for x<0, 1 otherwise.  This is the integral of the Dirac Delta function.");
char *fake = N_("The cis function, that is cos(x)+i*sin(x)");
char *fake = N_("Convert degrees to radians");
char *fake = N_("Convert radians to degrees");
char *fake = N_("Use classical Euler's method to numerically solve y'=f(x,y) for initial x0,y0 going to x1 with n increments, returns y at x1");
char *fake = N_("Find root of a function using the bisection method");
char *fake = N_("Find root of a function using the method of false position");
char *fake = N_("Find root of a function using the Muller's method");
char *fake = N_("Find root of a function using the secant method");
char *fake = N_("Use classical non-adaptive Runge-Kutta of fourth order method to numerically solve y'=f(x,y) for initial x0,y0 going to x1 with n increments, returns y at x1");
char *fake = N_("Calculate average of an entire matrix");
char *fake = N_("Integral of the GaussFunction from 0 to x (area under the normal curve)");
char *fake = N_("The normalized Gauss distribution function (the normal curve)");
char *fake = N_("Calculate median of an entire matrix");
char *fake = N_("Calculate the population standard deviation of a whole matrix");
char *fake = N_("Calculate average of each row in a matrix");
char *fake = N_("Calculate median of each row in a matrix");
char *fake = N_("Calculate the population standard deviations of rows of a matrix and return a vertical vector");
char *fake = N_("Calculate the standard deviations of rows of a matrix and return a vertical vector");
char *fake = N_("Calculate the standard deviation of a whole matrix");
char *fake = N_("Run newton's method on a polynomial to attempt to find a root, returns after two successive values are within epsilon or after maxn tries (then returns null)");
char *fake = N_("Returns a set theoretic intersection of X and Y (X and Y are vectors pretending to be sets)");
char *fake = N_("Returns true if the element x is in the set X (where X is a vector pretending to be a set)");
char *fake = N_("Returns a set where every element of X appears only once");
char *fake = N_("Returns a set theoretic difference X-Y (X and Y are vectors pretending to be sets)");
char *fake = N_("Returns a set theoretic union of X and Y (X and Y are vectors pretending to be sets)");
char *fake = N_("Attempt to symbolically differentiate a function n times");
char *fake = N_("Attempt to symbolically differentiate a function n times quietly and return null on failure");
char *fake = N_("Attempt to construct the taylor approximation function around x0 to the nth degree.");
