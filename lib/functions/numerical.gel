# Numerical functions
#FIXME: these need to be cleaned up!
#Indeed, some of these should probably be built-in

#just for somewhat of "source compatibility"
SetHelp("abs","numeric","Absolute value");
function abs(x) = |x|
protect("abs")

SetHelp("sign","numeric","Return the sign (-1,0,1)");
function sign(x) = (
	if(IsMatrix(x)) then
		return ApplyOverMatrix(x,sign)
	else if(not IsValue(x)) then
		(error("sign: argument not a value");bailout);
	if(IsComplex(x)) then (
		x/|x|
	) else if(x>0) then (
		1
	) else if(x<0) then (
		-1
	) else 0
);
protect("sign")

#-----

SetHelp ("FractionalPart", "numeric", "Return the fractional part of a number")
function FractionalPart(x) =
(
	if not IsValue(x) then
		(error("FractionalPart: argument not a value");bailout)
	else
		x - IntegerPart (x)
)
protect ("FractionalPart")
# Chop replaces very small number with zero
# FIXME: parameters
ChopTolerance = 10^(-10);
SetHelp ("Chop", "numeric", "Replace very small number with zero")
function Chop(x) =
(
	if not IsValue(x) then
		(error("Chop: argument not a value");bailout)
	else if |x| < ChopTolerance then
		0
	else
		x
)
protect ("Chop")

#-----

# A complex number is a gaussian integer iff 
# its real and complex parts are integers
SetHelp ("IsGaussianInteger", "numeric", "Check if argument is a gaussian integer")
function IsGaussianInteger(z) = ( IsInteger(Re(z)) and IsInteger(Im(z)) )
protect ("IsGaussianInteger")

#-----
# Mod (built-in)
# FIXME: Mod with offset (m mod n offset d = something in [d,d+n-1])

# Division w/o remainder
SetHelp ("IntegerQuotient", "numeric", "Division w/o remainder")
function IntegerQuotient(m,n) = floor(m/n)
protect ("IntegerQuotient")
# IntergerQuotient w/offset (such that d <= m-r*n < d+n
# IntegerDigits = (convert interger to its list of digits, base b, of length len)
# IntegerExponent = (number of trailing zeros in base b expansion = heighest power
#		of b that divides n)
