<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Teoría de números</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Manual de Genius"><link rel="up" href="ch11.html" title="Capítulo 11. Lista de funciones GEL"><link rel="prev" href="ch11s06.html" title="Trigonometría"><link rel="next" href="ch11s08.html" title="Manipulación de matrices"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Teoría de números</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch11s06.html">Anterior</a> </td><th width="60%" align="center">Capítulo 11. Lista de funciones GEL</th><td width="20%" align="right"> <a accesskey="n" href="ch11s08.html">Siguiente</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="genius-gel-function-list-number-theory"></a>Teoría de números</h2></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a name="gel-function-AreRelativelyPrime"></a>AreRelativelyPrime</span></dt><dd><pre class="synopsis">AreRelativelyPrime (a,b)</pre><p>¿Son los números reales <code class="varname">a</code> and <code class="varname">b</code> primos entre sí? Devuelve <code class="constant">true</code> o <code class="constant">false</code>.</p><p>Consulte la <a class="ulink" href="https://en.wikipedia.org/wiki/Coprime_integers" target="_top">Wikipedia</a> o <a class="ulink" href="http://planetmath.org/RelativelyPrime" target="_top">Planetmath</a> o <a class="ulink" href="http://mathworld.wolfram.com/RelativelyPrime.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-BernoulliNumber"></a>BernoulliNumber</span></dt><dd><pre class="synopsis">BernoulliNumber (n)</pre><p>Devolver el <code class="varname">n</code>-ésimo número de Bernoulli.</p><p>Consulte la <a class="ulink" href="http://en.wikipedia.org/wiki/Bernoulli_number" target="_top">Wikipedia</a> o <a class="ulink" href="http://mathworld.wolfram.com/BernoulliNumber.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-ChineseRemainder"></a>ChineseRemainder</span></dt><dd><pre class="synopsis">ChineseRemainder (a,m)</pre><p>Alias: <code class="function">CRT</code></p><p>Encontrar la <code class="varname">x</code> que resuelve el sistema dado por el vector <code class="varname">a</code> y el módulo de los elementos de <code class="varname">m</code>, utilizando el «teorema chino del resto».</p><p>Consulte la <a class="ulink" href="http://en.wikipedia.org/wiki/Chinese_remainder_theorem" target="_top">Wikipedia</a> o <a class="ulink" href="http://planetmath.org/ChineseRemainderTheorem" target="_top">Planetmath</a> o <a class="ulink" href="http://mathworld.wolfram.com/ChineseRemainderTheorem.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-CombineFactorizations"></a>CombineFactorizations</span></dt><dd><pre class="synopsis">CombineFactorizations (a,b)</pre><p>Dadas dos factorizaciones, dar la factorización del producto.</p><p>Consulte la sección<a class="link" href="ch11s07.html#gel-function-Factorize">factorizar</a>.</p></dd><dt><span class="term"><a name="gel-function-ConvertFromBase"></a>ConvertFromBase</span></dt><dd><pre class="synopsis">ConvertFromBase (v,b)</pre><p>Convertir un vector de valores mostrando potencias de b a un número.</p></dd><dt><span class="term"><a name="gel-function-ConvertToBase"></a>ConvertToBase</span></dt><dd><pre class="synopsis">ConvertToBase (n,b)</pre><p>Convertir un número en un vector de potencias para elementos en base <code class="varname">b</code>.</p></dd><dt><span class="term"><a name="gel-function-DiscreteLog"></a>DiscreteLog</span></dt><dd><pre class="synopsis">DiscreteLog (n,b,q)</pre><p>Encontrar el logaritmo discreto de <code class="varname">n</code> en base <code class="varname">b</code> en F<sub>q</sub>, el campo finito de orden <code class="varname">q</code>, donde <code class="varname">q</code> es primo, utilizando el algoritmo de Silver-Pohlig-Hellman.</p><p>Consulte la <a class="ulink" href="http://en.wikipedia.org/wiki/Discrete_logarithm" target="_top">Wikipedia</a>, <a class="ulink" href="http://planetmath.org/DiscreteLogarithm" target="_top">Planetmath</a>, o <a class="ulink" href="http://mathworld.wolfram.com/DiscreteLogarithm.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-Divides"></a>Divides</span></dt><dd><pre class="synopsis">Divides (m,n)</pre><p>Comprueba la divisibilidad (si <code class="varname">m</code> divide a <code class="varname">n</code>).</p></dd><dt><span class="term"><a name="gel-function-EulerPhi"></a>EulerPhi</span></dt><dd><pre class="synopsis">EulerPhi (n)</pre><p>Calcular la función phi de Euler para <code class="varname">n</code>, que es el número de enteros entre 1 y <code class="varname">n</code> primo relativo con <code class="varname">n</code>.</p><p>Consulte la <a class="ulink" href="http://en.wikipedia.org/wiki/Euler_phi" target="_top">Wikipedia</a>, <a class="ulink" href="http://planetmath.org/EulerPhifunction" target="_top">Planetmath</a>, o <a class="ulink" href="http://mathworld.wolfram.com/TotientFunction.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-ExactDivision"></a>ExactDivision</span></dt><dd><pre class="synopsis">ExactDivision (n,d)</pre><p>Devuelve <strong class="userinput"><code>n/d</code></strong> pero solo si <code class="varname">d</code> es divisible entre <code class="varname">n</code>. Si <code class="varname">d</code> no es divisible entre <code class="varname">n</code> entonces esta función devuelve basura. Esto es mucho mas rápido para números muy grandes que la operación <strong class="userinput"><code>n/d</code></strong>, pero sólo es útil si se sabe que la división es exacta.</p></dd><dt><span class="term"><a name="gel-function-Factorize"></a>Factorize</span></dt><dd><pre class="synopsis">Factorize (n)</pre><p>Devuelve la factorización de un número como una matriz. La primera fila son los números primos en la factorización (incluido el 1) y la segunda fila son las potencias. Por ejemplo: </p><pre class="screen"><code class="prompt">genius&gt;</code> <strong class="userinput"><code>Factorize(11*11*13)</code></strong>
=
[1      11      13
 1      2       1]</pre><p>Consulte la <a class="ulink" href="http://en.wikipedia.org/wiki/Factorization" target="_top">Wikipedia</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-Factors"></a>Factors</span></dt><dd><pre class="synopsis">Factors (n)</pre><p>Devuelve todos los factores de <code class="varname">n</code> en un vector. Esto incluye todos los factores no primos como buenos. Incluye 1 y el mismo número. Así por ejemplo, para imprimir todos los números perfectos (aquellos que son sumas de sus factores) hasta el número 1000 (esto es muy ineficiente) haga  </p><pre class="programlisting">for n=1 to 1000 do (
    if MatrixSum (Factors(n)) == 2*n then
        print(n)
)
</pre></dd><dt><span class="term"><a name="gel-function-FermatFactorization"></a>FermatFactorization</span></dt><dd><pre class="synopsis">FermatFactorization (n,tries)</pre><p>Probar la factorización de Fermat de <code class="varname">n</code> en <strong class="userinput"><code>(t-s)*(t+s)</code></strong>, devuelve <code class="varname">t</code> y <code class="varname">s</code> como un vector si es posible, <code class="constant">null</code> de otra manera <code class="varname">tries</code> especifica el número de intentos antes de abandonar </p><p>Es una buena factorización si su número es el producto de dos factores que están muy cerca.</p><p>Consulte la <a class="ulink" href="http://en.wikipedia.org/wiki/Fermat_factorization" target="_top">Wikipedia</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-FindPrimitiveElementMod"></a>FindPrimitiveElementMod</span></dt><dd><pre class="synopsis">FindPrimitiveElementMod (q)</pre><p>Encontrar el primer elemento primitivo en F<sub>q</sub>, en el grupo de orden finito<code class="varname">q</code>. Por supuesto, <code class="varname">q</code> debe de ser primo.</p></dd><dt><span class="term"><a name="gel-function-FindRandomPrimitiveElementMod"></a>FindRandomPrimitiveElementMod</span></dt><dd><pre class="synopsis">FindRandomPrimitiveElementMod (q)</pre><p>Encontrar un elemento primitivo aleatorio en F<sub>q</sub>, en el grupo de orden finito <code class="varname">q</code> (q debe de ser primo)</p></dd><dt><span class="term"><a name="gel-function-IndexCalculus"></a>IndexCalculus</span></dt><dd><pre class="synopsis">IndexCalculus (n,b,q,S)</pre><p>Calcula la base del logaritmo discreto <code class="varname">b</code> de n en F<sub>q</sub>, el grupo finito de orden <code class="varname">q</code> (<code class="varname">q</code> un primo), utilizando el factor base <code class="varname">S</code>. <code class="varname">S</code> será una columna de números primos y una segunda columna precalculada por <a class="link" href="ch11s07.html#gel-function-IndexCalculusPrecalculation"><code class="function">IndexCalculusPrecalculation</code></a>.</p></dd><dt><span class="term"><a name="gel-function-IndexCalculusPrecalculation"></a>IndexCalculusPrecalculation</span></dt><dd><pre class="synopsis">IndexCalculusPrecalculation (b,q,S)</pre><p>Ejecuta los pasos para los cálculos previos de <a class="link" href="ch11s07.html#gel-function-IndexCalculus"><code class="function">IndexCalculus</code></a> para logaritmos de base <code class="varname">b</code> en F<sub>q</sub>, del grupo finito de orden <code class="varname">q</code> (<code class="varname">q</code> un primo), para el factor base <code class="varname">S</code> (donde <code class="varname">S</code> es una columna de vector de primos). Los registros se calculan previamente y se devuelven en la segunda columna.</p></dd><dt><span class="term"><a name="gel-function-IsEven"></a>IsEven</span></dt><dd><pre class="synopsis">IsEven (n)</pre><p>Comprueba si un entero es par.</p></dd><dt><span class="term"><a name="gel-function-IsMersennePrimeExponent"></a>IsMersennePrimeExponent</span></dt><dd><pre class="synopsis">IsMersennePrimeExponent (p)</pre><p>Comprueba si un entero positivo <code class="varname">p</code> es un exponente primo de Mersenne. Esto es si 2<sup>p</sup>-1 es un primo. Esto lo hace mirando en una tabla de valores conocidos que es relativamente corta. Vea también <a class="link" href="ch11s07.html#gel-function-MersennePrimeExponents">MersennePrimeExponents</a> y <a class="link" href="ch11s07.html#gel-function-LucasLehmer">LucasLehmer</a>.</p><p>Consulte la <a class="ulink" href="http://en.wikipedia.org/wiki/Mersenne_prime" target="_top">Wikipedia</a>, <a class="ulink" href="http://planetmath.org/MersenneNumbers" target="_top">Planetmath</a>, <a class="ulink" href="http://mathworld.wolfram.com/MersennePrime.html" target="_top">Mathworld</a> o <a class="ulink" href="http://www.mersenne.org/" target="_top">GIMPS</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-IsNthPower"></a>IsNthPower</span></dt><dd><pre class="synopsis">IsNthPower (m,n)</pre><p>Comprueba si un número racional <code class="varname">m</code> es una potencia <code class="varname">n</code>-ésima perfecta. Consulte <a class="link" href="ch11s07.html#gel-function-IsPerfectPower">IsPerfectPower</a> y <a class="link" href="ch11s07.html#gel-function-IsPerfectSquare">IsPerfectSquare</a>.</p></dd><dt><span class="term"><a name="gel-function-IsOdd"></a>IsOdd</span></dt><dd><pre class="synopsis">IsOdd (n)</pre><p>Comprueba su un entero es impar.</p></dd><dt><span class="term"><a name="gel-function-IsPerfectPower"></a>IsPerfectPower</span></dt><dd><pre class="synopsis">IsPerfectPower (n)</pre><p>Comprobar si un entero es una potencia perfecta, a<sup>b</sup>.</p></dd><dt><span class="term"><a name="gel-function-IsPerfectSquare"></a>IsPerfectSquare</span></dt><dd><pre class="synopsis">IsPerfectSquare (n)</pre><p>Comprobar si un entero es un cuadrado perfecto de un entero. El número será un entero real. Los enteros negativos, por supuesto, no son perfectos cuadrados de enteros reales.</p></dd><dt><span class="term"><a name="gel-function-IsPrime"></a>IsPrime</span></dt><dd><pre class="synopsis">IsPrime (n)</pre><p>Comprueba si dos números enteros son primos, para números menores que 2.5e10 la respuesta es determinista (si la hipótesis de Riemann es verdadera). Para números más grandes, la probabilidad de un falso positivo depende de <a class="link" href="ch11s03.html#gel-function-IsPrimeMillerRabinReps"><code class="function">IsPrimeMillerRabinReps</code></a>. Significa que la probabilidad de un falso positivo es 1/4 de la potencia <code class="function">IsPrimeMillerRabinReps</code>. De manera predeterminada el valor de 22 produce una probabilidad entorno a 5.7e-14.</p><p>Si se devuelve <code class="constant">false</code>, puede estar seguro de que el número es un compuesto. Si quiere estar totalmente seguro de que tiene un número primo use <a class="link" href="ch11s07.html#gel-function-MillerRabinTestSure"><code class="function">MillerRabinTestSure</code></a> pero esto le puede llevar mucho más tiempo.</p><p>Consulte <a class="ulink" href="http://planetmath.org/PrimeNumber" target="_top">Planetmath</a> o <a class="ulink" href="http://mathworld.wolfram.com/PrimeNumber.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-IsPrimitiveMod"></a>IsPrimitiveMod</span></dt><dd><pre class="synopsis">IsPrimitiveMod (g,q)</pre><p>Comprobar si <code class="varname">g</code> es primario en F<sub>q</sub>, el grupo finito de orden <code class="varname">q</code>, donde <code class="varname">q</code> es un primo. Si <code class="varname">q</code> no es un primo los resultados son falsos.</p></dd><dt><span class="term"><a name="gel-function-IsPrimitiveModWithPrimeFactors"></a>IsPrimitiveModWithPrimeFactors</span></dt><dd><pre class="synopsis">IsPrimitiveModWithPrimeFactors (g,q,f)</pre><p>Comprobar si <code class="varname">g</code> es primario en F<sub>q</sub>, el grupo finito de orden <code class="varname">q</code>, donde <code class="varname">q</code> es un primo y <code class="varname">f</code> es un vector de factores primos de <code class="varname">q</code>-1. Si <code class="varname">q</code> no es primo los resultados son falsos.</p></dd><dt><span class="term"><a name="gel-function-IsPseudoprime"></a>IsPseudoprime</span></dt><dd><pre class="synopsis">IsPseudoprime (n,b)</pre><p>Si <code class="varname">n</code> es pseudo-primo en base <code class="varname">b</code> pero no un primo, esto es si <strong class="userinput"><code>b^(n-1) == 1 mod n</code></strong>. Esto llama a <a class="link" href="ch11s07.html#gel-function-PseudoprimeTest"><code class="function">PseudoprimeTest</code></a></p></dd><dt><span class="term"><a name="gel-function-IsStrongPseudoprime"></a>IsStrongPseudoprime</span></dt><dd><pre class="synopsis">IsStrongPseudoprime (n,b)</pre><p>Compruebe si <code class="varname">n</code> es un pseudo-primo fuerte en base <code class="varname">b</code> pero no un primo.</p></dd><dt><span class="term"><a name="gel-function-Jacobi"></a>Jacobi</span></dt><dd><pre class="synopsis">Jacobi (a,b)</pre><p>Alias: <code class="function">JacobiSymbol</code></p><p>Calcular el símbolo de Jacobi (a/b) (b debe ser impar).</p></dd><dt><span class="term"><a name="gel-function-JacobiKronecker"></a>JacobiKronecker</span></dt><dd><pre class="synopsis">JacobiKronecker (a,b)</pre><p>Alias: <code class="function">JacobiKroneckerSymbol</code></p><p>Calcular el símbolo de Jacobi (a/b) con extensión de Kronecker (a/2)=(2/a) cuando sea impar, o (a/2)=0 cuando sea par.</p></dd><dt><span class="term"><a name="gel-function-LeastAbsoluteResidue"></a>LeastAbsoluteResidue</span></dt><dd><pre class="synopsis">LeastAbsoluteResidue (a,n)</pre><p>Devuelve el resto de <code class="varname">a</code> mod <code class="varname">n</code> con el último valor absoluto (en el intervalo -n/2 to n/2).</p></dd><dt><span class="term"><a name="gel-function-Legendre"></a>Legendre</span></dt><dd><pre class="synopsis">Legendre (a,p)</pre><p>Alias: <code class="function">LegendreSymbol</code></p><p>Calcular el símbolo de Legendre (a/p).</p><p>Consulte <a class="ulink" href="http://planetmath.org/LegendreSymbol" target="_top">Planetmath</a> o <a class="ulink" href="http://mathworld.wolfram.com/LegendreSymbol.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-LucasLehmer"></a>LucasLehmer</span></dt><dd><pre class="synopsis">LucasLehmer (p)</pre><p>Compruebe si 2<sup>p</sup>-1 es un primo de Mersenne utilizando la prueba de Lucas-Lehmer. Consulte también <a class="link" href="ch11s07.html#gel-function-MersennePrimeExponents">MersennePrimeExponents</a> y <a class="link" href="ch11s07.html#gel-function-IsMersennePrimeExponent">IsMersennePrimeExponent</a>.</p><p>Consulte la <a class="ulink" href="http://en.wikipedia.org/wiki/Lucas%E2%80%93Lehmer_primality_test" target="_top">Wikipedia</a>, <a class="ulink" href="http://planetmath.org/LucasLhemer" target="_top">Planetmath</a>, o <a class="ulink" href="http://mathworld.wolfram.com/Lucas-LehmerTest.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-LucasNumber"></a>LucasNumber</span></dt><dd><pre class="synopsis">LucasNumber (n)</pre><p>Devuelve el <code class="varname">n</code>-ésimo número de Lucas.</p><p>Consulte la <a class="ulink" href="http://en.wikipedia.org/wiki/Lucas_number" target="_top">Wikipedia</a>, <a class="ulink" href="http://planetmath.org/LucasNumbers" target="_top">Planetmath</a>, o <a class="ulink" href="http://mathworld.wolfram.com/LucasNumber.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-MaximalPrimePowerFactors"></a>MaximalPrimePowerFactors</span></dt><dd><pre class="synopsis">MaximalPrimePowerFactors (n)</pre><p>Devuelve todos los factores primos de un número.</p></dd><dt><span class="term"><a name="gel-function-MersennePrimeExponents"></a>MersennePrimeExponents</span></dt><dd><pre class="synopsis">MersennePrimeExponents</pre><p>Un vector de Mersenne de exponentes primos conocidos, esto es una lista de enteros positivos <code class="varname">p</code> tal que 2<sup>p</sup>-1 es un primo. Consulte también <a class="link" href="ch11s07.html#gel-function-IsMersennePrimeExponent">IsMersennePrimeExponent</a> y <a class="link" href="ch11s07.html#gel-function-LucasLehmer">LucasLehmer</a>.</p><p>Consulte la <a class="ulink" href="http://en.wikipedia.org/wiki/Mersenne_prime" target="_top">Wikipedia</a>, <a class="ulink" href="http://planetmath.org/MersenneNumbers" target="_top">Planetmath</a>, <a class="ulink" href="http://mathworld.wolfram.com/MersennePrime.html" target="_top">Mathworld</a> o <a class="ulink" href="http://www.mersenne.org/" target="_top">GIMPS</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-MillerRabinTest"></a>MillerRabinTest</span></dt><dd><pre class="synopsis">MillerRabinTest (n,reps)</pre><p>Utiliza la prueba de números primarios Miller-Rabin de <code class="varname">n</code>, <code class="varname">reps</code> número de veces. La probabilidad de falso positivo es <strong class="userinput"><code>(1/4)^reps</code></strong>. Probablemente es mejor usar <a class="link" href="ch11s07.html#gel-function-IsPrime"><code class="function">IsPrime</code></a> ya que es más rápido y mejor sobre enteros más pequeños.</p><p>Consulte la <a class="ulink" href="http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test" target="_top">Wikipedia</a> o <a class="ulink" href="http://planetmath.org/MillerRabinPrimeTest" target="_top">Planetmath</a> o <a class="ulink" href="http://mathworld.wolfram.com/Rabin-MillerStrongPseudoprimeTest.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-MillerRabinTestSure"></a>MillerRabinTestSure</span></dt><dd><pre class="synopsis">MillerRabinTestSure (n)</pre><p>Utiliza la prueba Miller-Rabin de números primos de <code class="varname">n</code> con las bases suficientes que asuman la hipótesis generalizada de Reimann, el resultado es determinista.</p><p>Consulte la <a class="ulink" href="http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test" target="_top">Wikipedia</a>, <a class="ulink" href="http://planetmath.org/MillerRabinPrimeTest" target="_top">Planetmath</a>, o <a class="ulink" href="http://mathworld.wolfram.com/Rabin-MillerStrongPseudoprimeTest.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-ModInvert"></a>ModInvert</span></dt><dd><pre class="synopsis">ModInvert (n,m)</pre><p>Devuelve el inverso de n módulo m.</p><p>Consulte <a class="ulink" href="http://mathworld.wolfram.com/ModularInverse.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-MoebiusMu"></a>MoebiusMu</span></dt><dd><pre class="synopsis">MoebiusMu (n)</pre><p>Devuelve la función de Moebius «mu» de <code class="varname">n</code>. Esto es, devuelve 0 si <code class="varname">n</code> no es un producto entre primos distintos y <strong class="userinput"><code>(-1)^k</code></strong> si es un producto de <code class="varname">k</code> primos distintos.</p><p>Consulte <a class="ulink" href="http://planetmath.org/MoebiusFunction" target="_top">Planetmath</a> o <a class="ulink" href="http://mathworld.wolfram.com/MoebiusFunction.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-NextPrime"></a>NextPrime</span></dt><dd><pre class="synopsis">NextPrime (n)</pre><p>Devuelve el primo menor más grande que <code class="varname">n</code>. Los primos negativos se consideran primos y así para obtener el primo anterior, puede usar <strong class="userinput"><code>-NextPrime(-n)</code></strong>.</p><p>Esta función utiliza las GMP <code class="function">mpz_nextprime</code> la cual vuelve a utilizar la prueba probabilística de Miller-Rabin (consulte también <a class="link" href="ch11s07.html#gel-function-MillerRabinTest"><code class="function">MillerRabinTest</code></a>). La probabilidad de un falso positivo no se da, pero es lo suficientemente baja para prácticamente todos los propósitos.</p><p>Consulte <a class="ulink" href="http://planetmath.org/PrimeNumber" target="_top">Planetmath</a> o <a class="ulink" href="http://mathworld.wolfram.com/PrimeNumber.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-PadicValuation"></a>PadicValuation</span></dt><dd><pre class="synopsis">PadicValuation (n,p)</pre><p>Devuelve la evaluación del número «p-adic» (número de ceros que va dejando en base <code class="varname">p</code>).</p><p>Consulte la <a class="ulink" href="https://en.wikipedia.org/wiki/P-adic_order" target="_top">Wikipedia</a> o <a class="ulink" href="http://planetmath.org/PAdicValuation" target="_top">Planetmath</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-PowerMod"></a>PowerMod</span></dt><dd><pre class="synopsis">PowerMod (a,b,m)</pre><p>Calcula <strong class="userinput"><code>a^b mod m</code></strong>. La potencia <code class="varname">b</code> de <code class="varname">a</code> módulo <code class="varname">m</code>. No es necesario utilizar esta función ya que se utiliza automáticamente en modo módulo. Por lo tanto <strong class="userinput"><code>a^b mod m</code></strong> es igual de rápido.</p></dd><dt><span class="term"><a name="gel-function-Prime"></a>Prime</span></dt><dd><pre class="synopsis">Prime (n)</pre><p>Alias: <code class="function">prime</code></p><p>Devuelve el <code class="varname">n</code>-ésimo primo (hasta un límite).</p><p>Consulte <a class="ulink" href="http://planetmath.org/PrimeNumber" target="_top">Planetmath</a> o <a class="ulink" href="http://mathworld.wolfram.com/PrimeNumber.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-PrimeFactors"></a>PrimeFactors</span></dt><dd><pre class="synopsis">PrimeFactors (n)</pre><p>Devuelve todos los factores primos de un número como un vector.</p><p>Consulte la <a class="ulink" href="https://en.wikipedia.org/wiki/Prime_factor" target="_top">Wikipedia</a> o <a class="ulink" href="http://mathworld.wolfram.com/PrimeFactor.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-PseudoprimeTest"></a>PseudoprimeTest</span></dt><dd><pre class="synopsis">PseudoprimeTest (n,b)</pre><p>Prueba de pseudo-primo, devuelve <code class="constant">true</code> sólo si <strong class="userinput"><code>b^(n-1) == 1  mod n</code></strong></p><p>Consulte <a class="ulink" href="http://planetmath.org/Pseudoprime" target="_top">Planetmath</a> o <a class="ulink" href="http://mathworld.wolfram.com/Pseudoprime.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-RemoveFactor"></a>RemoveFactor</span></dt><dd><pre class="synopsis">RemoveFactor (n,m)</pre><p>Elimina todas las instancias del factor <code class="varname">m</code> desde el número <code class="varname">n</code>. Esto es, lo divide por la potencia mas grande de <code class="varname">m</code>, que divide <code class="varname">n</code>.</p><p>Consulte <a class="ulink" href="http://planetmath.org/Divisibility" target="_top">Planetmath</a> o <a class="ulink" href="http://mathworld.wolfram.com/Factor.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-SilverPohligHellmanWithFactorization"></a>SilverPohligHellmanWithFactorization</span></dt><dd><pre class="synopsis">SilverPohligHellmanWithFactorization (n,b,q,f)</pre><p>Buscar el logaritmo sencillo de <code class="varname">n</code> base <code class="varname">b</code> en F<sub>q</sub>, de grupo de orden finito <code class="varname">q</code>, donde <code class="varname">q</code> es un primo que utiliza el algoritmo de Silver-Pohlig-Hellman, dado <code class="varname">f</code> es la factorización de <code class="varname">q</code>-1.</p></dd><dt><span class="term"><a name="gel-function-SqrtModPrime"></a>SqrtModPrime</span></dt><dd><pre class="synopsis">SqrtModPrime (n,p)</pre><p>Buscar la raíz cuadrada de <code class="varname">n</code> módulo <code class="varname">p</code> (donde <code class="varname">p</code> es un primo). Se devuelve «null» si el resto no es cuadrático.</p><p>Consulte <a class="ulink" href="http://planetmath.org/QuadraticResidue" target="_top">Planetmath</a> o <a class="ulink" href="http://mathworld.wolfram.com/QuadraticResidue.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-StrongPseudoprimeTest"></a>StrongPseudoprimeTest</span></dt><dd><pre class="synopsis">StrongPseudoprimeTest (n,b)</pre><p>Ejecutar la prueba del pseudo-primo fuerte en base <code class="varname">b</code> de <code class="varname">n</code>.</p><p>Consulte la <a class="ulink" href="https://en.wikipedia.org/wiki/Strong_pseudoprime" target="_top">Wikipedia</a>, <a class="ulink" href="http://planetmath.org/StrongPseudoprime" target="_top">Planetmath</a>, o <a class="ulink" href="http://mathworld.wolfram.com/StrongPseudoprime.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-gcd"></a>gcd</span></dt><dd><pre class="synopsis">gcd (a,args...)</pre><p>Alias: <code class="function">GCD</code></p><p>Máximo común divisor de enteros. Puede introducir tantos enteros en la lista de argumentos, o puede introducir un vector o una matriz de enteros. Si introduce más de una matriz del mismo tamaño, entonces el máximo común divisor se realiza elemento a elemento.</p><p>Consulte la <a class="ulink" href="https://en.wikipedia.org/wiki/Greatest_common_divisor" target="_top">Wikipedia</a>, <a class="ulink" href="http://planetmath.org/GreatestCommonDivisor" target="_top">Planetmath</a>, o <a class="ulink" href="http://mathworld.wolfram.com/GreatestCommonDivisor.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span class="term"><a name="gel-function-lcm"></a>lcm</span></dt><dd><pre class="synopsis">lcm (a,args...)</pre><p>Alias: <code class="function">LCM</code></p><p>Mínimo común múltiplo de enteros. Puede introducir tantos enteros en la lista de argumentos, o introducir un vector o matriz de enteros. Si introduce mas de una matriz del mismo tamaño, entonces el mínimo común múltiplo se realiza elemento a elemento.</p><p>Consulte la <a class="ulink" href="https://en.wikipedia.org/wiki/Least_common_multiple" target="_top">Wikipedia</a>, <a class="ulink" href="http://planetmath.org/LeastCommonMultiple" target="_top">Planetmath</a>, o <a class="ulink" href="http://mathworld.wolfram.com/LeastCommonMultiple.html" target="_top">Mathworld</a> para obtener más información.</p></dd></dl></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch11s06.html">Anterior</a> </td><td width="20%" align="center"><a accesskey="u" href="ch11.html">Subir</a></td><td width="40%" align="right"> <a accesskey="n" href="ch11s08.html">Siguiente</a></td></tr><tr><td width="40%" align="left" valign="top">Trigonometría </td><td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td><td width="40%" align="right" valign="top"> Manipulación de matrices</td></tr></table></div></body></html>
