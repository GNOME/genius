<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Lista de operadores GEL</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="Manual de Genius"><link rel="up" href="ch05.html" title="Chapter 5. Conceptos de GEL"><link rel="prev" href="ch05s06.html" title="Evaluación modular"><link rel="next" href="ch06.html" title="Chapter 6. Programar con GEL"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Lista de operadores GEL</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s06.html">Prev</a> </td><th width="60%" align="center">Chapter 5. Conceptos de GEL</th><td width="20%" align="right"> <a accesskey="n" href="ch06.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="genius-gel-operator-list"></a>Lista de operadores GEL</h2></div></div></div><p>Todo en GEL es en realidad una expresión. Las expresiones se encadenan unas tras otras mediante diferentes operadores. Como hemos visto, incluso el separador es un operador binario en GEL. A continuación se muestra una lista de los operadores en GEL.</p><div class="variablelist"><dl class="variablelist"><dt><span lang="en" class="term"><strong class="userinput"><code>a;b</code></strong></span></dt><dd><p>El separador evalúa <code class="varname">a</code> y <code class="varname">b</code>, pero sólo devuelve el valor de <code class="varname">b</code>.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a=b</code></strong></span></dt><dd><p>El operador asignación. Asigna <code class="varname">b</code> a <code class="varname">a</code> (<code class="varname">a</code> debe ser un <a class="link" href="ch06s09.html" title="Lvalues">lvalue</a> válido) (tenga en cuenta que este operador puede equivaler a <code class="literal">==</code> si se usa cuando se espera una expresión booleana)</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a:=b</code></strong></span></dt><dd><p>El operador asignación. Asigna <code class="varname">b</code> a <code class="varname">a</code> (<code class="varname">a</code> debe ser un <a class="link" href="ch06s09.html" title="Lvalues">lvalue</a> válido). Se diferencia de <code class="literal">=</code> en que nunca equivale a <code class="literal">==</code>.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>|a|</code></strong></span></dt><dd><p>Valor absoluto. En el caso de que la expresión sea un número complejo el resultado será su módulo (distancia desde el origen). Por ejemplo: <strong class="userinput"><code>|3 * e^(1i*pi)|</code></strong> devuelve 3.</p><p>Consulte <a class="ulink" href="http://mathworld.wolfram.com/AbsoluteValue.html" target="_top">Mathworld</a> para obtener más información.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a^b</code></strong></span></dt><dd><p>Exponenciación, eleva <code class="varname">a</code> a la <code class="varname">b</code>-ésima potencia.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a.^b</code></strong></span></dt><dd><p>Potencia elemento a elemento. Eleva cada elemento de una matriz <code class="varname">a</code> a la <code class="varname">b</code>-ésima potencia. O si <code class="varname">b</code> es una matriz del mismo tamaño que <code class="varname">a</code>, entonces realiza la operación elemento a elemento. Si <code class="varname">a</code> es un número y <code class="varname">b</code> es una matriz entonces crea una matriz del mismo tamaño que <code class="varname">b</code> formada por <code class="varname">a</code> elevado a todas las diferentes potencias de <code class="varname">b</code>.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a+b</code></strong></span></dt><dd><p>Adición. Suma dos números, matrices, funciones o cadenas. Si suma una cadena a cualquier valor el resultado es una cadena. Si uno de ellos es una matriz cuadrada y el otro un número, el número se multiplica por la identidad de la matriz.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a-b</code></strong></span></dt><dd><p>Sustracción. Resta dos números, matrices o funciones.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a*b</code></strong></span></dt><dd><p>Multiplicación. Es la multiplicación normal de matrices.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a.*b</code></strong></span></dt><dd><p>Multiplicación elemento a elemento si <code class="varname">a</code> y <code class="varname">b</code> son matrices.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a/b</code></strong></span></dt><dd><p>División. Cuando <code class="varname">a</code> y <code class="varname">b</code> son sólo números es la división normal. Cuando son matrices, esto es el equivalente a <strong class="userinput"><code>a*b^-1</code></strong>.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a./b</code></strong></span></dt><dd><p>División elemento por elemento. Igual que <strong class="userinput"><code>a/b</code></strong> para números, pero opera elemento por elemento en matrices.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a\b</code></strong></span></dt><dd><p>División hacia atrás. Es lo mismo que <strong class="userinput"><code>b/a</code></strong>.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a.\b</code></strong></span></dt><dd><p>División hacia atrás elemento por elemento.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a%b</code></strong></span></dt><dd><p>El operador mod. No activa el <a class="link" href="ch05s06.html" title="Evaluación modular">modo modular</a> sino que simplemente devuelve el resto de la división de enteros <strong class="userinput"><code>a/b</code></strong>.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a.%b</code></strong></span></dt><dd><p>Operador mod elemento por elemento. Devuelve el resto despues de la división de enteros de elemento por elemento <strong class="userinput"><code>a./b</code></strong> .</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a mod b</code></strong></span></dt><dd><p>Operación de evaluación modular. La expresión <code class="varname">a</code> se evalúa módulo <code class="varname">b</code>. Consulte la <a class="xref" href="ch05s06.html" title="Evaluación modular">the section called “Evaluación modular”</a>. Algunas de las funciones y operadores se comportan de un modo distinto cuando trabajan en módulo entero.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a!</code></strong></span></dt><dd><p>Operador factorial. Esto es <strong class="userinput"><code>1*...*(n-2)*(n-1)*n</code></strong>.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a!!</code></strong></span></dt><dd><p>Operador doble factorial. Esto es <strong class="userinput"><code>1*...*(n-4)*(n-2)*n</code></strong>.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a==b</code></strong></span></dt><dd><p>Operador de igualdad, devuelve <code class="constant">true</code> o <code class="constant">false</code> dependiendo de si <code class="varname">a</code> y <code class="varname">b</code> son iguales o no.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a!=b</code></strong></span></dt><dd><p>Operador de desigualdad, devuelve <code class="constant">true</code> si <code class="varname">a</code> no es igual a <code class="varname">b</code>; si lo es, devuelve <code class="constant">false</code>.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a&lt;&gt;b</code></strong></span></dt><dd><p>Operador distinto alternativo devuelve <code class="constant">true</code> si <code class="varname">a</code> no es igual a <code class="varname">b</code> en caso contrario devuelve <code class="constant">false</code>.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a&lt;=b</code></strong></span></dt><dd><p>Operador menor o igual, devuelve <code class="constant">true</code> si <code class="varname">a</code> es menor o igual que <code class="varname">b</code>, si no, devuelve <code class="constant">false</code>. Esto se puede concatenar como <strong class="userinput"><code>a &lt;= b &lt;= c</code></strong> (también se puede combinar con el operador menor que).</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a&gt;=b</code></strong></span></dt><dd><p>El operador mayor o igual que, devuelve <code class="constant">true</code> si <code class="varname">a</code> es mayor o igual que <code class="varname">b</code>, si no, devuelve <code class="constant">false</code>. Esto se puede concatenar como <strong class="userinput"><code>a &gt;= b &gt;= c</code></strong> (también se puede combinar con el operador mayor que).</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a&lt;b</code></strong></span></dt><dd><p>Operador menor que, devuelve <code class="constant">true</code> si <code class="varname">a</code> es menor o igual que <code class="varname">b</code>, si no, devuelve <code class="constant">false</code>. Esto se puede concatenar como <strong class="userinput"><code>a &lt; b &lt; c</code></strong> (también se puede combinar con el operador menor o igual que).</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a&gt;b</code></strong></span></dt><dd><p>Operador mayor que, devuelve <code class="constant">true</code> si <code class="varname">a</code> es mayor o igual que <code class="varname">b</code>, si no, devuelve <code class="constant">false</code>. Esto se puede concatenar como <strong class="userinput"><code>a &gt; b &gt; c</code></strong> (también se puede combinar con el operador mayor o igual que).</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a&lt;=&gt;b</code></strong></span></dt><dd><p>Operador de comparación. Si <code class="varname">a</code> es igual a <code class="varname">b</code> devuelve 0, si <code class="varname">a</code> es menor que <code class="varname">b</code> devuelve -1 y si <code class="varname">a</code> es mayor que <code class="varname">b</code> devuelve 1.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a and b</code></strong></span></dt><dd><p>AND lógico. Devuelve cierto si <code class="varname">a</code> y <code class="varname">b</code> son ciertos; si no, devuelve falso. Si se dan números, los números distintos de cero se consideran como «verdadero».</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a or b</code></strong></span></dt><dd><p>OR lógico. Devuelve verdadero si <code class="varname">a</code> o <code class="varname">b</code> son verdaderos; si no, devuelve falso. Si se dan números, los números distintos de cero se consideran como verdadero.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a xor b</code></strong></span></dt><dd><p>X-OR lógico. Devuelve cierto si <code class="varname">a</code> o <code class="varname">b</code> son ciertos; si no, devuelve falso. Si se dan números, los números distintos de cero se consideran como «verdadero».</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>not a</code></strong></span></dt><dd><p>NOT lógico. Devuelve la negación lógica de <code class="varname">a</code></p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>-a</code></strong></span></dt><dd><p>Operador de negación. Devuelve el negativo de un número o una matriz (en una matriz, funciona de acuerdo al elemento).</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>&amp;a</code></strong></span></dt><dd><p>Referencia de variables (pasar una referencia a una variable). Consulte <a class="xref" href="ch06s08.html" title="Referencias">the section called “Referencias”</a>.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>*a</code></strong></span></dt><dd><p>Desreferenciar una variable (para acceder a una variable referenciada). Consulte la <a class="xref" href="ch06s08.html" title="Referencias">the section called “Referencias”</a>.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a'</code></strong></span></dt><dd><p>Transpuesta conjugada de una matriz. Significa que las filas y columnas se intercambian y se toman la conjugada compleja de todas las entradas. Esto es, si el elemento i,j de <code class="varname">a</code> es x+iy, entonces el elemento j,i de <strong class="userinput"><code>a'</code></strong> es x-iy.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a.'</code></strong></span></dt><dd><p>Transpuesta de matriz, no conjuga las entradas. Esto significa, el elemento i,j de <code class="varname">a</code> se convierte en el elemento j,i de <strong class="userinput"><code>a.'</code></strong>.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a@(b,c)</code></strong></span></dt><dd><p>Devuelve el elemento de una matriz en la fila <code class="varname">b</code> y columna <code class="varname">c</code>. Si <code class="varname">b</code>, <code class="varname">c</code> son vectores, devuelve las correspondientes filas, columnas o submatrices.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a@(b,)</code></strong></span></dt><dd><p>Devuelve la fila de la matriz (o múltiples filas si <code class="varname">b</code> es un vector).</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a@(b,:)</code></strong></span></dt><dd><p>Igual que el anterior</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a@(,c)</code></strong></span></dt><dd><p>Devuelve la columna de la matriz (o columnas si <code class="varname">c</code> es un vector).</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a@(:,c)</code></strong></span></dt><dd><p>Igual que el anterior</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a@(b)</code></strong></span></dt><dd><p>Obtiene un elemento de una matriz tratándola como vector. Recorre la matriz por filas.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a:b</code></strong></span></dt><dd><p lang="en">
             Build a vector from <code class="varname">a</code> to <code class="varname">b</code> (or specify a row, column region for the <code class="literal">@</code> operator).  For example to get rows 2 to 4 of matrix <code class="varname">A</code> we could do
	     </p><pre lang="en" class="programlisting">A@(2:4,)
	     </pre><p lang="en">
	     as <strong class="userinput"><code>2:4</code></strong> will return a vector
	     <strong class="userinput"><code>[2,3,4]</code></strong>.
           </p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a:b:c</code></strong></span></dt><dd><p lang="en">
	     Build a vector from <code class="varname">a</code> to <code class="varname">c</code>
	     with <code class="varname">b</code> as a step.  That is for example
	     </p><pre lang="en" class="programlisting">genius&gt; 1:2:9
=
`[1, 3, 5, 7, 9]
</pre><p lang="en">
           </p><p>Cuando los números implicados son números en coma flotante, por ejemplo <strong class="userinput"><code>1.0:0.4:3.0</code></strong>, la salida es lo que se espera a pesar de la adición de 0,4 a 1,0 cinco veces es en realidad sólo un poco más de 3,0 debido a la forma en que los números de coma flotante se almacenan en la base 2 (no hay 0.4, el número real almacenado es sólo ligeramente más grande). La forma en que se maneja es el mismo que en los bucles «for», «sum», y «prod». Si el final está dentro de <strong class="userinput"><code>2^-20</code></strong> veces el tamaño de paso del punto final, se utiliza el punto final y suponemos que no eran errores de redondeo. Esto no es perfecto, pero maneja la mayoría de los casos. Esta comprobación se realiza sólo desde la versión 1.0.18 en adelante, así que la ejecución de su código puede ser diferente en las versiones anteriores. Si quiere evitar este problema, utilice los números racionales reales, posiblemente usando el <code class="function">float</code> si quiere obtener los números de punto flotante en el final. Por ejemplo <strong class="userinput"><code>1:2/5:3</code></strong> hace lo correcto y <strong class="userinput"><code>float(1:2/5:3)</code></strong> incluso le da los números de punto flotante y es ligeramente más precisa que <strong class="userinput"><code>1,0:0,4:3,0</code></strong>.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>(a)i</code></strong></span></dt><dd><p lang="en">
	     Make <code class="varname">a</code> into an imaginary number (multiply <code class="varname">a</code> by the
	     imaginary).  Normally the imaginary number <code class="varname">i</code> is
	     written as <strong class="userinput"><code>1i</code></strong>.  So the above is equal to
	     </p><pre lang="en" class="programlisting">(a)*1i
	     </pre><p lang="en">
           </p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>`a</code></strong></span></dt><dd><p>Escapa un identificador de modo que no sea evaluado. O escapa una matriz de modo que no sea expandida.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>a swapwith b</code></strong></span></dt><dd><p>Intercambia el valor de <code class="varname">a</code> con el valor de <code class="varname">b</code>. Actualmente no funciona con rangos de elementos matriciales. Devuelve <code class="constant">null</code>. Está disponible desde la versión 1.0.13.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>increment a</code></strong></span></dt><dd><p>Incrementa la variable <code class="varname">a</code> en 1. Si <code class="varname">a</code> es una matriz entonces incrementará cada uno de los elementos. Es equivalente a <strong class="userinput"><code>a=a+1</code></strong> pero más rápido. Devuelve <code class="constant">null</code>. Está disponible desde la versión 1.0.13.</p></dd><dt><span lang="en" class="term"><strong class="userinput"><code>increment a by b</code></strong></span></dt><dd><p>Incrementa la variable <code class="varname">a</code> en <code class="varname">b</code>. Si <code class="varname">a</code> es una matriz, entonces incrementa cada elemento. Es equivalente a <strong class="userinput"><code>a=a+b</code></strong>, pero más rápido. Devuelve null <code class="constant">null</code>. Está disponible desde la versión 1.0.13.</p></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>El operador @() hace el operador «:» más útil. Con éste puede especificar regiones dentro de una matriz. De modo que a@(2:4,6) representa las filas 2, 3 y 4 de la columna 6. O @(,1:2) devuelve las dos primeras columnas de una matriz. Puede asignar al operador @() siempre que el valor sea una matriz cuyo tamaño coincida con el tamaño de la región asignada o cualquier otro tipo de valor.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Los operadores de comparación (excepto el operador &lt;=&gt; que se comporta de un modo normal), no son estrictamente operadores binarios, de hecho pueden agruparse de una forma matemática estándar, por ejemplo: (1&lt;x&lt;=y&lt;5) es una expresión booleana válida y significa lo que debería, es decir, (1&lt;x and x≤y and y&lt;5)</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>El operador unario «menos» opera de un modo distinto dependiendo del lugar donde aparece. Si lo hace antes de un número su prioridad es muy alta. Si aparece delante de una expresión tendrá menos prioridad que los operadores potencia y factorial. De este modo, por ejemplo, <strong class="userinput"><code>-1^k</code></strong> es en realidad <strong class="userinput"><code>(-1)^k</code></strong>, sin embargo <strong class="userinput"><code>-foo(1)^k</code></strong> es realmente <strong class="userinput"><code>-(foo(1)^k)</code></strong>. Por lo tanto, tenga cuidado con el uso de este operador y si tiene alguna duda, use paréntesis.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s06.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch05.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch06.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Evaluación modular </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 6. Programar con GEL</td></tr></table></div></body></html>
