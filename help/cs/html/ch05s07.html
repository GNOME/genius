<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Seznam operátorů GEL</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Příručka k aplikaci Genius"><link rel="up" href="ch05.html" title="Kapitola 5. Základy jazyka GEL"><link rel="prev" href="ch05s06.html" title="Modulární aritmetika"><link rel="next" href="ch06.html" title="Kapitola 6. Programování s jazykem GEL"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Seznam operátorů GEL</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s06.html">Předcházející</a> </td><th width="60%" align="center">Kapitola 5. Základy jazyka GEL</th><td width="20%" align="right"> <a accesskey="n" href="ch06.html">Další</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="genius-gel-operator-list"></a>Seznam operátorů GEL</h2></div></div></div><p>Vše v jazyce GEL jsou ve skutečnosti jen výrazy. Výrazy jsou dohromady řetězeny pomocí různých operátorů. Jak jste již viděli, i oddělovač je ve skutečnosti jen binární operátor jazyka. Zde je seznam operátorů jazyka GEL.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><strong class="userinput"><code>a;b</code></strong></span></dt><dd><p>Oddělovač, který vyhodnocuje jak <code class="varname">a</code>, tak <code class="varname">b</code>, ale vrací výsledek pouze z <code class="varname">b</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>a=b</code></strong></span></dt><dd><p>Operátor přiřazení. </p></dd><dt><span class="term"><strong class="userinput"><code>a:=b</code></strong></span></dt><dd><p>Operátor přiřazení. Přiřadí <code class="varname">b</code> do <code class="varname">a</code> (<code class="varname">a</code> musí být platná <a class="link" href="ch06s09.html" title="L-hodnoty">l-hodnota</a>). Liší se od <code class="literal">=</code>, protože se nikdy nepřevádí na <code class="literal">==</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>|a|</code></strong></span></dt><dd><p>Absolutní hodnota. V případě, že výraz je komplexní číslo, je vrácen modul (absolutní hodnota komplexního čísla, někdy také nazýván norma), což je vzdálenost od počátku. Například: <strong class="userinput"><code>|3 * e^(1i*pi)|</code></strong> vrátí 3.</p><p>Více informací najdete v encyklopediích <a class="ulink" href="http://mathworld.wolfram.com/AbsoluteValue.html" target="_top">Mathworld</a> (text je v angličtině) a <a class="ulink" href="http://cs.wikipedia.org/wiki/Absolutn%C3%AD_hodnota" target="_top">Wikipedia</a>.</p></dd><dt><span class="term"><strong class="userinput"><code>a^b</code></strong></span></dt><dd><p>Umocnění, umocní <code class="varname">a</code> na <code class="varname">b</code>-tou.</p></dd><dt><span class="term"><strong class="userinput"><code>a.^b</code></strong></span></dt><dd><p>Umocňování prvek po prvku. Umocní každý prvek matice <code class="varname">a</code> na <code class="varname">b</code>-tou. Nebo, když je <code class="varname">b</code> matice stejné velikosti jako <code class="varname">a</code>, umocňuje se prvek po prvku. Pokud je <code class="varname">a</code> číslo a <code class="varname">b</code> je matice, pak se vytvoří matice stejné velikosti jako <code class="varname">b</code> s <code class="varname">a</code> umocněným na všechny různé mocnitele v <code class="varname">b</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>a+b</code></strong></span></dt><dd><p>Sčítání. Sečte dvě čísla, matice, funkce nebo řetězce. Pokud přičtete řetězec k čemukoliv, výsledkem bude vždy řetězec. Pokud je jeden operand čtvercová matice a druhý číslo, je číslo vynásobeno jednotkovou maticí.</p></dd><dt><span class="term"><strong class="userinput"><code>a-b</code></strong></span></dt><dd><p>Odčítání. Odečte dvě čísla, matice nebo funkce.</p></dd><dt><span class="term"><strong class="userinput"><code>a*b</code></strong></span></dt><dd><p>Násobení. Jedná se o normální násobení matic.</p></dd><dt><span class="term"><strong class="userinput"><code>a.*b</code></strong></span></dt><dd><p>Násobení prvek po prvku v situaci, kdy <code class="varname">a</code> a <code class="varname">b</code> jsou matice.</p></dd><dt><span class="term"><strong class="userinput"><code>a/b</code></strong></span></dt><dd><p>Dělení. Pokud jsou <code class="varname">a</code> a <code class="varname">b</code> čísla, jedná se o běžné dělení. Pokud to jsou matice, odpovídá to <strong class="userinput"><code>a*b^-1</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>a./b</code></strong></span></dt><dd><p>Dělení prvek po prvku. Pro čísla je to stejné jako <strong class="userinput"><code>a/b</code></strong>, ale u matic to funguje prvek po prvku.</p></dd><dt><span class="term"><strong class="userinput"><code>a\b</code></strong></span></dt><dd><p>Zpětné dělení. Je to to stejné, jako <strong class="userinput"><code>b/a</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>a.\b</code></strong></span></dt><dd><p>Zpětné dělení prvků prvky.</p></dd><dt><span class="term"><strong class="userinput"><code>a%b</code></strong></span></dt><dd><p>Operátor zbytku. Nepřepíná do režimu <a class="link" href="ch05s06.html" title="Modulární aritmetika">modulární aritmetiky</a>, ale jen prostě vrátí zbytek podílu <strong class="userinput"><code>a/b</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>a.%b</code></strong></span></dt><dd><p>Operátor zbytku dělení prvků prvky. Vrací zbytky po dělení celočíselných prvků celočíselnými prvky <strong class="userinput"><code>a./b</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>a mod b</code></strong></span></dt><dd><p>Operátor modulární aritmetiky. Výraz <code class="varname">a</code> je vyhodnocen modulární aritmetikou vůči <code class="varname">b</code>. Viz <a class="xref" href="ch05s06.html" title="Modulární aritmetika">„Modulární aritmetika“</a>. Některé funkce a operátory se chovají odlišně při modulární aritmetice s celými čísly.</p></dd><dt><span class="term"><strong class="userinput"><code>a!</code></strong></span></dt><dd><p>Operátor faktoriálu. Je to jako <strong class="userinput"><code>1*…*(n-2)*(n-1)*n</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>a!!</code></strong></span></dt><dd><p>Operátor dvojitého faktoriálu. Je to jako <strong class="userinput"><code>1*…*(n-4)*(n-2)*n</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>a==b</code></strong></span></dt><dd><p>Operátor rovnosti, vrací <code class="constant">true</code> (pravda) nebo <code class="constant">false</code> (nepravda) podle toho, zda <code class="varname">a</code> je <code class="varname">b</code> rovno nebo není rovno.</p></dd><dt><span class="term"><strong class="userinput"><code>a!=b</code></strong></span></dt><dd><p>Operátor nerovnosti, vrací <code class="constant">true</code> (pravda) v případě, že <code class="varname">a</code> se nerovná <code class="varname">b</code>, jinak vrací <code class="constant">false</code> (nepravda).</p></dd><dt><span class="term"><strong class="userinput"><code>a&lt;&gt;b</code></strong></span></dt><dd><p>Alternativní operátor nerovnosti, vrací <code class="constant">true</code> (pravda) v případě, že <code class="varname">a</code> se nerovná <code class="varname">b</code>, jinak vrací <code class="constant">false</code> (nepravda).</p></dd><dt><span class="term"><strong class="userinput"><code>a&lt;=b</code></strong></span></dt><dd><p>Operátor menší než nebo rovno, vrací <code class="constant">true</code> (pravda) v případě, že <code class="varname">a</code> je menší než nebo se rovná <code class="varname">b</code>, jinak vrací <code class="constant">false</code> (nepravda). Je možné řetězit ve stylu <strong class="userinput"><code>a &lt;= b &lt;= c</code></strong> (a může se kombinovat s operátorem menší než).</p></dd><dt><span class="term"><strong class="userinput"><code>a&gt;=b</code></strong></span></dt><dd><p>Operátor větší než nebo rovno, vrací <code class="constant">true</code> (pravda) v případě, že <code class="varname">a</code> je větší než nebo se rovná <code class="varname">b</code>, jinak vrací <code class="constant">false</code> (nepravda). Je možné řetězit ve stylu <strong class="userinput"><code>a &gt;= b &gt;= c</code></strong> (a může se kombinovat s operátorem větší než).</p></dd><dt><span class="term"><strong class="userinput"><code>a&lt;=b</code></strong></span></dt><dd><p>Operátor menší než, vrací <code class="constant">true</code> (pravda) v případě, že <code class="varname">a</code> je menší než <code class="varname">b</code>, jinak vrací <code class="constant">false</code> (nepravda). Je možné řetězit ve stylu <strong class="userinput"><code>a &lt; b &lt; c</code></strong> (a může se kombinovat s operátorem menší než nebo rovno).</p></dd><dt><span class="term"><strong class="userinput"><code>a&gt;=b</code></strong></span></dt><dd><p>Operátor větší než, vrací <code class="constant">true</code> (pravda) v případě, že <code class="varname">a</code> je větší než <code class="varname">b</code>, jinak vrací <code class="constant">false</code> (nepravda). Je možné řetězit ve stylu <strong class="userinput"><code>a &gt; b &gt; c</code></strong> (a může se kombinovat s operátorem větší než nebo rovno).</p></dd><dt><span class="term"><strong class="userinput"><code>a&lt;=&gt;b</code></strong></span></dt><dd><p>Operátor porovnání. V případě, že <code class="varname">a</code> je rovno <code class="varname">b</code>, vrací 0, pokud je <code class="varname">a</code> menší než <code class="varname">b</code> vrací -1 a pokud je <code class="varname">a</code> větší než <code class="varname">b</code>, vrací 1.</p></dd><dt><span class="term"><strong class="userinput"><code>a and b</code></strong></span></dt><dd><p>Logické A (AND). Vrací pravda, když <code class="varname">a</code> i <code class="varname">b</code> jsou pravda, ve všech ostatních případech nepravda. Pokud jsou předána čísla, je se všemi nenulovými zacházeno jako s pravdivostní hodnotou pravda.</p></dd><dt><span class="term"><strong class="userinput"><code>a or b</code></strong></span></dt><dd><p>Logické NEBO (OR). Vrací pravda, když je <code class="varname">a</code> nebo <code class="varname">b</code> (nebo oboje) pravda, jinak vrací nepravda. Pokud jsou předána čísla, je se všemi nenulovými zacházeno jako s pravdivostní hodnotou pravda.</p></dd><dt><span class="term"><strong class="userinput"><code>a xor b</code></strong></span></dt><dd><p>Logické vylučovací NEBO (XOR). Vrací pravda, když právě <code class="varname">a</code> nebo <code class="varname">b</code> pravda, ve všech ostatních případech nepravda. Pokud jsou předána čísla, je se všemi nenulovými zacházeno jako s pravdivostní hodnotou pravda.</p></dd><dt><span class="term"><strong class="userinput"><code>not a</code></strong></span></dt><dd><p>Logická negace (NOT). Vrací logickou negaci <code class="varname">a</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>-a</code></strong></span></dt><dd><p>Operátor negace. Vrací opačné číslo nebo matici (u matice pracuje prvek po prvku).</p></dd><dt><span class="term"><strong class="userinput"><code>&amp;a</code></strong></span></dt><dd><p>Reference proměnné (pro předání odkazu na proměnnou). Viz <a class="xref" href="ch06s08.html" title="Reference">„Reference“</a>.</p></dd><dt><span class="term"><strong class="userinput"><code>*a</code></strong></span></dt><dd><p>Dereference proměnné (pro přístup k odkazované proměnné). Viz <a class="xref" href="ch06s08.html" title="Reference">„Reference“</a>.</p></dd><dt><span class="term"><strong class="userinput"><code>a'</code></strong></span></dt><dd><p>Transponovat matici komplexně sdruženou (Hermiteovsky sdružená matice). Tj. řádky a sloupce se prohodí a vezmou se komplexně sdružená čísla ke všem prvkům. To znamená, že když prvek i,j matice <code class="varname">a</code> je x+iy, pak prvek j,i matice <strong class="userinput"><code>a'</code></strong> je x-iy.</p></dd><dt><span class="term"><strong class="userinput"><code>a.'</code></strong></span></dt><dd><p>Transponovat matici (bez komplexního sdružení). To znamená, že prvek i,j matice <code class="varname">a</code> se stane prvkem j,i matice <strong class="userinput"><code>a.'</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>a@(b,c)</code></strong></span></dt><dd><p>Získat prvek matice v řádku <code class="varname">b</code> a sloupci <code class="varname">c</code>. Pokud jsou <code class="varname">b</code>, <code class="varname">c</code> vektory, získají se odpovídající řádky, sloupce nebo podmatice.</p></dd><dt><span class="term"><strong class="userinput"><code>a@(b,)</code></strong></span></dt><dd><p>Získat řádek matice (nebo více řádků, pokud je <code class="varname">b</code> vektor).</p></dd><dt><span class="term"><strong class="userinput"><code>a@(b,:)</code></strong></span></dt><dd><p>Stejné jako předchozí.</p></dd><dt><span class="term"><strong class="userinput"><code>a@(,c)</code></strong></span></dt><dd><p>Získat sloupec matice (nebo sloupce, pokud je <code class="varname">c</code> vektor).</p></dd><dt><span class="term"><strong class="userinput"><code>a@(:,c)</code></strong></span></dt><dd><p>Stejné jako předchozí.</p></dd><dt><span class="term"><strong class="userinput"><code>a@(b)</code></strong></span></dt><dd><p>Získat prvek z matice, s kterou se zachází jako s vektorem. Matice se prochází řádek pro řádku.</p></dd><dt><span class="term"><strong class="userinput"><code>a:b</code></strong></span></dt><dd><p>Sestavit vektor od <code class="varname">a</code> do <code class="varname">b</code> (nebo zadané části řádku, sloupce pro operátor <code class="literal">@</code>). Například pro získání řádků 2 až 4 z matice <code class="varname">A</code> byste mohli použít </p><pre class="programlisting">A@(2:4,)
	     </pre><p>, kdy <strong class="userinput"><code>2:4</code></strong> vrátí vektor <strong class="userinput"><code>[2,3,4]</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>a:b:c</code></strong></span></dt><dd><p>Sestavit vektor od <code class="varname">a</code> do <code class="varname">c</code> s krokem <code class="varname">b</code>. Tj. například </p><pre class="programlisting">genius&gt; 1:2:9
=
`[1, 3, 5, 7, 9]
</pre><p>Když jsou použita desetinná čísla, například <strong class="userinput"><code>1.0:0.4:3.0</code></strong>, je výstupem to, co očekáváte, přestože se k 1,0 pětkrát přidá 0,4, je to jen o něco více než 3,0 z důvodu, jakým jsou desetinná čísla uchována ve dvojkové soustavě (není to přesně 0,4, ale uložené číslo je obvykle o trochu větší). Způsob, jakým je to zpracováváno, je stejný jako u cyklu a sčítacích a násobících smyček. Pokud je konec v rámci <strong class="userinput"><code>2^-20</code></strong>násobku velikosti kroku koncového bodu, je koncový bod použit a předpokládá se, že nastaly chyby zaokrouhlení. To sice není perfektní, ale řeší to většinu případů. Tato kontrola se provádí až ve verzi 1.0.18 a novějších, takže provádění vašeho kódu může být ve starších verzích odlišné. Pokud chcete této záležitosti předejít, používejte opravdová racionální čísla, případně použijte funkci <code class="function">float</code>, když si přejete na konci dostat desetinné číslo. Například <strong class="userinput"><code>1:2/5:3</code></strong> funguje správně a <strong class="userinput"><code>float(1:2/5:3)</code></strong> vám poskytne desetinné číslo a přitom to bude nepatrně přesnější než <strong class="userinput"><code>1.0:0.4:3.0</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>(a)i</code></strong></span></dt><dd><p>Vytvořit imaginární číslo (vynásobit <code class="varname">a</code> imaginárním <code class="varname">i</code>). Všimněte si, že normálně se <code class="varname">i</code> zapisuje jako <code class="varname">1i</code>. Takže předchozí je vlastně ekvivalentní </p><pre class="programlisting">(a)*1i
	     </pre></dd><dt><span class="term"><strong class="userinput"><code>`a</code></strong></span></dt><dd><p>Uvozovat identifikátor, kterýžto nebude vyhodnocen. Nebo uvozovat matici, takže nebude rozšířena.</p></dd><dt><span class="term"><strong class="userinput"><code>a swapwith b</code></strong></span></dt><dd><p>Přehodit hodnotu proměnné <code class="varname">a</code> s hodnotou proměnné <code class="varname">b</code>. V současnosti nepracuje s částmi prvků matice. Vrací <code class="constant">null</code>. Dostupné od verze 1.0.13.</p></dd><dt><span class="term"><strong class="userinput"><code>increment a</code></strong></span></dt><dd><p>Zvýšit hodnotu proměnné <code class="varname">a</code> o 1. V případě, že <code class="varname">a</code> je matice, je o 1 zvýšen každý prvek. Dělá to vlastně to stejné co <strong class="userinput"><code>a=a+1</code></strong>, akorát o něco rychleji. Vrací <code class="constant">null</code>. Dostupné od verze 1.0.13.</p></dd><dt><span class="term"><strong class="userinput"><code>increment a by b</code></strong></span></dt><dd><p>Zvýšit hodnotu proměnné <code class="varname">a</code> o <code class="varname">b</code>. V případě, že <code class="varname">a</code> je matice, je o zvýšen každý prvek. Dělá to vlastně to stejné co <strong class="userinput"><code>a=a+b</code></strong>, akorát o něco rychleji. Vrací <code class="constant">null</code>. Dostupné od verze 1.0.13.</p></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Poznámka</h3><p>Operátor @() dává operátoru : více možností. S ním můžete určovat části matice. Takže a@(2:4,6) jsou řádky 2,3,4 sloupce 6. Nebo a@(,1:2) vám dá první dva sloupce matice. Do operátoru @() můžete i přiřazovat, stačí když je pravou hodnotou matice o stejném rozměru jako určená oblast nebo je to jiný typ hodnoty.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Poznámka</h3><p>Porovnávací operátory (vyjma operátoru &lt;=&gt;, který se chová normálně) nejsou striktně binární operátory, mohou být fakticky seskupovány běžným matematickým způsobem, např.: (1&lt;x&lt;=y&lt;5) je platný pravdivostní výraz a znamená přesně to, co by měl, tj. (1&lt;x a x≤y a y&lt;5)</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Poznámka</h3><p>Unární operátor mínus funguje různými způsoby v závislosti na tom, kde se vyskytuje. Když se objeví před číslem, váže se přímo k němu. Když se objeví před výrazem, má slabší vazbu než mocnina a faktoriál. Například <strong class="userinput"><code>-1^k</code></strong> je ve skutečnosti <strong class="userinput"><code>(-1)^k</code></strong>, ale <strong class="userinput"><code>-neco(1)^k</code></strong> je ve skutečnosti <strong class="userinput"><code>-(neco(1)^k)</code></strong>. Takže věnujte pozornost tomu, jak je používáte a pokud máte pochybnosti, raději přidejte závorky.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s06.html">Předcházející</a> </td><td width="20%" align="center"><a accesskey="u" href="ch05.html">Nahoru</a></td><td width="40%" align="right"> <a accesskey="n" href="ch06.html">Další</a></td></tr><tr><td width="40%" align="left" valign="top">Modulární aritmetika </td><td width="20%" align="center"><a accesskey="h" href="index.html">Domů</a></td><td width="40%" align="right" valign="top"> Kapitola 6. Programování s jazykem GEL</td></tr></table></div></body></html>
