<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Lista över GEL-operatorer</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Handbok för Genius"><link rel="up" href="ch05.html" title="Kapitel 5. Grunderna i GEL"><link rel="prev" href="ch05s06.html" title="Moduloberäkning"><link rel="next" href="ch06.html" title="Kapitel 6. Programmering med GEL"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Lista över GEL-operatorer</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s06.html">Föregående</a> </td><th width="60%" align="center">Kapitel 5. Grunderna i GEL</th><td width="20%" align="right"> <a accesskey="n" href="ch06.html">Nästa</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="genius-gel-operator-list"></a>Lista över GEL-operatorer</h2></div></div></div><p>Allt i GEL är bara ett uttryck. Uttryck slås samman med olika operatorer. Som vi har sett är till och med avskiljaren helt enkelt en binär operator i GEL. Här är en lista över operatorerna i GEL.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><strong class="userinput"><code>a;b</code></strong></span></dt><dd><p>Avskiljaren, evaluerar helt enkelt både <code class="varname">a</code> och <code class="varname">b</code>, men returnerar bara resultatet av <code class="varname">b</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>a=b</code></strong></span></dt><dd><p>Tilldelningsoperatorn. Denna tilldelar <code class="varname">b</code> till <code class="varname">a</code> (<code class="varname">a</code> måste vara ett giltigt <a class="link" href="ch06s09.html" title="Vvärden">vvärde</a>) (observera dock att denna operator kan översättas till <code class="literal">==</code> om den används där ett booleskt uttryck förväntas)</p></dd><dt><span class="term"><strong class="userinput"><code>a:=b</code></strong></span></dt><dd><p>Tilldelningsoperatorn. Tilldelar <code class="varname">b</code> till <code class="varname">a</code> (<code class="varname">a</code> måste vara ett giltigt <a class="link" href="ch06s09.html" title="Vvärden">vvärde</a>) Detta skiljer sig från <code class="literal">=</code> eftersom det aldrig översätts till <code class="literal">==</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>|a|</code></strong></span></dt><dd><p>Absolutbelopp. Om uttrycket är ett komplext tak kommer resultatet vara avståndet från origo. Till exempel: <strong class="userinput"><code>|3 * e^(1i*pi)|</code></strong> returnerar 3.</p><p>Se <a class="ulink" href="http://mathworld.wolfram.com/AbsoluteValue.html" target="_top">Mathworld</a> för mer information.</p></dd><dt><span class="term"><strong class="userinput"><code>a^b</code></strong></span></dt><dd><p>Exponentiering, upphöjer <code class="varname">a</code> till exponenten <code class="varname">b</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>a.^b</code></strong></span></dt><dd><p>Elementvis exponentiering. Upphöj varje element i en matris <code class="varname">a</code> till exponenten <code class="varname">b</code>. Eller om <code class="varname">b</code> är en matris med samma storlek som <code class="varname">a</code>, gör i så fall operationen elementvis. Om <code class="varname">a</code> är ett tal och <code class="varname">b</code> är en matris så skapar det en matris av samma storlek som <code class="varname">b</code> med <code class="varname">a</code> upphöjt till alla de olika exponenterna i <code class="varname">b</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>a+b</code></strong></span></dt><dd><p>Addition. Adderar två tal, matriser, funktioner eller strängar. Om du lägger till en sträng kommer resultatet att vara en sträng. Om en är en kvadratisk matris och den andra ett tal kommer talet att multipliceras med identitetsmatrisen.</p></dd><dt><span class="term"><strong class="userinput"><code>a-b</code></strong></span></dt><dd><p>Subtraktion. Subtrahera två tal, matriser eller funktioner.</p></dd><dt><span class="term"><strong class="userinput"><code>a*b</code></strong></span></dt><dd><p>Multiplikation. Detta är vanlig matrismultiplikation.</p></dd><dt><span class="term"><strong class="userinput"><code>a.*b</code></strong></span></dt><dd><p>Elementvis multiplikation om <code class="varname">a</code> och <code class="varname">b</code> är matriser.</p></dd><dt><span class="term"><strong class="userinput"><code>a/b</code></strong></span></dt><dd><p>Division. Då <code class="varname">a</code> och <code class="varname">b</code> bara är tal är detta vanlig division. Då de är matriser är detta ekvivalent med <strong class="userinput"><code>a*b^-1</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>a./b</code></strong></span></dt><dd><p>Elementvis division. Samma som <strong class="userinput"><code>a/b</code></strong> för tal, men opererar elementvis på matriser.</p></dd><dt><span class="term"><strong class="userinput"><code>a\b</code></strong></span></dt><dd><p>Baklängesdivision. Det vill säga detta är samma sak som <strong class="userinput"><code>b/a</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>a.\b</code></strong></span></dt><dd><p>Elementvis baklängesdivision.</p></dd><dt><span class="term"><strong class="userinput"><code>a%b</code></strong></span></dt><dd><p>Modulooperatorn. Detta slår inte på <a class="link" href="ch05s06.html" title="Moduloberäkning">moduloläget</a>, utan returnerar bara resten av <strong class="userinput"><code>a/b</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>a.%b</code></strong></span></dt><dd><p>Elementvis modulooperator. Returnerar resten efter elementvis <strong class="userinput"><code>a./b</code></strong> av heltal.</p></dd><dt><span class="term"><strong class="userinput"><code>a mod b</code></strong></span></dt><dd><p>Modulär evalueringsoperator. Uttrycket <code class="varname">a</code> evalueras modulo <code class="varname">b</code>. Se <a class="xref" href="ch05s06.html" title="Moduloberäkning">”Moduloberäkning”</a>. Vissa funktioner och operatorer beter sig annorlunda modulo ett heltal.</p></dd><dt><span class="term"><strong class="userinput"><code>a!</code></strong></span></dt><dd><p>Fakultetsoperator. Detta är som <strong class="userinput"><code>1*...*(n-2)*(n-1)*n</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>a!!</code></strong></span></dt><dd><p>Semifakultetsoperator. Detta är som <strong class="userinput"><code>1*...*(n-4)*(n-2)*n</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>a==b</code></strong></span></dt><dd><p>Likhetsoperator. Returnerar <code class="constant">true</code> eller <code class="constant">false</code> beroende på om <code class="varname">a</code> och <code class="varname">b</code> är lika eller inte.</p></dd><dt><span class="term"><strong class="userinput"><code>a!=b</code></strong></span></dt><dd><p>Olikhetsoperator, returnerar <code class="constant">true</code> om <code class="varname">a</code> inte är lika med <code class="varname">b</code>, returnerar annars <code class="constant">false</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>a&lt;&gt;b</code></strong></span></dt><dd><p>Alternativ olikhetsoperator, returnerar <code class="constant">true</code> om <code class="varname">a</code> inte är lika med <code class="varname">b</code>, returnerar annars <code class="constant">false</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>a&lt;=b</code></strong></span></dt><dd><p>Mindre än eller lika med-operator, returnerar <code class="constant">true</code> om <code class="varname">a</code> är mindre eller lika med <code class="varname">b</code>, returnerar annars <code class="constant">false</code>. Dessa kan kombineras som i <strong class="userinput"><code>a &lt;= b &lt;= c</code></strong> (kan också kombineras med mindre än-operatorn).</p></dd><dt><span class="term"><strong class="userinput"><code>a&gt;=b</code></strong></span></dt><dd><p>Större än eller lika med-operator, returnerar <code class="constant">true</code> om <code class="varname">a</code> är större eller lika med <code class="varname">b</code>, returnerar annars <code class="constant">false</code>. Dessa kan kombineras som i <strong class="userinput"><code>a &gt;= b &gt;= c</code></strong> (kan också kombineras med större än-operatorn).</p></dd><dt><span class="term"><strong class="userinput"><code>a&lt;b</code></strong></span></dt><dd><p>Mindre än-operator, returnerar <code class="constant">true</code> om <code class="varname">a</code> är mindre än <code class="varname">b</code>, returnerar annars <code class="constant">false</code>. Dessa kan kombineras som i <strong class="userinput"><code>a &lt; b &lt; c</code></strong> (kan också kombineras med mindre än eller lika med-operatorn).</p></dd><dt><span class="term"><strong class="userinput"><code>a&gt;b</code></strong></span></dt><dd><p>Större än-operator, returnerar <code class="constant">true</code> om <code class="varname">a</code> är större än <code class="varname">b</code>, returnerar annars <code class="constant">false</code>. Dessa kan kombineras som i <strong class="userinput"><code>a &gt; b &gt; c</code></strong> (kan också kombineras med större än eller lika med-operatorn).</p></dd><dt><span class="term"><strong class="userinput"><code>a&lt;=&gt;b</code></strong></span></dt><dd><p>Jämförelseoperator. Om <code class="varname">a</code> är lika med <code class="varname">b</code> returnerar den 0, om <code class="varname">a</code> är mindre än <code class="varname">b</code> returnerar den -1 och om <code class="varname">a</code> är större än <code class="varname">b</code> returnerar den 1.</p></dd><dt><span class="term"><strong class="userinput"><code>a and b</code></strong></span></dt><dd><p>Logiskt och. Returnerar true om både <code class="varname">a</code> och <code class="varname">b</code> är true, returnerar annars false. Om tal gives behandlas nollskilda tal som true.</p></dd><dt><span class="term"><strong class="userinput"><code>a or b</code></strong></span></dt><dd><p>Logiskt eller. Returnerar true om antingen <code class="varname">a</code> eller <code class="varname">b</code> är true, returnerar annars false. Om tal gives behandlas nollskilda tal som true.</p></dd><dt><span class="term"><strong class="userinput"><code>a xor b</code></strong></span></dt><dd><p>Logiskt uteslutande eller. Returnerar true om exakt en av <code class="varname">a</code> eller <code class="varname">b</code> är true, returnerar annars false. Om tal gives behandlas nollskilda tal som true.</p></dd><dt><span class="term"><strong class="userinput"><code>not a</code></strong></span></dt><dd><p>Logiskt inte. Returnerar den logiska negationen till <code class="varname">a</code></p></dd><dt><span class="term"><strong class="userinput"><code>-a</code></strong></span></dt><dd><p>Negationsoperator. Returnerar negativet av ett tal eller en matris (arbetar elementvis på en matris).</p></dd><dt><span class="term"><strong class="userinput"><code>&amp;a</code></strong></span></dt><dd><p>Variabelreferens (för att skicka en referens till en variabel). Se <a class="xref" href="ch06s08.html" title="Referenser">”Referenser”</a>.</p></dd><dt><span class="term"><strong class="userinput"><code>*a</code></strong></span></dt><dd><p>Variabeldereferering (för att komma åt en refererad variabel). Se <a class="xref" href="ch06s08.html" title="Referenser">”Referenser”</a>.</p></dd><dt><span class="term"><strong class="userinput"><code>a'</code></strong></span></dt><dd><p>Konjugattransponatet för matris. Det vill säga rader och kolumner byter plats och vi tar komplexkonjugatet av alla poster. Det vill säga om i,j-elementet av <code class="varname">a</code> är x+iy så är j,i-elementet av <strong class="userinput"><code>a'</code></strong> då x-iy.</p></dd><dt><span class="term"><strong class="userinput"><code>a.'</code></strong></span></dt><dd><p>Matristransponat, konjugerar inte posterna. Det vill säga i,j-elementet av <code class="varname">a</code> blir j,i-elementet av <strong class="userinput"><code>a.'</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>a@(b,c)</code></strong></span></dt><dd><p>Hämta element för en matris i rad <code class="varname">b</code> och kolumn <code class="varname">c</code>. Om <code class="varname">b</code>, <code class="varname">c</code> är vektorer så ger detta de motsvarande raderna, kolumnerna eller delmatriserna.</p></dd><dt><span class="term"><strong class="userinput"><code>a@(b,)</code></strong></span></dt><dd><p>Hämta rad av en matris (eller flera rader om <code class="varname">b</code> är en vektor).</p></dd><dt><span class="term"><strong class="userinput"><code>a@(b,:)</code></strong></span></dt><dd><p>Samma som ovan.</p></dd><dt><span class="term"><strong class="userinput"><code>a@(,c)</code></strong></span></dt><dd><p>Hämta kolumn av en matris (eller flera kolumner om <code class="varname">b</code> är en vektor).</p></dd><dt><span class="term"><strong class="userinput"><code>a@(:,c)</code></strong></span></dt><dd><p>Samma som ovan.</p></dd><dt><span class="term"><strong class="userinput"><code>a@(b)</code></strong></span></dt><dd><p>Hämta ett element från en matris behandlad som en vektor. Detta kommer traversera matrisen radvis.</p></dd><dt><span class="term"><strong class="userinput"><code>a:b</code></strong></span></dt><dd><p>Bygg en vektor från <code class="varname">a</code> till <code class="varname">b</code> (eller ange en rad- och kolumnregion för <code class="literal">@</code>-operatorn). Till exempel kan vi för att få raderna 2 till 4 av matrisen <code class="varname">A</code> göra </p><pre class="programlisting">A@(2:4,)
	     </pre><p> eftersom <strong class="userinput"><code>2:4</code></strong> kommer returnera en vektor <strong class="userinput"><code>[2,3,4]</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>a:b:c</code></strong></span></dt><dd><p>Bygg en vektor från <code class="varname">a</code> till <code class="varname">c</code> med <code class="varname">b</code> som steglängd. Det vill säga exempelvis </p><pre class="programlisting">genius&gt; 1:2:9
=
`[1, 3, 5, 7, 9]
</pre><p>Då de inblandade talen är flyttal, till exempel <strong class="userinput"><code>1.0:0.4:3.0</code></strong>, är utmatningen vad som förväntas även om att lägga till 0.4 till 1.0 fem gånger faktiskt är något mindre än 3.0 på grund av sättet som flyttal lagras i bas 2 (det finns inget 0.4, det faktiska lagrade talet är bara något större). Sättet detta hanteras är detsamma som i for-, sum-, och prod-slingorna. Om slutet är inom <strong class="userinput"><code>2^-20</code></strong> gånger stegstorleken till ändpunkten, används ändpunkten och vi antar att det fanns avrundningsfel. Detta är inte perfekt, men hanterar de flesta fallen. Denna kontroll görs bara från version 1.0.18 och framåt, så exekvering av din kod kan skilja sig åt i äldre versioner. Använd faktiska rationella tal om du vill undvika att hantera detta problem, möjligen tillsammans med <code class="function">float</code> om du vill få flyttal i slutet. Till exempel gör <strong class="userinput"><code>1:2/5:3</code></strong> rätt sak och <strong class="userinput"><code>float(1:2/5:3)</code></strong> ger dig till och med flyttal och är även något mer exakt än <strong class="userinput"><code>1.0:0.4:3.0</code></strong>.</p></dd><dt><span class="term"><strong class="userinput"><code>(a)i</code></strong></span></dt><dd><p>Skapa ett imaginärt tal (multiplicera <code class="varname">a</code> med det imaginära). Observera att <code class="varname">i</code> vanligen skrivs <strong class="userinput"><code>1i</code></strong>, så det ovanstående är detsamma som </p><pre class="programlisting">(a)*1i
	     </pre></dd><dt><span class="term"><strong class="userinput"><code>`a</code></strong></span></dt><dd><p>Citera en identifierare så att den inte evalueras. Eller citera en matris så att den inte expanderas.</p></dd><dt><span class="term"><strong class="userinput"><code>a swapwith b</code></strong></span></dt><dd><p>Byt värde på <code class="varname">a</code> med värdet av <code class="varname">b</code>. Opererar för närvarande inte på intervall av matriselement. Det returnerar <code class="constant">null</code>. Tillgängligt från version 1.0.13.</p></dd><dt><span class="term"><strong class="userinput"><code>increment a</code></strong></span></dt><dd><p>Inkrementera variabeln <code class="varname">a</code> med 1. Om <code class="varname">a</code> är en matris inkrementeras varje element. Detta är ekvivalent med <strong class="userinput"><code>a=a+1</code></strong>, men är något snabbare. Det returnerar <code class="constant">null</code>. Tillgängligt från version 1.0.13.</p></dd><dt><span class="term"><strong class="userinput"><code>increment a by b</code></strong></span></dt><dd><p>Inkrementera variabeln <code class="varname">a</code> med <code class="varname">b</code>. Om <code class="varname">a</code> är en matris inkrementeras varje element. Detta är ekvivalent med <strong class="userinput"><code>a=a+b</code></strong>, men är något snabbare. Det returnerar <code class="constant">null</code>. Tillgängligt från version 1.0.13.</p></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Notera</h3><p>@()-operatorn gör :-operatorn mest användbar. Med denna kan du ange regioner i en matris. Därmed är a@(2:4,6) raderna 2,3,4 för kolumn 6. Eller så ger a@(,1:2) dig de två första kolumnerna i en matris. Du kan också tilldela till @()-operatorn, så länge som högervärdet är en matris som matchar regionens storlek, eller om det är någon annan sorts värde.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Notera</h3><p>Jämförelseoperatorerna (förutom &lt;=&gt;-operatorn, vilken beter sig normalt) är inte strikt binära operatorer, de kan i själva verket grupperas på det vanliga matematiska sättet, t.ex. så är (1&lt;x&lt;=y&lt;5) ett giltigt booleskt uttryck och betyder precis vad det borde, det vill säga (1&lt;x och x≤y och y&lt;5)</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Notera</h3><p>Unärt minus opererar annorlunda beroende på var det förekommer. Om det förekommer före ett tal binder det väldigt hårt, om det förekommer före ett uttryck binder det mindre hårt än potens- och fakultet-operatorerna. Så till exempel är <strong class="userinput"><code>-1^k</code></strong> faktiskt <strong class="userinput"><code>(-1)^k</code></strong>, men <strong class="userinput"><code>-foo(1)^k</code></strong> är verkligen <strong class="userinput"><code>-(foo(1)^k)</code></strong>. Så var aktsam över hur du använder det, och om du är osäker, lägg till parenteser.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s06.html">Föregående</a> </td><td width="20%" align="center"><a accesskey="u" href="ch05.html">Upp</a></td><td width="40%" align="right"> <a accesskey="n" href="ch06.html">Nästa</a></td></tr><tr><td width="40%" align="left" valign="top">Moduloberäkning </td><td width="20%" align="center"><a accesskey="h" href="index.html">Hem</a></td><td width="40%" align="right" valign="top"> Kapitel 6. Programmering med GEL</td></tr></table></div></body></html>
