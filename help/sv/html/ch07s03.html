<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Returnera funktioner</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Handbok för Genius"><link rel="up" href="ch07.html" title="Kapitel 7. Avancerad programmering med GEL"><link rel="prev" href="ch07s02.html" title="Toppnivåsyntax"><link rel="next" href="ch07s04.html" title="Verkligt lokala variabler"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Returnera funktioner</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch07s02.html">Föregående</a> </td><th width="60%" align="center">Kapitel 7. Avancerad programmering med GEL</th><td width="20%" align="right"> <a accesskey="n" href="ch07s04.html">Nästa</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="genius-gel-returning-functions"></a>Returnera funktioner</h2></div></div></div><p>Det är möjligt att returnera funktioner som värde. På detta sätt kan du bygga funktioner som konstruerar specialanpassade funktioner enligt några parametrar. Det svåra är vilka variabler som funktionen ser. Sättet det fungerar på i GEL är att när en funktion returnerar en annan funktion, blir alla identifierare refererade i funktionskroppen som gick utanför räckvidd föregångna med en privat ordbok av den returnerade funktionen. Funktion kommer därmed se alla variabler som var inom räckvidd då den definierades. Till exempel definierar vi en funktion som returnerar en funktion som lägger till 5 till sitt argument. </p><pre class="programlisting">function f() = (
  k = 5;
  `(x) = (x+k)
)
</pre><p> Observera att funktionen lägger till <code class="varname">k</code> till <code class="varname">x</code>. Du kan använda detta som följer. </p><pre class="programlisting">g = f();
g(5)
</pre><p> och <strong class="userinput"><code>g(5)</code></strong> skulle returnera 10.</p><p>En sak att notera är att värdet på <code class="varname">k</code> som används är det som används då <code class="function">f</code> returnerar. Till exempel: </p><pre class="programlisting">function f() = (
  k := 5;
  function r(x) = (x+k);
  k := 10;
  r
)
</pre><p> kommer returnera en funktion som lägger till 10 till sitt argument snarare än 5. Detta är eftersom den extra ordboken skapas bara då kontexten i vilken funktionen definierades tar slut, vilket är när funktionen <code class="function">f</code> returnerar. Detta är konsekvent med hur du skulle förvänta dig att funktionen <code class="function">r</code> fungerar inuti funktionen <code class="function">f</code> enligt reglerna för variabelräckvidd i GEL. Endast de variabler som är i kontexten som just tog slut och inte längre existerar läggs till i den extra ordboken. Variabler som används i funktionen som är i fortfarande giltiga kontexter kommer fungera som vanligt, med aktuellt värde på variabeln. Den enda skillnaden är med globala variabler och funktioner. Alla identifierare som refererade globala variabler under tiden för funktionsdefinitionen läggs inte till i den privata ordboken. Detta är för att undvika mycket onödigt arbete då funktioner returneras och kommer sällan vara ett problem. Anta till exempel att du tar bort "k=5" från funktionen <code class="function">f</code>, och att du på toppnivån definierar <code class="varname">k</code> till att vara exempelvis 5. När du då kör <code class="function">f</code> kommer funktionen <code class="function">r</code> inte lägga <code class="varname">k</code> i den privata ordboken eftersom den var global (toppnivå) då <code class="function">r</code> definierades.</p><p>Ibland är det bättre att ha mer kontroll över hur variabler kopieras till den privata ordboken. Sedan version 1.0.7 kan du ange vilka variabler som kopieras till den privata ordboken genom att lägga till extra hakparenteser efter argumenten med listan över variabler som ska kopieras separerade av kommatecken. Om du gör detta kopieras variabler till den privata ordboken vid funktionsdefinitionen, och den privata ordboken rörs inte efteråt. Till exempel kommer </p><pre class="programlisting">function f() = (
  k := 5;
  function r(x) [k] = (x+k);
  k := 10;
  r
)
</pre><p> returnera en funktion som när den anropas kommer lägga till 5 till sitt argument. Den lokala kopian av <code class="varname">k</code> skapades när funktionen definierades.</p><p>Då du vill att funktionen inte ska ha någon privat ordbok sätter du tomma hakparenteser efter argumentlistan. Då kommer ingen privat ordbok att skapas överhuvudtaget. Att göra detta är bra för att öka effektiviteten då en privat ordbok inte behövs eller när du inte vill att funktionen ska slå upp alla variabler då den ser dem då de anropas. Anta till exempel att du vill att funktionen som returneras från <code class="function">f</code> ska se värdet av <code class="varname">k</code> från toppnivån även om det finns en lokal variabel med samma namn under definitionen. Så koden </p><pre class="programlisting">function f() = (
  k := 5;
  function r(x) [] = (x+k);
  r
);
k := 10;
g = f();
g(10)
</pre><p> kommer att returnera 20 och inte 15, vilket skulle hända om <code class="varname">k</code> med ett värde av 5 lades till i den privata ordboken.</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch07s02.html">Föregående</a> </td><td width="20%" align="center"><a accesskey="u" href="ch07.html">Upp</a></td><td width="40%" align="right"> <a accesskey="n" href="ch07s04.html">Nästa</a></td></tr><tr><td width="40%" align="left" valign="top">Toppnivåsyntax </td><td width="20%" align="center"><a accesskey="h" href="index.html">Hem</a></td><td width="40%" align="right" valign="top"> Verkligt lokala variabler</td></tr></table></div></body></html>
