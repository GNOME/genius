
Genius Manual

Jiri Lebl

   University of California, San Diego

    <jirka@5z.com>

Kai Willadsen

   University of Queensland, Australia

    <kaiw@itee.uq.edu.au>

   Copyright © 1997-2007 Jiri (George) Lebl

   Copyright © 2004 Kai Willadsen

   Permission is granted to copy, distribute and/or modify this
   document under the terms of the GNU Free Documentation License
   (GFDL), Version 1.1 or any later version published by the Free
   Software Foundation with no Invariant Sections, no Front-Cover
   Texts, and no Back-Cover Texts. You can find a copy of the
   GFDL at this link or in the file COPYING-DOCS distributed with
   this manual.

   This manual is part of a collection of GNOME manuals
   distributed under the GFDL. If you want to distribute this
   manual separately from the collection, you can do so by adding
   a copy of the license to the manual, as described in section 6
   of the license.

   Many of the names used by companies to distinguish their
   products and services are claimed as trademarks. Where those
   names appear in any GNOME documentation, and the members of
   the GNOME Documentation Project are made aware of those
   trademarks, then the names are in capital letters or initial
   capital letters.

   DOCUMENT AND MODIFIED VERSIONS OF THE DOCUMENT ARE PROVIDED
   UNDER THE TERMS OF THE GNU FREE DOCUMENTATION LICENSE WITH THE
   FURTHER UNDERSTANDING THAT:

    1. DOCUMENT IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTY
       OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
       WITHOUT LIMITATION, WARRANTIES THAT THE DOCUMENT OR
       MODIFIED VERSION OF THE DOCUMENT IS FREE OF DEFECTS
       MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
       NON-INFRINGING. THE ENTIRE RISK AS TO THE QUALITY,
       ACCURACY, AND PERFORMANCE OF THE DOCUMENT OR MODIFIED
       VERSION OF THE DOCUMENT IS WITH YOU. SHOULD ANY DOCUMENT
       OR MODIFIED VERSION PROVE DEFECTIVE IN ANY RESPECT, YOU
       (NOT THE INITIAL WRITER, AUTHOR OR ANY CONTRIBUTOR) ASSUME
       THE COST OF ANY NECESSARY SERVICING, REPAIR OR CORRECTION.
       THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART
       OF THIS LICENSE. NO USE OF ANY DOCUMENT OR MODIFIED
       VERSION OF THE DOCUMENT IS AUTHORIZED HEREUNDER EXCEPT
       UNDER THIS DISCLAIMER; AND
    2. UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY, WHETHER
       IN TORT (INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE,
       SHALL THE AUTHOR, INITIAL WRITER, ANY CONTRIBUTOR, OR ANY
       DISTRIBUTOR OF THE DOCUMENT OR MODIFIED VERSION OF THE
       DOCUMENT, OR ANY SUPPLIER OF ANY OF SUCH PARTIES, BE
       LIABLE TO ANY PERSON FOR ANY DIRECT, INDIRECT, SPECIAL,
       INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY CHARACTER
       INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF
       GOODWILL, WORK STOPPAGE, COMPUTER FAILURE OR MALFUNCTION,
       OR ANY AND ALL OTHER DAMAGES OR LOSSES ARISING OUT OF OR
       RELATING TO USE OF THE DOCUMENT AND MODIFIED VERSIONS OF
       THE DOCUMENT, EVEN IF SUCH PARTY SHALL HAVE BEEN INFORMED
       OF THE POSSIBILITY OF SUCH DAMAGES.

   Feedback

   To report a bug or make a suggestion regarding the Genius Math
   Tool application or this manual, follow the directions in the
   GNOME Feedback Page.
     _________________________________________________________

   Table of Contents
   1. Introduction
   2. Getting Started

        2.1. To Start Genius Math Tool
        2.2. When You Start Genius

   3. Basic usage

        3.1. Using the workarea
        3.2. To Create a New Program
        3.3. To Open and Run a Program

   4. Plotting

        4.1. Line Plots
        4.2. Parametric Plots
        4.3. Surface Plots

   5. GEL Basics

        5.1. Values

              5.1.1. Numbers
              5.1.2. Booleans
              5.1.3. Strings
              5.1.4. Null

        5.2. Using Variables

              5.2.1. Setting Variables
              5.2.2. Global variables
              5.2.3. Built-in variables
              5.2.4. Previous result variable

        5.3. Using Functions

              5.3.1. Defining functions
              5.3.2. Variable argument lists
              5.3.3. Passing functions to functions
              5.3.4. Operations on functions

        5.4. Absolute value / Modulus
        5.5. Separator
        5.6. Modular evaluation
        5.7. List of GEL operators

   6. Programming with GEL

        6.1. Conditionals
        6.2. Loops

              6.2.1. While loops
              6.2.2. For loops
              6.2.3. Foreach loops
              6.2.4. Break and continue

        6.3. Sums and products
        6.4. Comparison operators
        6.5. Returning
        6.6. References
        6.7. Lvalues

   7. Advanced Programming with GEL

        7.1. Error handling
        7.2. GEL startup procedure
        7.3. Loading programs

   8. Matrices in GEL

        8.1. Matrix support
        8.2. Conjugate transpose and transpose operator
        8.3. Linear Algebra

   9. Polynomials in GEL

        9.1. Using Polynomials

   10. List of GEL functions

        10.1. Commands
        10.2. Basic
        10.3. Parameters
        10.4. Constants
        10.5. Numeric
        10.6. Trigonometry
        10.7. Number Theory
        10.8. Matrix Manipulation
        10.9. Linear Algebra
        10.10. Combinatorics
        10.11. Calculus
        10.12. Functions
        10.13. Equation Solving
        10.14. Statistics
        10.15. Polynomials
        10.16. Set Theory
        10.17. Miscellaneous
        10.18. Symbolic Operations
        10.19. Plotting

   11. Example programs in GEL
   12. Settings

        12.1. Output
        12.2. Precision
        12.3. Terminal

   13. About Genius Math Tool

   List of Figures
   2-1. Genius Math Tool Window
   4-1. Create Plot Window
   4-2. Plot Window
   4-3. Parametric Plots
   4-4. 
   4-5. Surface plot
     _________________________________________________________

Chapter 1. Introduction

   The Genius Math Tool application is a general calculator for
   use as a desktop calculator, an educational tool in
   mathematics, and is useful even for rudimentary research. The
   language tries to be more `mathematical' in the sense that it
   should be `what you mean is what you get', though of course
   that's not an entirely attainable goal. It features using
   rationals, arbitrary precision integers and multiple precision
   floats using the GMP library. It also fully supports complex
   numbers. It can work with matrices and vectors and do
   rudimetary linear algebra. The language can have user-defined
   functions, variables and parameters.

   This manual describes mostly the graphical version of the
   calculator, but the language is of course the same. The
   command line only version lacks the graphing capabilities and
   all other capabilities that require the graphical user
   interface.
     _________________________________________________________

Chapter 2. Getting Started

2.1. To Start Genius Math Tool

   You can start Genius Math Tool in the following ways:

   Applications menu
          Choose Office->Genius Math Tool.

          Note that depending on your system installation this
          menu item may not be available. If it is not, you can
          open the Run dialog and executing gnome-genius.

   Command line
          Execute the following command: genius. Note that this
          will start the command line only version of genius, the
          graphical environment will not start and some functions
          such as plotting will not be available. To start the
          full GNOME version of Genius execute gnome-genius.
     _________________________________________________________

2.2. When You Start Genius

   When you start Genius Math Tool, the following window is
   displayed.

   Figure 2-1. Genius Math Tool Window

   [genius_window.png]

   The Genius Math Tool window contains the following elements:

   Menubar.
          The menus on the menubar contain all of the commands
          that you need to work with files in Genius Math Tool.

   Toolbar.
          The toolbar contains a subset of the commands that you
          can access from the menubar.

   Working area
          The working area is the primary method of interacting
          with the application.

          The working area initially has just the Console tab
          which is the main way of interacting with the
          calculator. Here you type expressions and the results
          are immediately returned after you hit the Enter key.

          Alternatively you can write longer programs and those
          can appear in separate tabs and can be stored in files
          for later retrieval.
     _________________________________________________________

Chapter 3. Basic usage

3.1. Using the workarea

   Normally you interact with the calculator in the Console tab
   of the work area. If you are running the text only version
   then the console will be the only thing that is available to
   you.

   Type your expression into the Console workarea and press enter
   and the expression will be evaluated. To load a program, type
genius> load path/to/program.gel

   To list files in the current directory type ls, to change
   directory do cd directory as in the unix command shell.

   To get a list of functions and commands, type:
genius> help

   If you wish to get more help on a specific function, type:
genius> help FunctionName

   To view this manual, type:
genius> manual

   The most simple GEL (The Genius Extension Language, or
   George`s Ego Leverage) expression just looks like mathematics.
   For example
genius> 30*70 + 67^3.0 + ln(7) * (88.8/100)

   or
genius> 62734 + 812634 + 77^4 mod 5

   or
genius> | sin(37) - e^7 |

   or
genius> sum n=1 to 70 do 1/n

   (Last is the harmonic sum from 1 to 70)
     _________________________________________________________

3.2. To Create a New Program

   To start writing a new program, choose File->New Program. A
   new tab will appear in the workarea. You can write a GEL
   program in this workarea.

   To save the program you've just written, choose File->Save
   As...
     _________________________________________________________

3.3. To Open and Run a Program

   To open a file in order, choose File->Open. A new tab
   containing the file will appear in the workarea. You can use
   this to edit the file.

   To run a program from a file, choose File->Load and Run....
     _________________________________________________________

Chapter 4. Plotting

   Plotting support is only available in the graphical GNOME
   version. All plotting accessible from the graphical interface
   is available from the Create Plot window. You can access this
   window by either clicking on the Plot button on the toolbar or
   selecting Plot from the Calculator menu. You can also access
   the plotting functionality by using the plotting functions of
   the GEL language. See the chapter on GEL Basics to find out
   how to enter expressions that Genius understands.
     _________________________________________________________

4.1. Line Plots

   To graph real valued functions of one variable open the Create
   Plot window. You can also use the LinePlot function on the
   command line (see its documentation).

   Once you click the Plot button, a window opens up with some
   notebooks in it. You want to be in the "Function line plot"
   notebook tab, and inside you want to be on the "Functions /
   Expressions" notebook tab.

   Figure 4-1. Create Plot Window

   [line_plot.png]

   Into the text boxes just type in expressions where x is the
   independent variable. You can also just give names of
   functions such as cos rather then having to type cos(x). You
   can graph up to ten functions. If you make a mistake and
   Genius cannot parse the input it will signify this with a
   warning icon on the right of the text input box where the
   error occured, as well as giving you an error dialog. You can
   change the ranges of the dependent and independent variables
   in the bottom part of the dialog.

   Pressing the Plot button produces the following graph.

   Figure 4-2. Plot Window

   [line_plot_graph.png]

   From here you can print out the plot, create encapsulated
   postscript or a PNG version of the plot or change the zoom. If
   the dependent axis was not set correctly you can have Genius
   fit it by finding out the extrema of the graphed functions.

   For plotting using the command line see the documentation of
   the LinePlot function.
     _________________________________________________________

4.2. Parametric Plots

   In the create plot window, you can also choose the Parametric
   notebook tab to create two dimensional parametric plots. This
   way you can plot a single parametric function. You can either
   specify the points as x and y, or giving a single complex
   number.

   Figure 4-3. Parametric Plots

   [parametric.png]

   Here is an example of a parametric plot. Similar operations
   can be done on such graphs as can be done on the other line
   plots.

   Figure 4-4. 

   [parametric_graph.png]

   For plotting using the command line see the documentation of
   the LinePlotParametric or LinePlotCParametric function.
     _________________________________________________________

4.3. Surface Plots

   Genius can also plot surfaces. Select the "Surface plot" tab
   in the main notebook of the Create Plot window. Here you can
   specify a single expression which should use either x and y as
   real independent variables or z as a complex variable (where x
   is the real part of z and y is the imaginary part). For
   example to plot the modulus of the cosine function for complex
   parameters, you could enter |cos(z)|. This would be equivalent
   to |cos(x+1i*y)|.

   Figure 4-5. Surface plot

   [surface_graph.png]

   For plotting using the command line see the documentation of
   the SurfacePlot function.
     _________________________________________________________

Chapter 5. GEL Basics

   GEL stands for Genius Extension Language. Alternatively it
   also stands for George's Ego Leverage. It is the language you
   use to write programs in Genius. A program in GEL is simply an
   expression that evaluates to a number.
     _________________________________________________________

5.1. Values

   Values in GEL can be numbers, Booleans or strings. Values can
   be used in calculations, assigned to variables and returned
   from functions, among other uses.
     _________________________________________________________

5.1.1. Numbers

   Integers are the first type of number in GEL. Integers are
   written in the normal way.
1234

   Hexidecimal and octal numbers can be written using C notation.
   For example:
0x123ABC
01234

   Or you can type numbers in an arbitrary base using
   <base>\<number>. Digits higher than 10 use letters in a
   similar way to hexidecimal. For example, a number in base 23
   could be written:
23\1234ABCD

   The second type of GEL number is rationals. Rationals are
   simply achieved by dividing two integers. So one could write:
3/4

   to get three quarters. Rationals also accept mixed fraction
   notation. So in order to get one and three tenths you could
   write:
1 3/10

   The next type if number is floating point. These are entered
   in a similar fashion to C notation. You can use E, e or @ as
   the exponent delimiter. Note that using the exponent delimiter
   gives a float even if there is no decimal point in the number.
   Examples:
1.315
7.887e77
7.887e-77
.3
0.3
77e5

   The final type of number in gel is the complex numbers. You
   can enter a complex number as a sum of real and imaginary
   parts. The imaginary part ends with an i. Here are examples of
   entering complex numbers:
1+2i
8.01i
77*e^(1.3i)

   Important

   When entering imaginary numbers, a number must be in front of
   the i. If you use i by itself, Genius will interpret this as
   referring to the variable i. If you need to refer to i by
   itself, use 1i instead.

   In order to use mixed fraction notation with imaginary numbers
   you must have the mixed fraction in parentheses. (i.e., (1
   2/5)i)
     _________________________________________________________

5.1.2. Booleans

   Genius also supports native Boolean values. The two Boolean
   constants are defined as true and false; these identifiers can
   be used like any other variable. You can also use the
   identifiers True, TRUE, False and FALSE as aliases for the
   above.

   At any place where a Boolean expression is expected, you can
   use a Boolean value or any expression that produces either a
   number or a Boolean. If Genius needs to evaluate a number as a
   Boolean it will interpret 0 as false and any other number as
   true.

   In addition, you can do arithmetic with Boolean values. For
   example:
( (1 + true) - false ) * true

   is the same as:
( (true or true) or not false ) and true

   Only addition, subtraction and multiplication are supported.
   If you mix numbers with Booleans in an expression then the
   numbers are converted to Booleans as described above. This
   means that, for example:
1 == true

   always evaluates to true since 1 will be converted to true
   before being compared to true.
     _________________________________________________________

5.1.3. Strings

   Like numbers and Booleans, strings in GEL can be stored as
   values inside variables and passed to functions. You can also
   concatenate a string with another value using the plus
   operator. For example:
a=2+3;"The result is: "+a

   will create the string:
The result is: 5

   You can also use C-like escape sequences such as \n,\t,\b,\a
   and \r. To get a \ or " into the string you can quote it with
   a \. For example:
"Slash: \\ Quotes: \" Tabs: \t1\t2\t3"

   will make a string:
Slash: \ Quotes: " Tabs:        1       2       3

   In addition, you can use the library function string to
   convert anything to a string. For example:
string(22)

   will return
"22"

   Strings can also be compared with ==, != and <=> operators
     _________________________________________________________

5.1.4. Null

   Null is a special value. No operations can be performed on it,
   and nothing is printed when it is returned. Therefore, Null is
   useful when you do not want output from an expression. Null
   can be obtained as an expression when you type . or nothing.

   Example:
x=5;.
x=5;
     _________________________________________________________

5.2. Using Variables

   Syntax:
VariableName

   Example:
genius> e
= 2.71828182846

   To evaluate a variable by itself, just enter the name of the
   variable. This will return the value of the variable. You can
   use a variable anywhere you would normally use a number or
   string. In addition, variables are necessary when defining
   functions that take arguments (see Section 5.3.1).

   Tip Using Tab completion


   You can use Tab completion to get Genius to complete variable
   names for you. Try typing the first few letters of the name
   and pressing Tab.

   Important Variable names are case sensitive


   The names of variables are case sensitive. That means that
   variables named hello, HELLO and Hello are all different
   variables.
     _________________________________________________________

5.2.1. Setting Variables

   Syntax:
<identifier> = <value>
<identifier> := <value>

   Example:
x = 3
x := 3

   To assign to a variable, use the = or := operators. These
   operators set the value of the variable and return the number
   you set, so you can do things like
a = b = 5

   The = and := operators can both be used to set variables. The
   difference between them is that the := operator always acts as
   an assignment operator, whereas the = operator may be
   interpreted as testing for equality when used in a context
   where a Boolean expression is expected.
     _________________________________________________________

5.2.2. Global variables

   Sometimes you'd like to set a global variable from inside a
   function. For this, use the set function. Passing a string or
   a quoted identifier to this function sets the variable
   globally. For example, to set a to the value 3 you could call:
set(`a,3)

   or:
set("a",3)

   Like most programming languages, Genius has two different
   types of variables: local (a variable set inside a function
   will not exist outside the function) and global (doesn't
   matter where you set them).
     _________________________________________________________

5.2.3. Built-in variables

   GEL has a number of built-in `variables', such as e. These are
   widely used constants with a preset value, and they cannot be
   assigned new values. There are a number of other built-in
   variables, such as pi and GoldenRatio. See Section 10.4 for a
   full list.
     _________________________________________________________

5.2.4. Previous result variable

   The Ans and ans variables can be used to get the result of the
   last expression. For example, if you had performed some
   calculation, to add 389 to the result you could do:
Ans+389
     _________________________________________________________

5.3. Using Functions

   Syntax:
FunctionName([argument1, argument2, ...])

   Example:
Factorial(5)
cos(2*pi)

   To evaluate a function, enter the name of the function,
   followed by the arguments (if any) to the function in
   parentheses. This will return the result of applying the
   function to its arguments. The number of arguments to the
   function is, of course, different for each function.

   There are many built-in functions, such as sin, cos and tan.
   You can use the help built-in function to get a list of
   available functions, or see Chapter 10 for a full listing.

   Tip Using Tab completion


   You can use Tab completion to get Genius to complete function
   names for you. Try typing the first few letters of the name
   and pressing Tab.

   Important Function names are case sensitive


   The names of functions are case sensitive. That means that
   functions named dosomething, DOSOMETHING and DoSomething are
   all different functions.
     _________________________________________________________

5.3.1. Defining functions

   Syntax:
function <identifier>(<comma separated arguments>) = <function body>
<identifier> = (`() = <function body>)

   The ` is the backquote character, and signifies an anonymous
   function. By setting it to a variable name you effectively
   define a function.

   A function takes zero or more comma separated arguments, and
   returns the result of the function body. Defining your own
   functions is primarily a matter of convenience; one possible
   use is to have sets of functions defined in GEL files which
   Genius can load in order to make available.

   Example:
function addup(a,b,c) = a+b+c

   then addup(1,4,9) yields 14
     _________________________________________________________

5.3.2. Variable argument lists

   If you include ... after the last argument name in the
   function declaration, then Genius will allow any number of
   arguments to be passed in place of that argument. If no
   arguments were passed then that argument will be set to null.
   Otherwise, it will be a horizontal vector containing all the
   arguments. For example:
function f(a,b...) = b

   Then f(1,2,3) yields [2,3], while f(1) yields null.
     _________________________________________________________

5.3.3. Passing functions to functions

   In Genius, it is possible to pass a function as an argument to
   another function. This can be done using either `function
   nodes' or anonymous functions.

   If you do not enter the parentheses after a function name,
   instead of being evaluated, the function will instead be
   returned as a `function node'. The function node can then be
   passed to another function.

   Example:
function f(a,b) = a(b)+1;
function b(x) = x*x;
f(b,2)

   If you want to pass a function that doesn't exist yet, you can
   use an anonymous function (see Section 5.3.1).

   Syntax:
function(<comma separated arguments>) = <function body>
`(<comma separated arguments>) = <function body>

   Example:
function f(a,b) = a(b)+1;
f(`(x) = x*x,2)
     _________________________________________________________

5.3.4. Operations on functions

   Some functions allow arithmetic operations, and some single
   argument functions such as exp or ln, to operate on the
   function. For example,
exp(sin*cos+4)

   will return a function that does
exp(sin(x)*cos(x)+4)

   This can be useful when quickly defining functions. For
   example to create a function to perform the above operation,
   you can just type:
f = exp(sin*cos+4)

   This can also be used in plotting. For example, to plot sin
   squared you can enter:
LinePlot(sin^2)

   Warning

   Not all functions can be used in this way. In addition, when
   you use a binary operation the functions must take the same
   arguments.
     _________________________________________________________

5.4. Absolute value / Modulus

   You can make an absolute value of something by putting the |'s
   around it.
|a-b|

   In case the expression is a complex number the result will be
   the modulus (distance from the origin). So for example:
|3 * e^(1i*pi)|

   returns 3.
     _________________________________________________________

5.5. Separator

   In GEL if you want to type more than one command you have to
   use the ; operator, which is a way to separate expressions,
   such a combined expression will return whatever is the result
   of the last one, so
3 ; 5

   yields 5.

   This will require some parenthesizing to make it unambiguous
   sometimes, especially if the ; is not the top most primitive.
   This slightly differs from other programming languages where
   the ; is a terminator of statements, whereas in GEL it's
   actually a binary operator. If you are familiar with pascal
   this should be second nature. However genius can let you
   pretend it's a terminator somewhat, if a ";" is found at the
   end of a parenthesis or a block, genius will itself append a
   null node to it as if you would have written ";". This is
   usefull in case you don't want to return a value from say a
   loop, or if you handle the return differently. Note that it
   will slow down the code if it's executed too often as there is
   one more operator involved.
     _________________________________________________________

5.6. Modular evaluation

   Sometimes when working with large numbers, it might be faster
   if results are modded after each calculation. To use it you
   just add "mod <integer>" after the expression.

   Example:
2^(5!) * 3^(6!) mod 5

   You can calculate the inverses of numbers mod some integer by
   just using rational numbers (of course the inverse has to
   exist).

   Examples:
10^-1 mod 101
1/10 mod 101

   You can also do modular evaluation with matrices including
   taking inverses, powers and dividing.

   Example:
A = [1,2;3,4]
B = A^-1 mod 5
A*B mod 5

   This should yield the identity matrix as B will be the inverse
   of A mod 5.

   Some functions such as sqrt or log work in a different way
   when in modulo mode. These will then work like their discrete
   versions working within the ring of integers you selected. For
   example:
genius> sqrt(4) mod 7
=
[2      5]
genius> 2*2 mod 7
= 4

   sqrt will actually return all the possible square roots.
     _________________________________________________________

5.7. List of GEL operators

   As everything in gel is really just an expression, it is
   really just all connected together with operators. Here is a
   list of the operators in GEL.

a;b

          The separator, just evaluates both a and b, but returns
          only the result of b.

a=b

          The assignment operator. This assigns b to a (a must be
          a valid lvalue) (note however that this operator may be
          translated to == if used in a place where boolean
          expression is expected)

a:=b

          The assignment operator. Assigns b to a (a must be a
          valid lvalue). This is different from = because it
          never gets translated to a ==.

|a|

          Absolute value or modulus (if a is a complex number).

          See Mathworld for more information.

a^b

          Exponentiation, raises a to the bth power.

a.^b

          Element by element exponentiation. Raise each element
          of a matrix a to the bth power. Or if b is a matrix of
          the same size as a, then do the operation element by
          element. If a is a number and b is a matrix then it
          creates matrix of the same size as b with a raised to
          all the different powers in b.

a+b

          Addition. Adds two numbers, matrices, functions or
          strings. If you add a string to anything the result
          will just be a string.

a-b

          Subtraction. Subtract two numbers, matrices or
          functions.

a*b

          Multiplication. This is the normal matrix
          multiplication.

a.*b

          Element by element multiplication if a and b are
          matrices.

a/b

          Division.

a./b

          Element by element division.

a\b

          Back division. That is this is the same as b/a.

a.\b

          Element by element back division.

a%b

          The mod operator. This does not turn on the modular
          mode, but just returns the remainder of a/b.

a.%b

          Element by element the mod operator. Returns the
          remaineder after element by element a./b.

a mod b

          Modular evaluation operator. The expression a is
          evaluated modulo b. See Section 5.6. Some functions and
          operators behave differently modulo an integer.

a!

          Factorial operator. This is like 1*...*(n-2)*(n-1)*n.

a!!

          Double factorial operator. This is like
          1*...*(n-4)*(n-2)*n.

a==b

          Equality operator (returns true or false).

a!=b

          Inequality operator, returns true if a does not equal b
          else returns false.

a<>b

          Alternative inequality operator, returns true if a does
          not equal b else returns false.

a<=b

          Less than or equal operator, returns true if a is less
          than or equal to b else returns false.

a>=b

          Greater than or equal operator, returns true if a is
          greater than or equal to b else returns false.

a<=>b

          Comparison operator. If a is equal to b it returns 0,
          if a is less than b it returns -1 and if a is greater
          than b it returns 1.

a and b

          Logical and.

a or b

          Logical or.

a xor b

          Logical xor.

not a

          Logical not.

-a

          Negation operator.

&a

          Variable referencing (to pass a reference to
          something). See Section 6.6.

*a

          Variable dereferencing (to access a referenced
          varible). See Section 6.6.

a'

          Matrix conjugate transpose.

a.'

          Matrix transpose, does not conjugate the entries.

a@(b,c)

          Get element of a matrix in row b and column c. If b, c
          are vectors, then this gets the corresponding rows
          columns or submatrices.

a@(b,)

          Get row of a matrix (or rows if b is a vector).

a@(b,:)

          Same as above.

a@(,c)

          Get column of a matrix (or columns if c is a vector).

a@(:,c)

          Same as above.

a@(b)

          Get an element from a matrix treating it as a vector.
          This will traverse the matrix row-wise.

a:b

          Build a vector from a to b (or specify a row, column
          region for the @ operator). For example to get rows 2
          to 4 of mamtrix A we could do

A@(2:4,)


          as 2:4 will return a vector [2,3,4].

a:b:c

          Build a vector from a to c with b as a step. That is
          for example

genius> 1:2:9
=
`[1     3       5       7       9]

(a)i

          Make a imaginary number (multiply a by the imaginary).
          Note that normally the number i is written as 1i. So
          the above is equal to

(a)*1i


`a

          Quote an identifier so that it doesn't get evaluated.
          Or quote a matrix so that it doesn't get expanded.

   Note

   The @() operator makes the : operator most useful. With this
   you can specify regions of a matrix. So that a@(2:4,6) is the
   rows 2,3,4 of the column 6. Or a@(,1:2) will get you the first
   two columns of a matrix. You can also assign to the @()
   operator, as long as the right value is a matrix that matches
   the region in size, or if it is any other type of value.

   Note

   The comparison operators (except for the <=> operator which
   behaves normally), are not strictly binary operators, they can
   in fact be grouped in the normal mathematical way, e.g.:
   (1<x<=y<5) is a legal boolean expression and means just what
   it should, that is (1<x and x=<y and y<5)

   Note

   The unitary minus operates in a different fashion depending on
   where it appears. If it appears before a number it binds very
   closely, if it appears in front of an expression it binds less
   than the power and factorial operators. So for example -1^k is
   really (-1)^k, but -foo(1)^k is really -(foo(1)^k). So be
   careful how you use it and if in doubt, add parentheses.
     _________________________________________________________

Chapter 6. Programming with GEL

6.1. Conditionals

   Syntax:
if <expression1> then <expression2> [else <expression3>]

   If else is omitted, then if the expression1 yields 0, NULL is
   returned.

   Examples:
if(a==5)then(a=a-1)
if b<a then b=a
if c>0 then c=c-1 else c=0
a = ( if b>0 then b else 1 )

   Note that = will be translated to == if used inside the
   expression for if, so
if a=5 then a=a-1

   will be interpreted as:
if a==5 then a:=a-1
     _________________________________________________________

6.2. Loops

6.2.1. While loops

   Syntax:
while <expression1> do <expression2>
until <expression1> do <expression2>
do <expression2> while <expression1>
do <expression2> until <expression1>

   These are similiar to other languages, however they return the
   result of the last iteration or NULL if no iteration was done.
   In the boolean expression, = is translated into == just as for
   the if statement.
     _________________________________________________________

6.2.2. For loops

   Syntax:
for <identifier> = <from> to <to> do <body>
for <identifier> = <from> to <to> by <increment> do <body>

   Loop with identifier being set to all values from <from> to
   <to>, optionally using an increment other than 1. These are
   faster, nicer and more compact than the normal loops such as
   above, but less flexible. The identifier must be an identifier
   and can't be a dereference. The value of identifier is the
   last value of identifier, or <from> if body was never
   evaluated. The variable is guaranteed to be initialized after
   a loop, so you can safely use it. Also the <from>, <to> and
   <increment> must be non complex values. The <to> is not
   guaranteed to be hit, but will never be overshot, for example
   the following prints out odd numbers from 1 to 19:
for i = 1 to 20 by 2 do print(i)
     _________________________________________________________

6.2.3. Foreach loops

   Syntax:
  for <identifier> in <matrix> do <body>

   For each element, going row by row from left to right do the
   body. To print numbers 1,2,3 and 4 in this order you could do:
for n in [1,2:3,4] do print(n)

   If you wish to run through the rows and columns of a matrix,
   you can use the RowsOf and ColumnsOf functions which return a
   vector of the rows or columns of the matrix. So,
for n in RowsOf ([1,2:3,4]) do print(n)

   will print out [1,2] and then [3,4].
     _________________________________________________________

6.2.4. Break and continue

   You can also use the break and continue commands in loops. The
   continue continue command will restart the current loop at its
   next iteration, while the break command exits the current
   loop.
while(<expression1>) do (
  if(<expression2>) break
  else if(<expression3>) continue;
  <expression4>
)
     _________________________________________________________

6.3. Sums and products

   Syntax:
sum <identifier> = <from> to <to> do <body>
sum <identifier> = <from> to <to> by <increment> do <body>
sum <identifier> in <matrix> do <body>
prod <identifier> = <from> to <to> do <body>
prod <identifier> = <from> to <to> by <increment> do <body>
prod <identifier> in <matrix> do <body>

   If you substitute for with sum or prod, then you will get a
   sum or a product instead of a for loop. Instead of returning
   the last value, these will return the sum or the product of
   the values respectively.

   If no body is executed (for example sum i=1 to 0 do ...) then
   sum returns 0 and prod returns 1 as is the standard
   convention.
     _________________________________________________________

6.4. Comparison operators

   ==, >=, <=, !=, <>, <, > return true or false.

   != and <> are the same thing and mean "is not equal to".

   Normally = is translated to == if it happens to be somewhere
   where GEL is expecing a condition such as in the if condition.
   For example
if a=b then c
if a==b then c

   are the same thing in GEL. However you should really use == or
   := when you want to compare or assign respectively if you want
   your code to be easy to read and to avoid mistakes.

   All the comparison operators (except for the <=> operator
   which behaves normally), are not strictly binary operators,
   they can in fact be grouped in the normal mathematical way,
   e.g.: (1<x<=y<5) is a legal boolean expression and means just
   what it should, that is (1<x and x=<y and y<5)

   The <=> operator returns -1 if left side is smaller, 0 if both
   sides are equal, 1 if left side is larger.

   To build up logical expressions use the words not, and, or,
   xor.

   "or" and "and" are special beasts as they evaluate their
   arguemnts one by one, so the usual trick for conditional
   evaluation works here as well. (e.g., "1 or a=1" will not set
   a=1 since the first argument was true)
     _________________________________________________________

6.5. Returning

   Sometimes you don't want to return the last thing calculated.
   You may, for example, want to return from a middle of a
   function. In this case, you can use the return keyword. return
   takes one argument, which is the value to be returned.

   Example:
function f(x) = (
  y=1;
  while true do (
    if x>50 then return y;
    y=y+1;
    x=x+1
  )
)
     _________________________________________________________

6.6. References

   GEL contains references with a C like syntax. & references a
   variable and * dereferences a variable. Both can only be
   applied to an identifier, so **a is not legal in GEL.

   Example:
a=1;
b=&a;
*b=2;

   now 'a' contains 2.
function f(x) = x+1;
t=&f;
*t(3)

   gives us 4.
     _________________________________________________________

6.7. Lvalues

   An lvalue is the left hand side of an assignment. In other
   words, an lvalue is what you assign something to. Valid
   lvalues are:

   a
          Identifier. Here we would be setting the varable of
          name a.

   *a
          Dereference of an identifier. This will set whatever
          variable a points to.

   a@(<region>)
          A region of a matrix. Here the region is specified
          normally as with the regular @() operator, and can be a
          single entry, or an entire region of the matrix.

   Examples:
a:=4
*tmp := 89
a@(1,1) := 5
a@(4:8,3) := [1,2,3,4,5]'

   Note that both := and = can be used interchangably. That is
   except if the assignment appears in a condition. It is thus
   always safer to just use := when you mean assignment.
     _________________________________________________________

Chapter 7. Advanced Programming with GEL

7.1. Error handling

   If you detect an error in your function, you can bail out of
   it. For normal errors, such as wrong types of arguments, you
   can fail to compute the function by adding the empty statement
   bailout. If something went really wrong and you want to
   completely kill the current computation, you can use
   exception.

   Look at lib.gel for some examples.
     _________________________________________________________

7.2. GEL startup procedure

   First the program looks for the installed library file (the
   compiled version lib.cgel) in the installed directory, then it
   looks into the current directory, and then it tries to load an
   uncompiled file called ~/.geniusinit.

   If you ever change the the library its installed place, you'll
   have to first compile it with genius --compile loader.gel >
   lib.cgel
     _________________________________________________________

7.3. Loading programs

   Sometimes you have a larger program that you wrote into a file
   and want to read in that file. In these situations, you have
   two options. You can keep the functions you use most inside
   the ~/.geniusinit file. Or if you want to load up a file in a
   middle of a session (or from within another file), you can
   type load <list of filenames> at the prompt. This has to be
   done on the top level and not inside any function or whatnot,
   and it cannot be part of any expression. It also has a
   slightly different syntax than the rest of genius, more
   similiar to a shell. You can enter the file in quotes. If you
   use the '' quotes, you will get exactly the string that you
   typed, if you use the "" quotes, special characters will be
   unescaped as they are for strings. Example:
load program1.gel program2.gel
load "Weird File Name With SPACES.gel"

   There are also cd, pwd and ls commands built in. cd will take
   one argument, ls will take an argument which is like the glob
   in the unix shell (i.e., you can use wildcards). pwd takes no
   arguments. For example:
cd directory_with_gel_programs
ls *.gel
     _________________________________________________________

Chapter 8. Matrices in GEL

8.1. Matrix support

   To enter matrixes, you can use one of the following two
   syntaxes. You can either enter the matrix on one line,
   separating values by commas and rows by semicolons. Or you can
   enter each row on one line, separating values by commas or
   tabs. (Note that tabs are not usually easily possible on the
   console, only in files). You can also just combine the two
   methods. So to enter a 3x3 matrix of numbers 1-9 you could do
[1,2,3;4,5,6;7,8,9]

   or
[1, 2, 3
 4, 5, 6
 7, 8, 9]

   or (where the empty spaces are tabs)
[1 2 3
 4 5 6
 7 8 9]

   Do not use both ';' and return at once on the same line
   though. Also do not mix tabs and commas. It is just safest to
   use commas as separators.

   You can also use the matrix expansion functionality to enter
   matricies. For example you can do:
a = [ 1, 2, 3
      4, 5, 6
      7, 8, 9]
b = [ a,  10
      11, 12]

   and you should get
[1  2  3  10
 4  5  6  10
 7  8  9  10
 11 11 11 12]

   similiarly you can build matricies out of vectors and other
   stuff like that.

   Another thing is that non-specified spots are initialized to
   0, so
[1, 2, 3
 4, 5
 6]

   will end up being
[1 2 3
 4 5 0
 6 0 0]

   Note

   Be careful about using whitespace and returns for expressions
   inside the [ ] brackets, as they have a slightly different
   meaning and could mess you up.
     _________________________________________________________

8.2. Conjugate transpose and transpose operator

   You can conjugate transpose a matrix by using the ' operator.
   For example:
[1,2,3]*[4,5,6]'

   We transpose the second vector to make matrix multiplication
   possible.

   If you just want to transpose a matrix without conjugating it,
   you would use the .' operator. For example:
[1,2,3]*[4,5,6i].'
     _________________________________________________________

8.3. Linear Algebra

   Genius implements many useful linear algebra and matrix
   manipulation routines. See the Linear Algebra and Matrix
   Manipulation sections of the GEL function listing.
     _________________________________________________________

Chapter 9. Polynomials in GEL

   Currently Genius can handle polynomials of one variable
   written out as vectors, and do some basic operations with
   these. It is planned to expand this support further.
     _________________________________________________________

9.1. Using Polynomials

   Currently polynomials in one variable are just horizontal
   vectors with value only nodes. The power of the term is the
   position in the vector, with the first position being 0. So,
[1,2,3]

   translates to a polynomial of
1 + 2*x + 3*x^2

   You can add, subtract and multiply polynomials using the
   AddPoly, SubtractPoly, and MultiplyPoly functions
   respectively. You can print a polynomial using the
   PolyToString function. For example,
PolyToString([1,2,3],"y")

   gives
3*y^2 + 2*y + 1

   You can also get a function representation of the polynomial
   so that you can evaluate it. This is done by using
   PolyToFunction, which returns an anonymous function which you
   can assign to something.
f = PolyToFunction([0,1,1])
f(2)

   It is also possible to find roots of polynomials of degrees 1
   through 4 by using the function PolynomialRoots, which calls
   the appropriate formula function. Higher degree polynomials
   must be converted to functions and solved numerically using a
   function such as FindRootBisection, FindRootFalsePosition,
   FindRootMullersMethod, or FindRootSecant.

   Look at the function table for the rest of functions acting on
   polynomials.
     _________________________________________________________

Chapter 10. List of GEL functions

   To get help on a specific function from the console type:
help FunctionName
     _________________________________________________________

10.1. Commands

   help

help

help FunctionName

          Print help (or help on a function/command).

   load

load "file.gel"

          Load a file into the interpretor.

   cd

cd /directory/name

          Change working directory.

   pwd

pwd

          Change working directory.

   ls

ls

          List files in the current directory.

   plugin

plugin plugin_name

          Load a plugin.
     _________________________________________________________

10.2. Basic

   Compose

Compose (f,g)

          Compose two functions and return a function that is the
          composition of f and g.

   ComposePower

ComposePower (f,n,x)

          Compose a function with itself n times, passing x as
          argument, and returning x if n == 0. Examples:

genius> function f(x) = x^2 ;
genius> ComposePower (f,3,7)
= 5764801
genius> f(f(f(7)))
= 5764801

   GetCurrentModulo

GetCurrentModulo

          Get current modulo from the context outside the
          function

   Identity

Identity (x)

          Identity function, returns its argument

   IntegerFromBoolean

IntegerFromBoolean (bval)

          Make integer (0 for false or 1 for true) from a boolean
          value. bval can also be a number in which case a
          non-zero value will be interpreted as true and zero
          will be interpretted as false.

   IsBoolean

IsBoolean (arg)

          Check if argument is a boolean (and not a number)

   IsFunction

IsFunction (arg)

          Check if argument is a function

   IsFunctionOrIdentifier

IsFunctionOrIdentifier (arg)

          Check if argument is a function or identifier

   IsFunctionRef

IsFunctionRef (arg)

          Check if argument is a function reference

   IsMatrix

IsMatrix (arg)

          Check if argument is a matrix

   IsNull

IsNull (arg)

          Check if argument is a null

   IsString

IsString (arg)

          Check if argument is a text string

   IsValue

IsValue (arg)

          Check if argument is a number

   SetFunctionFlags

SetFunctionFlags (id,flags...)

          Set flags for a function, currently "PropagateMod" and
          "NoModuloArguments"

   SetHelp

SetHelp (id,category,desc)

          Set the category and help description line for a
          function

   SetHelpAlias

SetHelpAlias (id,alias)

          Sets up a help alias

   chdir

chdir (dir)

          Changes current directory

   display

display (str,expr)

          Display a string and an expression

   error

error (str)

          Prints a string to the error stream

   exit

exit

          Aliases: quit

          Exits the program

   false

false

          Aliases: False FALSE

          The false boolean value

   manual

manual

          Displays the user manual

   print

print (str)

          Prints an expression

   printn

printn (str)

          Prints an expression without a trailing newline

   protect

protect (id)

          Protect a variable from being modified

   set

set (id,val)

          Set a global variable. The id can be either a string or
          a quoted identifier as follows. For example:

set(`x,1)


          will set the global variable x to the value 1.

   string

string (s)

          Make a string. This will make a string out of any
          argument.

   true

true

          Aliases: True TRUE

          The true boolean value

   unprotect

unprotect (id)

          Unprotect a variable from being modified

   wait

wait (secs)

          Waits a specified number of seconds.

   warranty

warranty

          Gives the warranty information
     _________________________________________________________

10.3. Parameters

   ChopTolerance

ChopTolerance = number

          Tolerance of the Chop function

   ContinuousNumberOfTries

ContinuousNumberOfTries = number

          How many iterations to try to find the limit for
          continuity and limits

   ContinuousSFS

ContinuousSFS = number

          How many successive steps to be within tolerance for
          calculation of continuity

   ContinuousTolerance

ContinuousTolerance = number

          Tolerance for continuity of functions and for
          calculating the limit

   DerivativeNumberOfTries

DerivativeNumberOfTries = number

          How many iterations to try to find the limit for
          derivative

   DerivativeSFS

DerivativeSFS = number

          How many successive steps to be within tolerance for
          calculation of derivative

   DerivativeTolerance

DerivativeTolerance = number

          Tolerance for calculating the derivatives of functions

   ErrorFunctionTolerance

ErrorFunctionTolerance = number

          Tolerance of the ErrorFunction

   FloatPrecision

FloatPrecision = number

          Floating point precision

   FullExpressions

FullExpressions = boolean

          Print full expressions, even if more than a line

   GaussDistributionTolerance

GaussDistributionTolerance = number

          Tolerance of the GaussDistribution function

   IntegerOutputBase

IntegerOutputBase = number

          Integer output base

   IsPrimeMillerRabinReps

IsPrimeMillerRabinReps = number

          Number of extra Miller-Rabin tests to run on a number
          before declaring it a prime in IsPrime

   LinePlotWindow

LinePlotWindow = [x1,x2,y1,y2]

          Sets the limits for line plotting (See LinePlot).

   MaxDigits

MaxDigits = number

          Maximum digits to display

   MaxErrors

MaxErrors = number

          Maximum errors to display

   MixedFractions

MixedFractions = boolean

          If true, mixed fractions are printed

   NumericalIntegralFunction

NumericalIntegralFunction = function

          The function used for numerical integration in
          NumericalIntegral

   NumericalIntegralSteps

NumericalIntegralSteps = number

          Steps to perform in NumericalIntegral

   OutputStyle

OutputStyle = string

          Output style, this can be normal, latex, mathml or
          troff.

          This affects mostly how matrices and fractions are
          printed out and is useful for pasting into documents.
          For example you can set this to the latex by:

OutputStyle = "latex"

   ResultsAsFloats

ResultsAsFloats = boolean

          Convert all results to floats before printing

   ScientificNotation

ScientificNotation = boolean

          Use scientific notation

   SumProductNumberOfTries

SumProductNumberOfTries = number

          How many iterations to try for InfiniteSum and
          InfiniteProduct

   SumProductSFS

SumProductSFS = number

          How many successive steps to be within tolerance for
          InfiniteSum and InfiniteProduct

   SumProductTolerance

SumProductTolerance = number

          Tolerance for InfiniteSum and InfiniteProduct

   SurfacePlotWindow

SurfacePlotWindow = [x1,x2,y1,y2,z1,z2]

          Sets the limits for surface plotting (See SurfacePlot).
     _________________________________________________________

10.4. Constants

   CatalanConstant

CatalanConstant

          Catalan's Constant, approximately 0.915... It is
          defined to be the series where terms are
          (-1^k)/((2*k+1)^2), where k ranges from 0 to infinity.

          See Mathworld for more information.

   EulerConstant

EulerConstant

          Aliases: gamma

          Euler's Constant gamma. Sometimes called the
          Euler-Mascheroni constant.

          See Planetmath or Mathworld for more information.

   GoldenRatio

GoldenRatio

          The Golden Ratio

          See Planetmath or Mathworld for more information.

   Gravity

Gravity

          Free fall acceleration

   e

e

          The base of the natural logarithm. e^x is the
          exponential function exp. This is the number
          approximately 2.71828182846...

          See Planetmath or Mathworld for more information.

   pi

pi

          The number pi, that is the ratio of a circle's
          circumference to it's diameter. This is approximately
          3.14159265359...

          See Planetmath or Mathworld for more information.
     _________________________________________________________

10.5. Numeric

   AbsoluteValue

AbsoluteValue (x)

          Aliases: abs

          Absolute value of a number and if x is a complex value
          the modulus of x.

          See Planetmath (absolute value), Planetmath (modulus),
          Mathworld (absolute value) or Mathworld (complex
          modulus) for more information.

   Chop

Chop (x)

          Replace very small number with zero

   ComplexConjugate

ComplexConjugate (M)

          Aliases: conj Conj

          Calculates the conjugate

   Denominator

Denominator (x)

          Get the denominator of a rational number

   FractionalPart

FractionalPart (x)

          Return the fractional part of a number

   Im

Im (z)

          Aliases: ImaginaryPart

          Get the imaginary part of a complex number

   IntegerQuotient

IntegerQuotient (m,n)

          Division w/o remainder

   IsComplex

IsComplex (num)

          Check if argument is a complex (non-real) number

   IsComplexRational

IsComplexRational (num)

          Check if argument is a possibly complex rational number

   IsFloat

IsFloat (num)

          Check if argument is a floating point number
          (non-complex)

   IsGaussInteger

IsGaussInteger (num)

          Aliases: IsComplexInteger

          Check if argument is a possibly complex integer

   IsGaussianInteger

IsGaussianInteger (z)

          Check if argument is a gaussian integer

   IsInteger

IsInteger (num)

          Check if argument is an integer (non-complex)

   IsNonNegativeInteger

IsNonNegativeInteger (num)

          Check if argument is a non-negative real integer.

   IsPositiveInteger

IsPositiveInteger (num)

          Aliases: IsNaturalNumber

          Check if argument is a positive real integer.

   IsRational

IsRational (num)

          Check if argument is a rational number (non-complex)

   IsReal

IsReal (num)

          Check if argument is a real number

   Numerator

Numerator (x)

          Get the numerator of a rational number

   Re

Re (z)

          Aliases: RealPart

          Get the real part of a complex number

   Sign

Sign (x)

          Aliases: sign

          Return the sign of a number. That is returns -1 if
          value is negative, 0 if value is zero and 1 if value is
          positive. If x is a complex value then Sign returns the
          direction or 0.

   ceil

ceil (x)

          Aliases: Ceiling

          Get the lowest integer more than or equal to n

   exp

exp (x)

          The exponential function. This is the function e^x
          where e is the base of the natural logarithm.

          See Planetmath or Mathworld for more information.

   float

float (x)

          Make number a floating point value. That is returns the
          floating point representation of the number x.

   floor

floor (x)

          Aliases: Floor

          Get the highest integer less than or equal to n

   ln

ln (x)

          The natural logarithm, the logarithm to base e.

   log

log (x,b...)

          Logarithm of x base b (calls DiscreteLog if in modulo
          mode), if base is not given, e is used.

   log10

log10 (x)

          Logarithm of x base 10

   log2

log2 (x)

          Aliases: lg

          Logarithm of x base 2

   max

max (a,args...)

          Aliases: Max Maximum

          Returns the maximum of arguments or matrix

   min

min (a,args...)

          Aliases: Min Minimum

          Returns the minimum of arguments or matrix

   rand

rand (size...)

          Generate random float in the range [0,1). If size is
          given then a matrix (if two numbers are specified) or
          vector (if one number is specified) of the given size
          returned.

   randint

randint (max,size...)

          Generate random integer in the range [0,max). If size
          is given then a matrix (if two numbers are specified)
          or vector (if one number is specified) of the given
          size returned. For example

genius> randint(4)
= 3
genius> randint(4,2)
=
[0      1]
genius> randint(4,2,3)
=
[2      2       1
 0      0       3]

   round

round (x)

          Aliases: Round

          Round a number

   sqrt

sqrt (x)

          Aliases: SquareRoot

          The square root. When operating modulo some integer
          will return either a null or a vector of the square
          roots. Examples:

genius> sqrt(2)
= 1.41421356237
genius> sqrt(-1)
= 1i
genius> sqrt(4) mod 7
=
[2      5]
genius> 2*2 mod 7
= 4

          See Planetmath for more information.

   trunc

trunc (x)

          Aliases: Truncate IntegerPart

          Truncate number to an integer (return the integer part)
     _________________________________________________________

10.6. Trigonometry

   acos

acos (x)

          Aliases: arccos

          The arccos (inverse cos) function

   acosh

acosh (x)

          Aliases: arccosh

          The arccosh (inverse cosh) function

   acot

acot (x)

          Aliases: arccot

          The arccot (inverse cot) function

   acoth

acoth (x)

          Aliases: arccoth

          The arccoth (inverse coth) function

   acsc

acsc (x)

          Aliases: arccsc

          The inverse cosecant function

   acsch

acsch (x)

          Aliases: arccsch

          The inverse hyperbolic cosecant function

   asec

asec (x)

          Aliases: arcsec

          The inverse secant function

   asech

asech (x)

          Aliases: arcsech

          The inverse hyperbolic secant function

   asin

asin (x)

          Aliases: arcsin

          The arcsin (inverse sin) function

   asinh

asinh (x)

          Aliases: arcsinh

          The arcsinh (inverse sinh) function

   atan

atan (x)

          Aliases: arctan

          Calculates the arctan (inverse tan) function.

          See Mathworld for more information.

   atanh

atanh (x)

          Aliases: arctanh

          The arctanh (inverse tanh) function

   atan2

atan2 (y, x)

          Aliases: arctan2

          Calculates the arctan2 function. If x>0 then it returns
          atan(y/x). If x<0 then it returns sign(y) * (pi -
          atan(|y/x|). When x=0 it returns sign(y) * pi/2.
          atan2(0,0) returns 0 rather then failing.

          See Mathworld for more information.

   cos

cos (x)

          Calculates the cosine function.

          See Planetmath for more information.

   cosh

cosh (x)

          Calculates the hyperbolic cosine function

          See Planetmath for more information.

   cot

cot (x)

          The cotangent function

          See Planetmath for more information.

   coth

coth (x)

          The hyperbolic cotangent function

          See Planetmath for more information.

   csc

csc (x)

          The cosecant function

          See Planetmath for more information.

   csch

csch (x)

          The hyperbolic cosecant function

          See Planetmath for more information.

   sec

sec (x)

          The secant function

          See Planetmath for more information.

   sech

sech (x)

          The hyperbolic secant function

          See Planetmath for more information.

   sin

sin (x)

          Calculates the sine function.

          See Planetmath for more information.

   sinh

sinh (x)

          Calculates the hyperbolic sine function

          See Planetmath for more information.

   tan

tan (x)

          Calculates the tan function

          See Planetmath for more information.

   tanh

tanh (x)

          The hyperbolic tangent function

          See Planetmath for more information.
     _________________________________________________________

10.7. Number Theory

   AreRelativelyPrime

AreRelativelyPrime (a,b)

          Are the real integers a and b relatively prime? Returns
          true or false.

          See Planetmath or Mathworld for more information.

   BernoulliNumber

BernoulliNumber (n)

          Return the nth Bernoulli number

   ChineseRemainder

ChineseRemainder (a,m)

          Aliases: CRT

          Find the x that solves the system given by the vector a
          and modulo the elements of m, using the Chinese
          Remainder Theorem.

          See Planetmath or Mathworld for more information.

   CombineFactorizations

CombineFactorizations (a,b)

          Given two factorizations, give the factorization of the
          product.

          See Factorize.

   ConvertFromBase

ConvertFromBase (v,b)

          Convert a vector of values indicating powers of b to a
          number

   ConvertToBase

ConvertToBase (n,b)

          Convert a number to a vector of powers for elements in
          base b

   DiscreteLog

DiscreteLog (n,b,q)

          Find discrete log of n base b in F_q where q is a prime
          using the Silver-Pohlig-Hellman algoritm

          See Planetmath or Mathworld for more information.

   Divides

Divides (m,n)

          Checks divisibility (if m divides n)

   EulerPhi

EulerPhi (n)

          Compute the Euler phi function for n, that is the
          number of integers between 1 and n relatively prime to
          n.

          See Planetmath or Mathworld for more information.

   ExactDivision

ExactDivision (n,d)

          Return n/d but only if d divides n. If d does not
          divide n then this function returns garbage. This is a
          lot faster for very large numbers than the operation
          n/d, but of course only useful if you know that the
          division is exact.

   Factorize

Factorize (n)

          Return factorization of a number as a matrix. The first
          row is the primes in the factorization (including 1)
          and the second row are the powers. So for example:

genius> Factorize(11*11*13)
=
[1      11      13
 1      2       1]

   Factors

Factors (n)

          Return all factors of n in a vector. This includes all
          the non-prime factors as well. It includes 1 and the
          number itself. So for example to print all the perfect
          numbers (those that are sums of their factors) up to
          the number 1000 you could do (this is of course very
          inefficent)

for n=1 to 1000 do (
    if MatrixSum (Factors(n)) == 2*n then
        print(n)
)

   FermatFactorization

FermatFactorization (n,tries)

          Attempt fermat factorization of n into (t-s)*(t+s),
          returns t and s as a vector if possible, null
          otherwise. tries specifies the number of tries before
          giving up.

          This is a fairly good factorization if your number is
          the product of two factors that are very close to each
          other.

   FindPrimitiveElementMod

FindPrimitiveElementMod (q)

          Find the first primitive element in F_q (q must be a
          prime)

   FindRandomPrimitiveElementMod

FindRandomPrimitiveElementMod (q)

          Find a random primitive element in F_q (q must be a
          prime)

   IndexCalculus

IndexCalculus (n,b,q,S)

          Compute discrete log base b of n in F_q (q a prime)
          using the factor base S. S should be a column of primes
          possibly with second column precalculated by
          IndexCalculusPrecalculation.

   IndexCalculusPrecalculation

IndexCalculusPrecalculation (b,q,S)

          Run the precalculation step of IndexCalculus for
          logarithms base b in F_q (q a prime) for the factor
          base S (where S is a column vector of primes). The logs
          will be precalculated and returned in the second
          column.

   IsEven

IsEven (n)

          Tests if an integer is even.

   IsNthPower

IsNthPower (m,n)

          Tests if a rational number m is a perfect nth power.
          See also IsPerfectPower and IsPerfectSquare.

   IsOdd

IsOdd (n)

          Tests if an integer is odd

   IsPerfectPower

IsPerfectPower (n)

          Check a number for being any perfect power (a^b)

   IsPerfectSquare

IsPerfectSquare (n)

          Check a number for being a perfect square. The number
          must be a real integer. Negative integers are of course
          never perfect squares.

   IsPrime

IsPrime (n)

          Tests primality of integers, for numbers less than
          25*10^9 the answer is deterministic (if Riemann
          hypothesis is true). For numbers larger, the
          probability of a false positive depends on
          IsPrimeMillerRabinReps. That is the probability of
          false positive is 1/4 to the power
          IsPrimeMillerRabinReps. The default value of 22 yields
          a probability of about 5.7e-14.

          If false is returned, you can be sure that the number
          is a composite. If you want to be absolutely sure that
          you have a prime you can use MillerRabinTestSure but it
          may take a lot longer.

          See Planetmath or Mathworld for more information.

   IsPrimitiveMod

IsPrimitiveMod (g,q)

          Check if g is primitive in F_q, where q is a prime. If
          q is not prime results are bogus.

   IsPrimitiveModWithPrimeFactors

IsPrimitiveModWithPrimeFactors (g,q,f)

          Check if g is primitive in F_q, where q is a prime and
          f is a vector of prime factors of q-1. If q is not
          prime results are bogus.

   IsPseudoprime

IsPseudoprime (n,b)

          If n is a pseudoprime base b but not a prime, that is
          if b^(n-1) == 1 mod n

   IsStrongPseudoprime

IsStrongPseudoprime (n,b)

          Test if n is a strong pseudoprime to base b but not a
          prime

   Jacobi

Jacobi (a,b)

          Aliases: JacobiSymbol

          Calculate the Jacobi symbol (a/b) (b should be odd)

   JacobiKronecker

JacobiKronecker (a,b)

          Aliases: JacobiKroneckerSymbol

          Calculate the Jacobi symbol (a/b) with the Kronecker
          extension (a/2)=(2/a) when a odd, or (a/2)=0 when a
          even

   LeastAbsoluteResidue

LeastAbsoluteResidue (a,n)

          Return the residue of a mod n with the least absolute
          value (in the interval -n/2 to n/2)

   Legendre

Legendre (a,p)

          Aliases: LegendreSymbol

          Calculate the Legendre symbol (a/p).

          See Planetmath or Mathworld for more information.

   LucasLehmer

LucasLehmer (p)

          Test if Mp is a Mersenne prime using the Lucas-Lehmer
          test

          See Planetmath or Mathworld for more information.

   LucasNumber

LucasNumber (n)

          Returns the n'th Lucas number

          See Planetmath or Mathworld for more information.

   MaximalPrimePowerFactors

MaximalPrimePowerFactors (n)

          Return all maximal prime power factors of a number

   MillerRabinTest

MillerRabinTest (n,reps)

          Use the Miller-Rabin primality test on n, reps number
          of times. The probability of false positive is
          (1/4)^reps. It is probably usually better to use
          IsPrime since that is faster and better on smaller
          integers.

          See Planetmath or Mathworld for more information.

   MillerRabinTestSure

MillerRabinTestSure (n)

          Use the Miller-Rabin primality test on n with enough
          bases that assuming the Generalized Reimann Hypothesis
          the result is deterministic.

          See Planetmath or Mathworld for more information.

   ModInvert

ModInvert (n,m)

          Returns inverse of n mod m

          See Mathworld for more information.

   MoebiusMu

MoebiusMu (n)

          Return the Moebius mu function evaluated in n. That is,
          it returns 0 if n is not a product of distinct primes
          and (-1)^k if it is a product of k distinct primes.

          See Planetmath or Mathworld for more information.

   NextPrime

NextPrime (n)

          Returns the least prime greater than n. Negatives of
          primes are considered prime and so to get the previous
          prime you can use -NextPrime(-n).

          This uses the GMP's mpz_nextprime which in turn uses
          the probabilistic Miller-Rabin test (See also
          MillerRabinTest). The probability of false positive is
          not tunable, but is low enough for all practical
          purposes.

          See Planetmath or Mathworld for more information.

   PadicValuation

PadicValuation (n,p)

          Returns the padic valuation (number of trailing zeros
          in base p).

          See Planetmath for more information.

   PowerMod

PowerMod (a,b,m)

          Compute a^b mod m. The b's power of a modulo m.

   Prime

Prime (n)

          Aliases: prime

          Return the n'th prime (up to a limit)

          See Planetmath or Mathworld for more information.

   PrimeFactors

PrimeFactors (n)

          Return all prime factors of a number as a vector.

          See Mathworld for more information.

   PseudoprimeTest

PseudoprimeTest (n,b)

          Pseudoprime test, returns true if and only if b^(n-1)
          == 1 mod n

          See Planetmath or Mathworld for more information.

   RemoveFactor

RemoveFactor (n,m)

          Removes all instances of the factor m from the number
          n. That is divides by the largest power of m, that
          divides n.

          See Planetmath or Mathworld for more information.

   SilverPohligHellmanWithFactorization

SilverPohligHellmanWithFactorization (n,b,q,f)

          Find discrete log of n base b in F_q where q is a prime
          using the Silver-Pohlig-Hellman algoritm, given f being
          the factorization of q-1

   SqrtModPrime

SqrtModPrime (n,p)

          Find square root of n modulo p (where p is a prime).
          Null is returned if not a quadratic residue.

          See Planetmath or Mathworld for more information.

   StrongPseudoprimeTest

StrongPseudoprimeTest (n,b)

          Run the strong pseudoprime test base b on n.

          See Planetmath or Mathworld for more information.

   gcd

gcd (a,args...)

          Aliases: GCD

          Greatest common divisor of integers. You can enter as
          many integers in the argument list, or you can give a
          vector or a matrix of integers. If you give more than
          one matrix of the same size then GCD is done element by
          element.

          See Planetmath or Mathworld for more information.

   lcm

lcm (a,args...)

          Aliases: LCM

          Least common multiplier of integers. You can enter as
          many integers in the argument list, or you can give a
          vector or a matrix of integers. If you give more than
          one matrix of the same size then LCM is done element by
          element.

          See Planetmath or Mathworld for more information.
     _________________________________________________________

10.8. Matrix Manipulation

   ApplyOverMatrix

ApplyOverMatrix (a,func)

          Apply a function over all entries of a matrix and
          return a matrix of the results

   ApplyOverMatrix2

ApplyOverMatrix2 (a,b,func)

          Apply a function over all entries of 2 matrices (or 1
          value and 1 matrix) and return a matrix of the results

   ColumnsOf

ColumnsOf (M)

          Gets the columns of a matrix as a horizontal vector

   ComplementSubmatrix

ComplementSubmatrix (m,r,c)

          Remove column(s) and row(s) from a matrix

   CompoundMatrix

CompoundMatrix (k,A)

          Calculate the kth compund matrix of A

   CountZeroColumns

CountZeroColumns (M)

          Count the number of zero columns in a matrix. For
          example Once you column reduce a matrix you can use
          this to find the nullity. See cref and Nullity.

   DeleteColumn

DeleteColumn (M,col)

          Delete a column of a matrix

   DeleteRow

DeleteRow (M,row)

          Delete a row of a matrix

   DiagonalOf

DiagonalOf (M)

          Gets the diagonal entries of a matrix as a column
          vector.

   DotProduct

DotProduct (u,v)

          Get the dot product of two vectors. The vectors must be
          of the same size. No conjugates are taken so this is a
          bilinear form even if working over the complex numbers.

          See Planetmath for more information.

   ExpandMatrix

ExpandMatrix (M)

          Expands a matrix just like we do on unquoted matrix
          input. That is we expand any internal matrices as
          blocks. This is a way to construct matrices out of
          smaller ones and this is normally done automatically on
          input unless the matrix is quoted.

   HermitianProduct

HermitianProduct (u,v)

          Aliases: InnerProduct

          Get the hermitian product of two vectors. The vectors
          must be of the same size. This is a sesquilinear form
          using the identity matrix.

          See Mathworld for more information.

   I

I (n)

          Aliases: eye

          Return an identity matrix of a given size, that is n by
          n.

          See Planetmath for more information.

   IndexComplement

IndexComplement (vec,msize)

          Return the index complement of a vector of indexes

   IsDiagonal

IsDiagonal (M)

          Is a matrix diagonal

          See Planetmath for more information.

   IsLowerTriangular

IsLowerTriangular (M)

          Is a matrix lower triangular

   IsMatrixInteger

IsMatrixInteger (M)

          Check if a matrix is an integer (non-complex) matrix

   IsMatrixRational

IsMatrixRational (M)

          Check if a matrix is a rational (non-complex) matrix

   IsMatrixReal

IsMatrixReal (M)

          Check if a matrix is a real (non-complex) matrix

   IsMatrixSquare

IsMatrixSquare (M)

          Check if a matrix is square, that is its width is equal
          to its height.

   IsUpperTriangular

IsUpperTriangular (M)

          Is a matrix upper triangular

   IsValueOnly

IsValueOnly (M)

          Check if a matrix is a matrix of numbers

   IsVector

IsVector (v)

          Is argument a horizontal or a vertical vector. Genius
          does not distinguish between a matrix and a vector and
          a vector is just a 1 by n or n by 1 matrix.

   LowerTriangular

LowerTriangular (M)

          Zero out entries above the diagonal

   MakeDiagonal

MakeDiagonal (v,arg...)

          Aliases: diag

          Make diagonal matrix from a vector

          See Planetmath for more information.

   MakeVector

MakeDiagonal (A)

          Make column vector out of matrix by putting columns
          above each other. Returns null when given null.

   MatrixProduct

MatrixProduct (a)

          Calculate the product of all elements in a matrix. That
          is we multiply all the elements and return a number
          that is the product of all the elements.

   MatrixSum

MatrixSum (a)

          Calculate the sum of all elements in a matrix. That is
          we add all the elements and return a number that is the
          sum of all the elements.

   MatrixSumSquares

MatrixSumSquares (a)

          Calculate the sum of squares of all elements in a
          matrix.

   OuterProduct

OuterProduct (u,v)

          Get the outer product of two vectors

   ReverseVector

ReverseVector (v)

          Reverse elements in a vector

   RowSum

RowSum (m)

          Calculate sum of each row in a matrix

   RowSumSquares

RowSumSquares (m)

          Calculate sum of squares of each row in a matrix

   RowsOf

RowsOf (M)

          Gets the rows of a matrix as a vertical vector

   SetMatrixSize

SetMatrixSize (M,rows,columns)

          Make new matrix of given size from old one. That is, a
          new matrix will be returned to which the old one is
          copied. Entries that don't fit are clipped and extra
          space is filled with zeros.

   SortVector

SortVector (v)

          Sort vector elements in an increasing order.

   StripZeroColumns

StripZeroColumns (M)

          Removes any all-zero columns of M.

   StripZeroRows

StripZeroRows (M)

          Removes any all-zero rows of M.

   Submatrix

Submatrix (m,r,c)

          Return column(s) and row(s) from a matrix

   SwapRows

SwapRows (m,row1,row2)

          Swap two rows in a matrix

   UpperTriangular

UpperTriangular (M)

          Zero out entries below the diagonal

   columns

columns (M)

          Get the number of columns of a matrix

   elements

elements (M)

          Get the number of elements of a matrix

   ones

ones (rows,columns...)

          Make an matrix of all ones (or a row vector)

   rows

rows (M)

          Get the number of rows of a matrix

   zeros

zeros (rows,columns...)

          Make an matrix of all zeros (or a row vector)
     _________________________________________________________

10.9. Linear Algebra

   AuxilliaryUnitMatrix

AuxilliaryUnitMatrix (n)

          Get the auxilliary unit matrix of size n

   BilinearForm

BilinearForm (v,A,w)

          Evaluate (v,w) with respect to the bilinear form given
          by the matrix A

   BilinearFormFunction

BilinearFormFunction (A)

          Return a function that evaluates two vectors with
          respect to the bilinear form given by A

   CharacteristicPolynomial

CharacteristicPolynomial (M)

          Aliases: CharPoly

          Get the characteristic polynomial as a vector

   CharacteristicPolynomialFunction

CharacteristicPolynomialFunction (M)

          Get the characteristic polynomial as a function

   ColumnSpace

ColumnSpace (M)

          Get a basis matrix for the columnspace of a matrix

   CommutationMatrix

CommutationMatrix (m, n)

          Return the commutation matrix K(m,n) which is the
          unique m*n by m*n matrix such that K(m,n) *
          MakeVector(A) = MakeVector(A.') for all m by n matrices
          A.

   CompanionMatrix

CompanionMatrix (p)

          Companion matrix of a polynomial (as vector)

   ConjugateTranspose

ConjugateTranspose (M)

          Conjugate transpose of a matrix (adjoint). This is the
          same as the ' operator.

          See Planetmath for more information.

   Convolution

Convolution (a,b)

          Aliases: convol

          Calculate convolution of two horizontal vectors

   ConvolutionVector

ConvolutionVector (a,b)

          Calculate convolution of two horizontal vectors

   CrossProduct

CrossProduct (v,w)

          CrossProduct of two vectors in R^3

   DeterminantalDivisorsInteger

DeterminantalDivisorsInteger (M)

          Get the determinantal divisors of an integer matrix
          (not its characteristic)

   DirectSum

DirectSum (M,N...)

          Direct sum of matrices

   DirectSumMatrixVector

DirectSumMatrixVector (v)

          Direct sum of a vector of matrices

   Eigenvalues

Eigenvalues (M)

          Aliases: eig

          Get the eigenvalues of a square matrix. Currently only
          works for matrices of size up to 4 by 4, or for
          triangular matrices (for which the eigenvalues are on
          the diagonal).

          See Planetmath or Mathworld for more information.

   GramSchmidt

GramSchmidt (v,B...)

          Apply the Gram-Schmidt process (to the columns) with
          respect to inner product given by B. If B is not given
          then the standard hermitian product is used. B can
          either be a sesquilinear function of two arguments or
          it can be a matrix giving a sesquilinear form. The
          vectors will be made orthonormal with respect to B.

          See Planetmath for more information.

   HankelMatrix

HankelMatrix (c,r)

          Hankel matrix

   HilbertMatrix

HilbertMatrix (n)

          Hilbert matrix of order n.

          See Planetmath for more information.

   Image

Image (T)

          Get the image (columnspace) of a linear transform

   InfNorm

InfNorm (v)

          Get the Inf Norm of a vector, sometimes called the sup
          norm or the max norm.

   InvariantFactorsInteger

InvariantFactorsInteger (M)

          Get the invariant factors of a square integer matrix
          (not its characteristic)

   InverseHilbertMatrix

InverseHilbertMatrix (n)

          Inverse Hilbert matrix of order n.

          See Planetmath for more information.

   IsHermitian

IsHermitian (M)

          Is a matrix hermitian. That is, is it equal to its
          conjugate transpose.

          See Planetmath for more information.

   IsInSubspace

IsInSubspace (v,W)

          Test if a vector is in a subspace

   IsInvertible

IsInvertible (n)

          Is a matrix (or number) invertible (Integer matrix is
          invertible iff it's invertible over the integers)

   IsInvertibleField

IsInvertibleField (n)

          Is a matrix (or number) invertible over a field

   IsNormal

IsNormal (M)

          Is M a normal matrix. That is, does M*M' == M'*M.

          See Planetmath or Mathworld for more information.

   IsPositiveDefinite

IsPositiveDefinite (M)

          Is M a hermitian positive definite matrix. That is if
          HermitianProduct(M*v,v) is always strictly positive for
          any vector v. M must be square and hermitian to be
          positive definite. The check that is performed is that
          every principal submatrix has a nonnegative
          determinant. (See HermitianProduct)

          Note that some authors (for example Mathworld) do not
          require that M be hermitian, and then the condition is
          on the real part of the inner product, but we do not
          take this view. If you wish to perform this check, just
          check the hermitian part of the matrix M as follows:
          IsPositiveDefinite(M+M').

          See Planetmath or Mathworld for more information.

   IsPositiveSemidefinite

IsPositiveSemidefinite (M)

          Is M a hermitian positive semidefinite matrix. That is
          if HermitianProduct(M*v,v) is always nonnegative for
          any vector v. M must be square and hermitian to be
          positive semidefinite. The check that is performed is
          that every principal submatrix has a nonnegative
          determinant. (See HermitianProduct)

          Note that some authors do not require that M be
          hermitian, and then the condition is on the real part
          of the inner product, but we do not take this view. If
          you wish to perform this check, just check the
          hermitian part of the matrix M as follows:
          IsPositiveSemidefinite(M+M').

          See Planetmath or Mathworld for more information.

   IsSkewHermitian

IsSkewHermitian (M)

          Is a matrix skew-hermitian. That is, is the conjugate
          transpose equal to negative of the matrix.

          See Planetmath for more information.

   IsUnitary

IsUnitary (M)

          Is a matrix unitary? That is, does M'*M and M*M' equal
          the identity.

          See Planetmath or Mathworld for more information.

   JordanBlock

JordanBlock (n,lambda)

          Aliases: J

          Get the Jordan block corresponding to the eigenvalue
          lambda with multiplicity n.

          See Planetmath or Mathworld for more information.

   Kernel

Kernel (T)

          Get the kernel (nullspace) of a linear transform.

          (See NullSpace)

   LUDecomposition

LUDecomposition (A, L, U)

          Get the LU decomposition of A and store the result in
          the L and U which should be references. It returns true
          if successful. For example suppose that A is a square
          matrix, then after running:

genius> LUDecomposition(A,&L,&U)

          You will have the lower matrix stored in a variable
          called L and the upper matrix in a variable called U.

          This is the LU decomposition of a matrix aka Crout
          and/or Cholesky reduction. (ISBN 0-201-11577-8
          pp.99-103) The upper triangular matrix features a
          diagonal of values 1 (one). This is not Doolittle's
          Method which features the 1's diagonal on the lower
          matrix.

          Not all matrices have LU decompositions, for example
          [0,1;1,0] does not and this function returns false in
          this case and sets L and U to null.

          See Planetmath or Mathworld for more information.

   Minor

Minor (M,i,j)

          Get the i-j minor of a matrix.

          See Planetmath for more information.

   NonPivotColumns

NonPivotColumns (M)

          Return the columns that are not the pivot columns of a
          matrix

   Norm

Norm (v,p...)

          Aliases: norm

          Get the p Norm (or 2 Norm if no p is supplied) of a
          vector

   NullSpace

NullSpace (T)

          Get the nullspace of a matrix. That is the kernel of
          the linear mapping that the matrix represents. This is
          returned as a matrix whose column space is the
          nullspace of T.

          See Planetmath for more information.

   Nullity

Nullity (M)

          Aliases: nullity

          Get the nullity of a matrix.

          See Planetmath for more information.

   OrthogonalComplement

OrthogonalComplement (M)

          Get the orthogonal complement of the columnspace

   PivotColumns

PivotColumns (M)

          Return pivot columns of a matrix, that is columns which
          have a leading 1 in row reduced form. Also returns the
          row where they occur.

   Projection

Projection (v,W,B...)

          Projection of vector v onto subspace W with respect to
          inner product given by B. If B is not given then the
          standard hermitian product is used. B can either be a
          sesquilinear function of two arguments or it can be a
          matrix giving a sesquilinear form.

   QRDecomposition

QRDecomposition (A, Q)

          Get the QR decomposition of a square matrix A, returns
          the upper triangular matrix R and sets Q to the
          orthogonal (unitary) matrix. Q should be a reference or
          null if you don't want any return. For example:

genius> R = QRDecomposition(A,&Q)

          You will have the upper triangular matrix stored in a
          variable called R and the orthogonal (unitary) matrix
          stored in Q.

          See Planetmath or Mathworld for more information.

   RayleighQuotient

RayleighQuotient (A,x)

          Return the Rayleigh quotient (also called the
          Rayleigh-Ritz quotient or ratio) of a matrix and a
          vector.

          See Planetmath for more information.

   Rank

Rank (M)

          Aliases: rank

          Get the rank of a matrix.

          See Planetmath for more information.

   RosserMatrix

RosserMatrix ()

          Rosser matrix, a classic symmetric eigenvalue test
          problem

   Rotation2D

Rotation2D (angle)

          Aliases: RotationMatrix

          Rotation around origin in R^2

   Rotation3DX

Rotation3DX (angle)

          Rotation around origin in R^3 about the x-axis

   Rotation3DY

Rotation3DY (angle)

          Rotation around origin in R^3 about the y-axis

   Rotation3DZ

Rotation3DZ (angle)

          Rotation around origin in R^3 about the z-axis

   RowSpace

RowSpace (M)

          Get a basis matrix for the rowspace of a matrix

   SesquilinearForm

SesquilinearForm (v,A,w)

          Evaluate (v,w) with respect to the sesquilinear form
          given by the matrix A

   SesquilinearFormFunction

SesquilinearFormFunction (A)

          Return a function that evaluates two vectors with
          respect to the sesquilinear form given by A

   SmithNormalFormField

SmithNormalFormField (A)

          Smith Normal Form for fields (will end up with 1's on
          the diagonal)

   SmithNormalFormInteger

SmithNormalFormInteger (M)

          Smith Normal Form for square integer matrices (not its
          characteristic)

   SolveLinearSystem

SolveLinearSystem (M,V,args...)

          Solve linear system Mx=V, return solution V if there is
          a unique solution, null otherwise. Extra two reference
          parameters can optionally be used to get the reduced M
          and V.

   ToeplitzMatrix

ToeplitzMatrix (c, r...)

          Return the Toeplitz matrix constructed given the first
          column c and (optionally) the first row r. If only the
          column c is given then it is conjugated and the
          nonconjugated version is used for the first row to give
          a Hermitian matrix (if the first element is real of
          course).

          See Planetmath for more information.

   Trace

Trace (m)

          Aliases: trace

          Calculate the trace of a matrix

   Transpose

Transpose (M)

          Transpose of a matrix. This is the same as the .'
          operator.

          See Planetmath for more information.

   VandermondeMatrix

VandermondeMatrix (v)

          Aliases: vander

          Return the Vandermonde matrix

   VectorAngle

VectorAngle (v,w,B...)

          The angle of two vectors with respect to inner product
          given by B. If B is not given then the standard
          hermitian product is used. B can either be a
          sesquilinear function of two arguments or it can be a
          matrix giving a sesquilinear form.

   VectorSpaceDirectSum

VectorSpaceDirectSum (M,N)

          The direct sum of the vector spaces M and N

   VectorSubspaceIntersection

VectorSubspaceIntersection (M,N)

          Intersection of the subspaces given by M and N

   VectorSubspaceSum

VectorSubspaceSum (M,N)

          The sum of the vector spaces M and N, that is {w |
          w=m+n, m in M, n in N}

   adj

adj (m)

          Aliases: Adjugate

          Get the classical adjoint (adjugate) of a matrix

   cref

cref (M)

          Aliases: CREF ColumnReducedEchelonForm

          Compute the Column Reduced Echelon Form

   det

det (M)

          Aliases: Determinant

          Get the determinant of a matrix.

          See Planetmath for more information.

   ref

ref (M)

          Aliases: REF RowEchelonForm

          Get the row echelon form of a matrix.

          See Planetmath for more information.

   rref

rref (M)

          Aliases: RREF ReducedRowEchelonForm

          Get the reduced row echelon form of a matrix.

          See Planetmath for more information.
     _________________________________________________________

10.10. Combinatorics

   Catalan

Catalan (n)

          Get n'th catalan number.

          See Planetmath for more information.

   Combinations

Combinations (k,n)

          Get all combinations of k numbers from 1 to n as a
          vector of vectors. (See also NextCombination)

   DoubleFactorial

DoubleFactorial (n)

          Double factorial: n(n-2)(n-4)...

          See Planetmath for more information.

   Factorial

Factorial (n)

          Factorial: n(n-1)(n-2)...

          See Planetmath for more information.

   FallingFactorial

FallingFactorial (n,k)

          Falling factorial: (n)_k = n(n-1)...(n-(k-1))

          See Planetmath for more information.

   Fibbonachi

Fibbonachi (x)

          Aliases: fib

          Calculate nth fibbonachi number. That is the number
          defined recursively by Fibbonachi(n) = Fibbonachi(n-1)
          + Fibbonachi(n-2) and Fibbonachi(1) = Fibbonachi(2) =
          1.

          See Planetmath or Mathworld for more information.

   GaloisMatrix

GaloisMatrix (combining_rule)

          Galois matrix given a linear combining rule
          (a_1*x_+...+a_n*x_n=x_(n+1))

   HarmonicNumber

HarmonicNumber (n,r)

          Aliases: HarmonicH

          Harmonic Number, the n'th harmonic number of order r.

   Hofstadter

Hofstadter (n)

          Hofstadter's function q(n) defined by q(1)=1, q(2)=1,
          q(n)=q(n-q(n-1))+q(n-q(n-2))

   LinearRecursiveSequence

LinearRecursiveSequence (seed_values,combining_rule,n)

          Compute linear recursive sequence using galois stepping

   Multinomial

Multinomial (v,arg...)

          Calculate multinomial coefficients

   NextCombination

NextCombination (v,n)

          Get combination that would come after v in call to
          combinations, first combination should be [1:k]. This
          function is useful if you have many combinations to go
          through and you don't want to waste memory to store
          them all.

          For example with Combination you would normally write a
          loop like:

for n in Combinations (4,6) do (
  SomeFunction (n)
);

          But with NextCombination you would write something
          like:

n:=[1:4];
do (
  SomeFunction (n)
) while not IsNull(n:=NextCombination(n,6));

          See also Combinations.

   Pascal

Pascal (i)

          Get the Pascal's triangle as a matrix. This will return
          an i+1 by i+1 lower diagonal matrix which is the
          Pascal's triangle after i iterations.

          See Planetmath for more information.

   Permutations

Permutations (k,n)

          Get all permutations of k numbers from 1 to n as a
          vector of vectors

   RisingFactorial

RisingFactorial (n,k)

          Aliases: Puchhammer

          (Puchhammer) Rising factorial: (n)_k =
          n(n+1)...(n+(k-1))

          See Planetmath for more information.

   Subfactorial

Subfactorial (n)

          Subfactorial: n! times sum_{k=1}^n (-1)^k/k!

   Triangular

Triangular (nth)

          Calculate the n'th triangular number.

          See Planetmath for more information.

   nCr

nCr (n,r)

          Aliases: Binomial

          Calculate combinations (binomial coefficient)

   nPr

nPr (n,r)

          Calculate permutations
     _________________________________________________________

10.11. Calculus

   CompositeSimpsonsRule

CompositeSimpsonsRule (f,a,b,n)

          Integration of f by Composite Simpson's Rule on the
          interval [a,b] with n subintervals with error of
          max(f'''')*h^4*(b-a)/180, note that n should be even.

          See Planetmath for more information.

   CompositeSimpsonsRuleTolerance

CompositeSimpsonsRuleTolerance (f,a,b,FourthDerivativeBound,Tolerance)

          Integration of f by Composite Simpson's Rule on the
          interval [a,b] with the number of steps calculated by
          the fourth derivative bound and the desired tolerance.

          See Planetmath for more information.

   Derivative

Derivative (f,x0)

          Attempt to calculate derivative by trying first
          symbolically and then numerically.

   InfiniteProduct

InfiniteProduct (func,start,inc)

          Try to calculate an infinite product for a single
          parameter function

   InfiniteProduct2

InfiniteProduct2 (func,arg,start,inc)

          Try to calculate an infinite product for a double
          parameter function with func(arg,n)

   InfiniteSum

InfiniteSum (func,start,inc)

          Try to calculate an infinite sum for a single parameter
          function

   InfiniteSum2

InfiniteSum2 (func,arg,start,inc)

          Try to calculate an infinite sum for a double parameter
          function with func(arg,n)

   IsContinuous

IsContinuous (f,x0)

          Try and see if a real-valued function is continuous at
          x0 by calculating the limit there

   IsDifferentiable

IsDifferentiable (f,x0)

          Test for differentiability by approximating the left
          and right limits and comparing

   LeftLimit

LeftLimit (f,x0)

          Calculate the left limit of a real-valued function at
          x0

   Limit

Limit (f,x0)

          Calculate the limit of a real-valued function at x0.
          Tries to calculate both left and right limits.

   MidpointRule

MidpointRule (f,a,b,n)

          Integration by midpoint rule

   NumericalDerivative

NumericalDerivative (f,x0)

          Aliases: NDerivative

          Attempt to calculate numerical derivative

   NumericalIntegral

NumericalIntegral (f,a,b)

          Integration by rule set in NumericalIntegralFunction of
          f from a to b using NumericalIntegralSteps steps

   NumericalLeftDerivative

NumericalLeftDerivative (f,x0)

          Attempt to calculate numerical left derivative

   NumericalLimitAtInfinity

NumericalLimitAtInfinity (_f,step_fun,tolerance,successive_for_success,
N)

          Attempt to calculate the limit of f(step_fun(i)) as i
          goes from 1 to N

   NumericalRightDerivative

NumericalRightDerivative (f,x0)

          Attempt to calculate numerical right derivative

   OneSidedFivePointFormula

OneSidedFivePointFormula (f,x0,h)

          Compute one-sided derivative using five point formula

   OneSidedThreePointFormula

OneSidedThreePointFormula (f,x0,h)

          Compute one-sided derivative using three-point formula

   RightLimit

RightLimit (f,x0)

          Calculate the right limit of a real-valued function at
          x0

   TwoSidedFivePointFormula

TwoSidedFivePointFormula (f,x0,h)

          Compute two-sided derivative using five-point formula

   TwoSidedThreePointFormula

TwoSidedThreePointFormula (f,x0,h)

          Compute two-sided derivative using three-point formula
     _________________________________________________________

10.12. Functions

   Argument

Argument (z)

          Aliases: Arg arg

          argument (angle) of complex number

   DirichletKernel

DirichletKernel (n,t)

          Dirichlet kernel of order n

   DiscreteDelta

DiscreteDelta (v)

          Returns 1 iff all elements are zero

   ErrorFunction

ErrorFunction (x)

          Aliases: erf

          The error function, 2/sqrt(pi) * int_0^x e^(-t^2) dt

          See Planetmath for more information.

   FejerKernel

FejerKernel (n,t)

          Fejer kernel of order n evaluated at t

          See Planetmath for more information.

   GammaFunction

GammaFunction (x)

          Aliases: Gamma

          The Gamma function. Currently only implemented for real
          values.

          See Planetmath for more information.

   KroneckerDelta

KroneckerDelta (v)

          Returns 1 iff all elements are equal

   MinimizeFunction

MinimizeFunction (func,x,incr)

          Find the first value where f(x)=0

   MoebiusDiskMapping

MoebiusDiskMapping (a,z)

          Moebius mapping of the disk to itself mapping a to 0

          See Planetmath for more information.

   MoebiusMapping

MoebiusMapping (z,z2,z3,z4)

          Moebius mapping using the cross ratio taking z2,z3,z4
          to 1,0, and infinity respectively

          See Planetmath for more information.

   MoebiusMappingInftyToInfty

MoebiusMappingInftyToInfty (z,z2,z3)

          Moebius mapping using the cross ratio taking infinity
          to infinity and z2,z3 to 1 and 0 respectively

          See Planetmath for more information.

   MoebiusMappingInftyToOne

MoebiusMappingInftyToOne (z,z3,z4)

          Moebius mapping using the cross ratio taking infinity
          to 1 and z3,z4 to 0 and infinity respectively

          See Planetmath for more information.

   MoebiusMappingInftyToZero

MoebiusMappingInftyToZero (z,z2,z4)

          Moebius mapping using the cross ratio taking infinity
          to 0 and z2,z4 to 1 and infinity respectively

          See Planetmath for more information.

   PoissonKernel

PoissonKernel (r,sigma)

          Poisson kernel on D(0,1) (not normalized to 1, that is
          integral of this is 2pi)

   PoissonKernelRadius

PoissonKernelRadius (r,sigma)

          Poisson kernel on D(0,R) (not normalized to 1)

   RiemannZeta

RiemannZeta (x)

          Aliases: zeta

          The Riemann zeta function. Currently only implemented
          for real values.

          See Planetmath for more information.

   UnitStep

UnitStep (x)

          The unit step function is 0 for x<0, 1 otherwise. This
          is the integral of the Dirac Delta function.

   cis

cis (x)

          The cis function, that is the same as cos(x)+1i*sin(x)

   deg2rad

deg2rad (x)

          Convert degrees to radians

   rad2deg

rad2deg (x)

          Convert radians to degrees
     _________________________________________________________

10.13. Equation Solving

   CubicFormula

CubicFormula (p)

          Compute roots of a cubic (degree 3) polynomial using
          the cubic formula. The polynomial should be given as a
          vector of coefficients. That is 4*x^3 + 2*x + 1
          corresponds to the vector [1,2,0,4]. Returns a column
          vector of the three solutions. The first solution is
          always the real one as a cubic always has one real
          solution.

          See Planetmath, Mathworld, or Wikipedia for more
          information.

   EulerMethod

EulerMethod (f,x0,y0,x1,n)

          Use classical Euler's method to numerically solve
          y'=f(x,y) for initial x0, y0 going to x1 with n
          increments, returns y at x1.

          See Mathworld for more information.

   FindRootBisection

FindRootBisection (f,a,b,TOL,N)

          Find root of a function using the bisection method

   FindRootFalsePosition

FindRootFalsePosition (f,a,b,TOL,N)

          Find root of a function using the method of false
          position

   FindRootMullersMethod

FindRootMullersMethod (f,x1,x2,x3,TOL,N)

          Find root of a function using the Muller's method

   FindRootSecant

FindRootSecant (f,a,b,TOL,N)

          Find root of a function using the secant method

   PolynomialRoots

PolynomialRoots (p)

          Compute roots of a polynomial (degrees 1 through 4)
          using one of the formulas for such polynomials. The
          polynomial should be given as a vector of coefficients.
          That is 4*x^3 + 2*x + 1 corresponds to the vector
          [1,2,0,4]. Returns a column vector of the solutions.

          The function calls QuadraticFormula, CubicFormula, and
          QuarticFormula.

   QuadraticFormula

QuadraticFormula (p)

          Compute roots of a quadratic (degree 2) polynomial
          using the quadratic formula. The polynomial should be
          given as a vector of coefficients. That is 3*x^2 + 2*x
          + 1 corresponds to the vector [1,2,3]. Returns a column
          vector of the two solutions.

          See Planetmath or Mathworld for more information.

   QuarticFormula

QuarticFormula (p)

          Compute roots of a quartic (degree 4) polynomial using
          the quartic formula. The polynomial should be given as
          a vector of coefficients. That is 5*x^4 + 2*x + 1
          corresponds to the vector [1,2,0,0,5]. Returns a column
          vector of the four solutions.

          See Planetmath, Mathworld, or Wikipedia for more
          information.

   RungeKutta

RungeKutta (f,x0,y0,x1,n)

          Use classical non-adaptive Runge-Kutta method to
          numerically solve y'=f(x,y) for initial x0, y0 going to
          x1 with n increments, returns y at x1.

          See Mathworld for more information.
     _________________________________________________________

10.14. Statistics

   Average

Average (m)

          Aliases: average Mean mean

          Calculate average of an entire matrix

          See Mathworld for more information.

   GaussDistribution

GaussDistribution (x,sigma)

          Integral of the GaussFunction from 0 to x (area under
          the normal curve)

          See Mathworld for more information.

   GaussFunction

GaussFunction (x,sigma)

          The normalized Gauss distribution function (the normal
          curve)

          See Mathworld for more information.

   Median

Median (m)

          Aliases: median

          Calculate median of an entire matrix

          See Mathworld for more information.

   PopulationStandardDeviation

PopulationStandardDeviation (m)

          Aliases: stdevp

          Calculate the population standard deviation of a whole
          matrix

   RowAverage

RowAverage (m)

          Aliases: RowMean

          Calculate average of each row in a matrix

          See Mathworld for more information.

   RowMedian

RowMedian (m)

          Calculate median of each row in a matrix and return a
          column vector of the medians.

          See Mathworld for more information.

   RowPopulationStandardDeviation

RowPopulationStandardDeviation (m)

          Aliases: rowstdevp

          Calculate the population standard deviations of rows of
          a matrix and return a vertical vector

   RowStandardDeviation

RowStandardDeviation (m)

          Aliases: rowstdev

          Calculate the standard deviations of rows of a matrix
          and return a vertical vector

   StandardDeviation

StandardDeviation (m)

          Aliases: stdev

          Calculate the standard deviation of a whole matrix
     _________________________________________________________

10.15. Polynomials

   AddPoly

AddPoly (p1,p2)

          Add two polynomials (vectors)

   IsPoly

IsPoly (p)

          Check if a vector is usable as a polynomial

   MultiplyPoly

MultiplyPoly (p1,p2)

          Multiply two polynomials (as vectors)

   NewtonsMethodPoly

NewtonsMethodPoly (poly,guess,epsilon,maxn)

          Run newton's method on a polynomial to attempt to find
          a root, returns after two successive values are within
          epsilon or after maxn tries (then returns null).

   Poly2ndDerivative

Poly2ndDerivative (p)

          Take second polynomial (as vector) derivative

   PolyDerivative

PolyDerivative (p)

          Take polynomial (as vector) derivative

   PolyToFunction

PolyToFunction (p)

          Make function out of a polynomial (as vector)

   PolyToString

PolyToString (p,var...)

          Make string out of a polynomial (as vector)

   SubtractPoly

SubtractPoly (p1,p2)

          Subtract two polynomials (as vectors)

   TrimPoly

TrimPoly (p)

          Trim zeros from a polynomial (as vector)
     _________________________________________________________

10.16. Set Theory

   Intersection

Intersection (X,Y)

          Returns a set theoretic intersection of X and Y (X and
          Y are vectors pretending to be sets)

   IsIn

IsIn (x,X)

          Returns true if the element x is in the set X (where X
          is a vector pretending to be a set)

   MakeSet

MakeSet (X)

          Returns a set where every element of X appears only
          once

   SetMinus

SetMinus (X,Y)

          Returns a set theoretic difference X-Y (X and Y are
          vectors pretending to be sets)

   Union

Union (X,Y)

          Returns a set theoretic union of X and Y (X and Y are
          vectors pretending to be sets)
     _________________________________________________________

10.17. Miscellaneous

   ASCIIToString

ASCIIToString (vec)

          Convert a vector of ASCII values to a string

   AlphabetToString

AlphabetToString (vec,alphabet)

          Convert a vector of 0-based alphabet values (positions
          in the alphabet string) to a string

   StringToASCII

StringToASCII (str)

          Convert a string to a vector of ASCII values.

   StringToAlphabet

StringToAlphabet (str,alphabet)

          Convert a string to a vector of 0-based alphabet values
          (positions in the alphabet string), -1's for unknown
          letters
     _________________________________________________________

10.18. Symbolic Operations

   SymbolicDerivative

SymbolicDerivative (f)

          Attempt to symbolically differentiate the function f,
          where f is a function of one variable.

          Examples:

genius> SymbolicDerivative(sin)
genius> (`(x)=cos(x))
genius> SymbolicDerivative(`(x)=7*x^2)
genius> (`(x)=(7*(2*x)))

   SymbolicDerivativeTry

SymbolicDerivativeTry (f)

          Attempt to symbolically differentiate the function f,
          where f is a function of one variable, returns null if
          unsuccessful but is silent. (See SymbolicDerivative)

   SymbolicNthDerivative

SymbolicNthDerivative (f,n)

          Attempt to symbolically differentiate a function n
          times. (See SymbolicDerivative)

   SymbolicNthDerivativeTry

SymbolicNthDerivativeTry (f,n)

          Attempt to symbolically differentiate a function n
          times quietly and return null on failure (See
          SymbolicNthDerivative)

   SymbolicTaylorApproximationFunction

SymbolicTaylorApproximationFunction (f,x0,n)

          Attempt to construct the taylor approximation function
          around x0 to the nth degree. (See SymbolicDerivative)
     _________________________________________________________

10.19. Plotting

   LinePlot

LinePlot (func1,func2,func3,...)

LinePlot (func1,func2,func3,x1,x2,y1,y2)

          Plot a function (or several functions) with a line.
          First up to 10 arguments are functions, then optionally
          you can specify the limits of the plotting window as
          x1, x2, y1, y2. If limits are not specified, then the
          currently set limits apply (See LinePlotWindow)

          Examples:

genius> LinePlot(sin,cos)
genius> LinePlot(`(x)=x^2,-1,1,0,1)

   LinePlotClear

LinePlotClear ()

          Show the line plot window and clear out functions and
          any other lines that were drawn.

   LinePlotDrawLine

LinePlotDrawLine (x1,y1,x2,y2,...)

LinePlotDrawLine (v,...)

          Draw a line from x1,y1 to x2,y2. x1,y1, x2,y2 can be
          replaced by an n by 2 matrix for a longer line.

          Extra parameters can be added to specify line color and
          thickness, by adding a string "color" or "thickness"
          and the color and thickness after as a string or
          integer respectively.

          Examples:

genius> LinePlotDrawLine(0,0,1,1,"color","blue","thickness",3)
genius> LinePlotDrawLine([0,0;1,-1;-1,-1])

   LinePlotParametric

LinePlotParametric (xfunc,yfunc,...)

LinePlotParametric (xfunc,yfunc,t1,t2,tinc)

LinePlotParametric (xfunc,yfunc,t1,t2,tinc,x1,x2,y1,y2)

          Plot a parametric function with a line. First come the
          functions for x and y then optionally the t limits as
          t1,t2,tinc, then optionally the limits as x1,x2,y1,y2.

   LinePlotCParametric

LinePlotCParametric (func,...)

LinePlotCParametric (func,t1,t2,tinc)

LinePlotCParametric (func,t1,t2,tinc,x1,x2,y1,y2)

          Plot a parametric complex valued function with a line.
          First comes the function that returns x+iy then
          optionally the t limits as t1,t2,tinc, then optionally
          the limits as x1,x2,y1,y2.

   SurfacePlot

SurfacePlot (func)

SurfacePlot (func,x1,x2,y1,y2,z1,z2)

          Plot a surface function which takes either two
          arguments or a complex number. First comes the function
          then optionally limits as x1, x2, y1, y2, z1, z2. If
          limits are not specified, then the currently set limits
          apply (See SurfacePlotWindow). Genius can only plot a
          single surface function at this time.

          Examples:

genius> SurfacePlot(|sin|,-1,1,-1,1,0,1.5)
genius> SurfacePlot(`(x,y)=x^2+y,-1,1,-1,1,-2,2)
genius> SurfacePlot(`(z)=|z|^2,-1,1,-1,1,0,2)
     _________________________________________________________

Chapter 11. Example programs in GEL

   Here is a function that calculates factorials:
function f(x) = if x <= 1 then 1 else (f(x-1)*x)

   With indentation it becomes:
function f(x) = (
  if x <= 1 then
    1
  else
    (f(x-1)*x)
)

   This is a direct port of the factorial function from the bc
   manpage. The syntax seems similar to bc, but different in that
   in GEL, the last expression is the one that is returned. Using
   the return function instead, it would be:
function f(x) = (
  if (x <= 1) then return (1);
  return (f(x-1) * x)
)

   This is a smaller, nicer, iterative version, that uses the
   product loop:
function f(x) = prod k=1 to x do k

   Here is a larger example, this basically redefines the
   internal ref function to calculate the same thing, but is
   written in GEL:
# Calculate the row-echelon form of a matrix
function MyOwnREF(m) = (
  if not IsMatrix(m) or not IsValueOnly(m) then
    (error("ref: argument not a value only matrix");bailout);
  s := min(rows(m), columns(m));
  i := 1;
  d := 1;
  while d <= s and i <= columns(m) do (

    # This just makes the anchor element non-zero if at
    # all possible
    if m@(d,i) == 0 then (
      j := d+1;
      while j <= rows(m) do (
        if m@(j,i) == 0 then
          (j=j+1;continue);
        a := m@(j,);
        m@(j,) := m@(d,);
        m@(d,) := a;
        j := j+1;
        break
      )
    );
    if m@(d,i) == 0 then
      (i:=i+1;continue);

    # Here comes the actual zeroing of all but the anchor
    # element rows
    j := d+1;
    while j <= rows(m)) do (
      if m@(j,i) != 0 then (
        m@(j,) := m@(j,)-(m@(j,i)/m@(d,i))*m@(d,)
      );
      j := j+1
    );
    m@(d,) := m@(d,) * (1/m@(d,i));
    d := d+1;
    i := i+1
  );
  m
)
     _________________________________________________________

Chapter 12. Settings

   To configure Genius Math Tool, choose Settings->Preferences.
   There are several basic parameters provided by the calculator
   in addition to the ones provided by the standard library.
   These control how the calculator behaves.

   Note Changing settings with GEL


   Many of the settings in Genius are simply global variables,
   and can be evaluated and assigned to in the same way as normal
   variables. See Section 5.2 about evaluating and assigning to
   variables, and Section 10.3 for a list of settings that can be
   modified in this way.

   As an example, you can set the maximum number of digits in a
   result to 12 by typing:
MaxDigits = 12
     _________________________________________________________

12.1. Output

   Maximum digits to output
          The maximum digits in a result (MaxDigits)

   Results as floats
          If the results should be always printed as floats
          (ResultsAsFloats)

   Floats in scientific notation
          If floats should be in scientific notation
          (ScientificNotation)

   Always print full expressions
          Should we print out full expressions for non-numeric
          return values (longer than a line) (FullExpressions)

   Use mixed fractions
          If fractions should be printed as mixed fractions such
          as "1 1/3" rather than "4/3". (MixedFractions)

   Remember output settings across sessions
          Should the output settings in the Number/Expression
          output options frame be remembered for next session.
          Does not apply to the Error/Info output options frame.

          If unchecked, either the default or any previously
          saved settings are used each time Genius starts up.
          Note that settings are saved at the end of the session,
          so if you wish to change the defaults check this box,
          restart genius and then uncheck it again.

   Display errors in a dialog
          If set the errors will be displayed in a seprate
          dialog, if unset the errors will be printed on the
          console.

   Display information messages in a dialog
          If set the information messages will be displayed in a
          seprate dialog, if unset the information messages will
          be printed on the console.

   Maximum errors to display
          The maximum number of errors to return on one
          evaluation (MaxErrors). If you set this to 0 then all
          errors are always returned. Usually if some loop causes
          many errors, then it is unlikely that you will be able
          to make sense out of more than a few of these, so
          seeing a long list of errors is usually not helpful.

   In addition to these preferences, there are some preferences
   that can only be changed by setting them in the workspace
   console. For others that may affect the output see Section
   10.3.

   IntegerOutputBase
          The base that will be used to output integers

   OutputStyle
          A string, can be "normal", "latex", "mathml" or "troff"
          and it will effect how matrices (and perhaps other
          stuff) is printed, useful for pasting into documents
     _________________________________________________________

12.2. Precision

   Floating point precision
          The floating point precision in bits (FloatPrecision).
          Note that changing this only affects newly computed
          quantities. Old values stored in variables are
          obviously still in the old precision and if you want to
          have them more precise you will have to recompute them.
          Exceptions to this are the system constants such as pi
          or e.

   Remember precision setting across sessions
          Should the precision setting be remembered for the next
          session. If unchecked, either the default or any
          previously saved setting is used each time Genius
          starts up. Note that settings are saved at the end of
          the session, so if you wish to change the default check
          this box, restart genius and then uncheck it again.
     _________________________________________________________

12.3. Terminal

   Terminal refers to the console in the workarea.

   Scrollback lines
          Lines of scrollback in the terminal.

   Font
          The font to use on the terminal.

   Black on white
          If to use black on white on the terminal.

   Blinking cursor
          If the cursor in the terminal should blink when the
          terminal is in focus. This can sometimes be annoying
          and it generates idle traffic if you are using Genius
          remotely.
     _________________________________________________________

Chapter 13. About Genius Math Tool

   Genius Math Tool was written by Jiri (George) Lebl
   (<jirka@5z.com>). To find more information about Genius Math
   Tool, please visit the Genius Web page.

   To report a bug or make a suggestion regarding this
   application or this manual, follow the directions in this
   document.

   This program is distributed under the terms of the GNU General
   Public license as published by the Free Software Foundation;
   either version 2 of the License, or (at your option) any later
   version. A copy of this license can be found at this link, or
   in the file COPYING included with the source code of this
   program.
