                                 Genius Manual

  Jiri Lebl

   University of Illinois, Urbana-Champaign

    <jirka@5z.com> 

  Kai Willadsen

   University of Queensland, Australia

    <kaiw@itee.uq.edu.au> 

   Copyright (c) 1997-2008 Jiri (George) Lebl

   Copyright (c) 2004 Kai Willadsen

   Permission is granted to copy, distribute and/or modify this document
   under the terms of the GNU Free Documentation License (GFDL), Version 1.1
   or any later version published by the Free Software Foundation with no
   Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. You can
   find a copy of the GFDL at this link or in the file COPYING-DOCS
   distributed with this manual.

   This manual is part of a collection of GNOME manuals distributed under the
   GFDL. If you want to distribute this manual separately from the
   collection, you can do so by adding a copy of the license to the manual,
   as described in section 6 of the license.

   Many of the names used by companies to distinguish their products and
   services are claimed as trademarks. Where those names appear in any GNOME
   documentation, and the members of the GNOME Documentation Project are made
   aware of those trademarks, then the names are in capital letters or
   initial capital letters.

   DOCUMENT AND MODIFIED VERSIONS OF THE DOCUMENT ARE PROVIDED UNDER THE
   TERMS OF THE GNU FREE DOCUMENTATION LICENSE WITH THE FURTHER UNDERSTANDING
   THAT:

    1. DOCUMENT IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTY OF ANY
       KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
       WARRANTIES THAT THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS
       FREE OF DEFECTS MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
       NON-INFRINGING. THE ENTIRE RISK AS TO THE QUALITY, ACCURACY, AND
       PERFORMANCE OF THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS
       WITH YOU. SHOULD ANY DOCUMENT OR MODIFIED VERSION PROVE DEFECTIVE IN
       ANY RESPECT, YOU (NOT THE INITIAL WRITER, AUTHOR OR ANY CONTRIBUTOR)
       ASSUME THE COST OF ANY NECESSARY SERVICING, REPAIR OR CORRECTION. THIS
       DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS LICENSE.
       NO USE OF ANY DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS
       AUTHORIZED HEREUNDER EXCEPT UNDER THIS DISCLAIMER; AND

    2. UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY, WHETHER IN TORT
       (INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE, SHALL THE AUTHOR,
       INITIAL WRITER, ANY CONTRIBUTOR, OR ANY DISTRIBUTOR OF THE DOCUMENT OR
       MODIFIED VERSION OF THE DOCUMENT, OR ANY SUPPLIER OF ANY OF SUCH
       PARTIES, BE LIABLE TO ANY PERSON FOR ANY DIRECT, INDIRECT, SPECIAL,
       INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY CHARACTER INCLUDING,
       WITHOUT LIMITATION, DAMAGES FOR LOSS OF GOODWILL, WORK STOPPAGE,
       COMPUTER FAILURE OR MALFUNCTION, OR ANY AND ALL OTHER DAMAGES OR
       LOSSES ARISING OUT OF OR RELATING TO USE OF THE DOCUMENT AND MODIFIED
       VERSIONS OF THE DOCUMENT, EVEN IF SUCH PARTY SHALL HAVE BEEN INFORMED
       OF THE POSSIBILITY OF SUCH DAMAGES.

   Feedback

   To report a bug or make a suggestion regarding the Genius Mathematics Tool
   application or this manual, follow the directions in the GNOME Feedback
   Page.

     ----------------------------------------------------------------------

   Table of Contents

   1. Introduction

   2. Getting Started

                2.1. To Start Genius Mathematics Tool

                2.2. When You Start Genius

   3. Basic Usage

                3.1. Using the Work Area

                3.2. To Create a New Program

                3.3. To Open and Run a Program

   4. Plotting

                4.1. Line Plots

                4.2. Parametric Plots

                4.3. Surface Plots

   5. GEL Basics

                5.1. Values

                             5.1.1. Numbers

                             5.1.2. Booleans

                             5.1.3. Strings

                             5.1.4. Null

                5.2. Using Variables

                             5.2.1. Setting Variables

                             5.2.2. Built-in Variables

                             5.2.3. Previous Result Variable

                5.3. Using Functions

                             5.3.1. Defining Functions

                             5.3.2. Variable Argument Lists

                             5.3.3. Passing Functions to Functions

                             5.3.4. Operations on Functions

                5.4. Absolute Value / Modulus

                5.5. Separator

                5.6. Modular Evaluation

                5.7. List of GEL Operators

   6. Programming with GEL

                6.1. Conditionals

                6.2. Loops

                             6.2.1. While Loops

                             6.2.2. For Loops

                             6.2.3. Foreach Loops

                             6.2.4. Break and Continue

                6.3. Sums and Products

                6.4. Comparison Operators

                6.5. Global Variables and Scope of Variables

                6.6. Returning

                6.7. References

                6.8. Lvalues

   7. Advanced Programming with GEL

                7.1. Error Handling

                7.2. Toplevel Syntax

                7.3. Returning Functions

                7.4. GEL Startup Procedure

                7.5. Loading Programs

   8. Matrices in GEL

                8.1. Entering Matrices

                8.2. Conjugate Transpose and Transpose Operator

                8.3. Linear Algebra

   9. Polynomials in GEL

                9.1. Using Polynomials

   10. Set Theory in GEL

                10.1. Using Sets

   11. List of GEL functions

                11.1. Commands

                11.2. Basic

                11.3. Parameters

                11.4. Constants

                11.5. Numeric

                11.6. Trigonometry

                11.7. Number Theory

                11.8. Matrix Manipulation

                11.9. Linear Algebra

                11.10. Combinatorics

                11.11. Calculus

                11.12. Functions

                11.13. Equation Solving

                11.14. Statistics

                11.15. Polynomials

                11.16. Set Theory

                11.17. Miscellaneous

                11.18. Symbolic Operations

                11.19. Plotting

   12. Example Programs in GEL

   13. Settings

                13.1. Output

                13.2. Precision

                13.3. Terminal

                13.4. Memory

   14. About Genius Mathematics Tool

   List of Figures

   2-1. Genius Mathematics Tool Window

   4-1. Create Plot Window

   4-2. Plot Window

   4-3. Parametric Plot Tab

   4-4. Parametric Plot

   4-5. Surface Plot

     ----------------------------------------------------------------------

                            Chapter 1. Introduction

   The Genius Mathematics Tool application is a general calculator for use as
   a desktop calculator, an educational tool in mathematics, and is useful
   even for research. The language used in Genius Mathematics Tool is
   designed to be `mathematical' in the sense that it should be `what you
   mean is what you get'. Of course that is not an entirely attainable goal.
   Genius Mathematics Tool features rationals, arbitrary precision integers
   and multiple precision floats using the GMP library. It handles complex
   numbers using cartesian notation. It has good vector and matrix
   manipulation and can handle basic linear algebra. The programming language
   allows user defined functions, variables and modification of parameters.

   Genius Mathematics Tool comes in two versions. One version is the
   graphical GNOME version, which features an IDE style interface and the
   ability to plot functions of one or two variables. The command line
   version does not require GNOME, but of course does not implement any
   feature that requires the graphical interface.

   This manual describes mostly the graphical version of the calculator, but
   the language is of course the same. The command line only version lacks
   the graphing capabilities and all other capabilities that require the
   graphical user interface.

     ----------------------------------------------------------------------

                           Chapter 2. Getting Started

2.1. To Start Genius Mathematics Tool

   You can start Genius Mathematics Tool in the following ways:

   Applications menu

           Depending on your operating system and version, the menu item for
           Genius Mathematics Tool could appear in a number of different
           places. It can be in the Education, Accessories, Office, Science,
           or similar submenu, depending on your particular setup. The menu
           item name you are looking for is Genius Math Tool. Once you locate
           this menu item click on it to start Genius Mathematics Tool.

   Run dialog

           Depending on your system installation the menu item may not be
           available. If it is not, you can open the Run dialog and execute
           gnome-genius.

   Command line

           To start the GNOME version of Genius Mathematics Tool execute
           gnome-genius from the command line.

           To start the command line only version, execute the following
           command: genius. This version does not include the graphical
           environment and some functionality such as plotting will not be
           available.

     ----------------------------------------------------------------------

2.2. When You Start Genius

   When you start the GNOME edition of Genius Mathematics Tool, the window
   pictured in Figure 2-1 is displayed.

   Figure 2-1. Genius Mathematics Tool Window

   The Genius Mathematics Tool window contains the following elements:

   Menubar.

           The menus on the menubar contain all of the commands that you need
           to work with files in Genius Mathematics Tool. The File menu
           contains items for loading and saving items and creating new
           programs. The Load and Run... command does not open a new window
           for the program, but just executes the program directly. It is
           equivalent to the load command.

           The Calculator menu controls the calculator engine. It allows you
           to run the currently selected program or to interrupt the current
           calculation. You can also look at the full expression of the last
           answer (useful if the last answer was too large to fit onto the
           console), or you can view a listing of the values of all user
           defined variables. Finally it allows plotting functions using a
           user friendly dialog box.

           The other menus have same familiar functions as in other
           applications.

   Toolbar.

           The toolbar contains a subset of the commands that you can access
           from the menubar.

   Working area

           The working area is the primary method of interacting with the
           application.

           The working area initially has just the Console tab which is the
           main way of interacting with the calculator. Here you type
           expressions and the results are immediately returned after you hit
           the Enter key.

           Alternatively you can write longer programs and those can appear
           in separate tabs and can be stored in files for later retrieval.

     ----------------------------------------------------------------------

                             Chapter 3. Basic Usage

3.1. Using the Work Area

   Normally you interact with the calculator in the Console tab of the work
   area. If you are running the text only version then the console will be
   the only thing that is available to you. If you want to use Genius
   Mathematics Tool as a calculator only, just type in your expression here
   and it willg et evaluated.

   Type your expression into the Console work area and press enter and the
   expression will be evaluated. Expressions are written in a language called
   GEL. The most simple GEL expression just looks like mathematics. For
   example

 genius> 30*70 + 67^3.0 + ln(7) * (88.8/100)

   or

 genius> 62734 + 812634 + 77^4 mod 5

   or

 genius> | sin(37) - e^7 |

   or

 genius> sum n=1 to 70 do 1/n

   (Last is the harmonic sum from 1 to 70)

   To get a list of functions and commands, type:

 genius> help

   If you wish to get more help on a specific function, type:

 genius> help FunctionName

   To view this manual, type:

 genius> manual

   Suppose you have previously saved some GEL commands as a program to a file
   and you now want to execute them. To load this program from the file
   path/to/program.gel, type

 genius> load path/to/program.gel

   Genius Mathematics Tool keeps track of the current directory. To list
   files in the current directory type ls, to change directory do cd
   directory as in the unix command shell.

     ----------------------------------------------------------------------

3.2. To Create a New Program

   To start writing a new program, choose File->New Program. A new tab will
   appear in the work area. You can write a GEL program in this work area.
   Once you have written your program you can run it by Calculator->Run. This
   will execute your program and will display any output on the Console tab.
   Executing a program is equivalent of taking the text of the program and
   typing it into the console. The only difference is that this input is done
   independent of the console and just the output goes onto the console.
   Calculator->Run will always run the currently selected program even if you
   are on the Console tab. The currently selected program has its tab in bold
   type. To select a program, just click on its tab.

   To save the program you've just written, choose File->Save As...

     ----------------------------------------------------------------------

3.3. To Open and Run a Program

   To open a file, choose File->Open. A new tab containing the file will
   appear in the work area. You can use this to edit the file.

   To run a program from a file, choose File->Load and Run.... This will run
   the program without opening it in a separate tab. This is equivalent to
   the load command.

     ----------------------------------------------------------------------

                              Chapter 4. Plotting

   Plotting support is only available in the graphical GNOME version. All
   plotting accessible from the graphical interface is available from the
   Create Plot window. You can access this window by either clicking on the
   Plot button on the toolbar or selecting Plot from the Calculator menu. You
   can also access the plotting functionality by using the plotting functions
   of the GEL language. See Chapter 5 to find out how to enter expressions
   that Genius understands.

     ----------------------------------------------------------------------

4.1. Line Plots

   To graph real valued functions of one variable open the Create Plot
   window. You can also use the LinePlot function on the command line (see
   its documentation).

   Once you click the Plot button, a window opens up with some notebooks in
   it. You want to be in the Function line plot notebook tab, and inside you
   want to be on the Functions / Expressions notebook tab. See Figure 4-1.

   Figure 4-1. Create Plot Window

   Into the text boxes just type in expressions where x is the independent
   variable. You can also just give names of functions such as cos rather
   then having to type cos(x). You can graph up to ten functions. If you make
   a mistake and Genius cannot parse the input it will signify this with a
   warning icon on the right of the text input box where the error occurred,
   as well as giving you an error dialog. You can change the ranges of the
   dependent and independent variables in the bottom part of the dialog.
   Pressing the Plot button produces the graph shown in Figure 4-2.

   Figure 4-2. Plot Window

   From here you can print out the plot, create encapsulated postscript or a
   PNG version of the plot or change the zoom. If the dependent axis was not
   set correctly you can have Genius fit it by finding out the extrema of the
   graphed functions.

   For plotting using the command line see the documentation of the LinePlot
   function.

     ----------------------------------------------------------------------

4.2. Parametric Plots

   In the create plot window, you can also choose the Parametric notebook tab
   to create two dimensional parametric plots. This way you can plot a single
   parametric function. You can either specify the points as x and y, or
   giving a single complex number. See Figure 4-3.

   Figure 4-3. Parametric Plot Tab

   An example of a parametric plot is given in Figure 4-3. Similar operations
   can be done on such graphs as can be done on the other line plots. For
   plotting using the command line see the documentation of the
   LinePlotParametric or LinePlotCParametric function.

   Figure 4-4. Parametric Plot

     ----------------------------------------------------------------------

4.3. Surface Plots

   Genius can also plot surfaces. Select the Surface plot tab in the main
   notebook of the Create Plot window. Here you can specify a single
   expression which should use either x and y as real independent variables
   or z as a complex variable (where x is the real part of z and y is the
   imaginary part). For example to plot the modulus of the cosine function
   for complex parameters, you could enter |cos(z)|. This would be equivalent
   to |cos(x+1i*y)|. See Figure 4-5. For plotting using the command line see
   the documentation of the SurfacePlot function.

   Figure 4-5. Surface Plot

     ----------------------------------------------------------------------

                             Chapter 5. GEL Basics

   GEL stands for Genius Extension Language. It is the language you use to
   write programs in Genius. A program in GEL is simply an expression that
   evaluates to a number. Genius Mathematics Tool can therefore be used as a
   simple calculator, or as a powerful theoretical research tool. The syntax
   is meant to have as shallow of a learning curve as possible, especially
   for use as a calculator.

     ----------------------------------------------------------------------

5.1. Values

   Values in GEL can be numbers, Booleans or strings. Values can be used in
   calculations, assigned to variables and returned from functions, among
   other uses.

     ----------------------------------------------------------------------

  5.1.1. Numbers

   Integers are the first type of number in GEL. Integers are written in the
   normal way.

 1234

   Hexidecimal and octal numbers can be written using C notation. For
   example:

 0x123ABC
 01234

   Or you can type numbers in an arbitrary base using <base>\<number>. Digits
   higher than 10 use letters in a similar way to hexadecimal. For example, a
   number in base 23 could be written:

 23\1234ABCD

   The second type of GEL number is rationals. Rationals are simply achieved
   by dividing two integers. So one could write:

 3/4

   to get three quarters. Rationals also accept mixed fraction notation. So
   in order to get one and three tenths you could write:

 1 3/10

   The next type if number is floating point. These are entered in a similar
   fashion to C notation. You can use E, e or @ as the exponent delimiter.
   Note that using the exponent delimiter gives a float even if there is no
   decimal point in the number. Examples:

 1.315
 7.887e77
 7.887e-77
 .3
 0.3
 77e5

   When Genius prints a floating point number it will always append a .0 even
   if the number is whole. This is to indicate that floating point numbers
   are taken as imprecise quantities. When a number is written in the
   scientific notation, it is always a floating point number and thus Genius
   does not print the .0.

   The final type of number in gel is the complex numbers. You can enter a
   complex number as a sum of real and imaginary parts. The imaginary part
   ends with an i. Here are examples of entering complex numbers:

 1+2i
 8.01i
 77*e^(1.3i)

   Important When entering imaginary numbers, a number must be in front of    
             the i. If you use i by itself, Genius will interpret this as     
             referring to the variable i. If you need to refer to i by        
             itself, use 1i instead.                                          
                                                                              
             In order to use mixed fraction notation with imaginary numbers   
             you must have the mixed fraction in parentheses. (i.e., (1       
             2/5)i)                                                           

     ----------------------------------------------------------------------

  5.1.2. Booleans

   Genius also supports native Boolean values. The two Boolean constants are
   defined as true and false; these identifiers can be used like any other
   variable. You can also use the identifiers True, TRUE, False and FALSE as
   aliases for the above.

   At any place where a Boolean expression is expected, you can use a Boolean
   value or any expression that produces either a number or a Boolean. If
   Genius needs to evaluate a number as a Boolean it will interpret 0 as
   false and any other number as true.

   In addition, you can do arithmetic with Boolean values. For example:

 ( (1 + true) - false ) * true

   is the same as:

 ( (true or true) or not false ) and true

   Only addition, subtraction and multiplication are supported. If you mix
   numbers with Booleans in an expression then the numbers are converted to
   Booleans as described above. This means that, for example:

 1 == true

   always evaluates to true since 1 will be converted to true before being
   compared to true.

     ----------------------------------------------------------------------

  5.1.3. Strings

   Like numbers and Booleans, strings in GEL can be stored as values inside
   variables and passed to functions. You can also concatenate a string with
   another value using the plus operator. For example:

 a=2+3;"The result is: "+a

   will create the string:

 The result is: 5

   You can also use C-like escape sequences such as \n,\t,\b,\a and \r. To
   get a \ or " into the string you can quote it with a \. For example:

 "Slash: \\ Quotes: \" Tabs: \t1\t2\t3"

   will make a string:

 Slash: \ Quotes: " Tabs:        1       2       3

   In addition, you can use the library function string to convert anything
   to a string. For example:

 string(22)

   will return

 "22"

   Strings can also be compared with == (equal), != (not equal) and <=>
   (comparison) operators

     ----------------------------------------------------------------------

  5.1.4. Null

   There is a special value called null. No operations can be performed on
   it, and nothing is printed when it is returned. Therefore, null is useful
   when you do not want output from an expression. The value null can be
   obtained as an expression when you type ., the contant null or nothing. By
   nothing we mean that if you end an expression with a separator ;, it is
   equivalent to ending it with a separator followed by a null.

   Example:

 x=5;.
 x=5;

   Some functions return null when no value can be returned or an error
   happened. Also null is used as an empty vector or matrix, or an empty
   reference.

     ----------------------------------------------------------------------

5.2. Using Variables

   Syntax:

 VariableName

   Example:

 genius> e
 = 2.71828182846

   To evaluate a variable by itself, just enter the name of the variable.
   This will return the value of the variable. You can use a variable
   anywhere you would normally use a number or string. In addition, variables
   are necessary when defining functions that take arguments (see Section
   5.3.1).

   Tip Using Tab completion                                                   
       You can use Tab completion to get Genius to complete variable names    
       for you. Try typing the first few letters of the name and pressing     
       Tab.                                                                   

   Important Variable names are case sensitive                                
             The names of variables are case sensitive. That means that       
             variables named hello, HELLO and Hello are all different         
             variables.                                                       

     ----------------------------------------------------------------------

  5.2.1. Setting Variables

   Syntax:

 <identifier> = <value>
 <identifier> := <value>

   Example:

 x = 3
 x := 3

   To assign to a variable, use the = or := operators. These operators set
   the value of the variable and return the number you set, so you can do
   things like

 a = b = 5

   The = and := operators can both be used to set variables. The difference
   between them is that the := operator always acts as an assignment
   operator, whereas the = operator may be interpreted as testing for
   equality when used in a context where a Boolean expression is expected.

   For issues regarding the scope of variables, see Section 6.5.

     ----------------------------------------------------------------------

  5.2.2. Built-in Variables

   GEL has a number of built-in `variables', such as e, pi or GoldenRatio.
   These are widely used constants with a preset value, and they cannot be
   assigned new values. There are a number of other built-in variables. See
   Section 11.4 for a full list.

     ----------------------------------------------------------------------

  5.2.3. Previous Result Variable

   The Ans and ans variables can be used to get the result of the last
   expression. For example, if you had performed some calculation, to add 389
   to the result you could do:

 Ans+389

     ----------------------------------------------------------------------

5.3. Using Functions

   Syntax:

 FunctionName(argument1, argument2, ...)

   Example:

 Factorial(5)
 cos(2*pi)
 gcd(921,317)

   To evaluate a function, enter the name of the function, followed by the
   arguments (if any) to the function in parentheses. This will return the
   result of applying the function to its arguments. The number of arguments
   to the function is, of course, different for each function.

   There are many built-in functions, such as sin, cos and tan. You can use
   the help built-in function to get a list of available functions, or see
   Chapter 11 for a full listing.

   Tip Using Tab completion                                                   
       You can use Tab completion to get Genius to complete function names    
       for you. Try typing the first few letters of the name and pressing     
       Tab.                                                                   

   Important Function names are case sensitive                                
             The names of functions are case sensitive. That means that       
             functions named dosomething, DOSOMETHING and DoSomething are all 
             different functions.                                             

     ----------------------------------------------------------------------

  5.3.1. Defining Functions

   Syntax:

 function <identifier>(<comma separated arguments>) = <function body>
 <identifier> = (`() = <function body>)

   The ` is the backquote character, and signifies an anonymous function. By
   setting it to a variable name you effectively define a function.

   A function takes zero or more comma separated arguments, and returns the
   result of the function body. Defining your own functions is primarily a
   matter of convenience; one possible use is to have sets of functions
   defined in GEL files which Genius can load in order to make available.
   Example:

 function addup(a,b,c) = a+b+c

   then addup(1,4,9) yields 14

     ----------------------------------------------------------------------

  5.3.2. Variable Argument Lists

   If you include ... after the last argument name in the function
   declaration, then Genius will allow any number of arguments to be passed
   in place of that argument. If no arguments were passed then that argument
   will be set to null. Otherwise, it will be a horizontal vector containing
   all the arguments. For example:

 function f(a,b...) = b

   Then f(1,2,3) yields [2,3], while f(1) yields a null.

     ----------------------------------------------------------------------

  5.3.3. Passing Functions to Functions

   In Genius, it is possible to pass a function as an argument to another
   function. This can be done using either `function nodes' or anonymous
   functions.

   If you do not enter the parentheses after a function name, instead of
   being evaluated, the function will instead be returned as a `function
   node'. The function node can then be passed to another function. Example:

 function f(a,b) = a(b)+1;
 function b(x) = x*x;
 f(b,2)

   If you want to pass a function that doesn't exist yet, you can use an
   anonymous function (see Section 5.3.1).

   Syntax:

 function(<comma separated arguments>) = <function body>
 `(<comma separated arguments>) = <function body>

   Example:

 function f(a,b) = a(b)+1;
 f(`(x) = x*x,2)

     ----------------------------------------------------------------------

  5.3.4. Operations on Functions

   Some functions allow arithmetic operations, and some single argument
   functions such as exp or ln, to operate on the function. For example,

 exp(sin*cos+4)

   will return a function that does

 exp(sin(x)*cos(x)+4)

   This can be useful when quickly defining functions. For example to create
   a function to perform the above operation, you can just type:

 f = exp(sin*cos+4)

   This can also be used in plotting. For example, to plot sin squared you
   can enter:

 LinePlot(sin^2)

   Warning Not all functions can be used in this way. In addition, when you   
           use a binary operation the functions must take the same arguments. 

     ----------------------------------------------------------------------

5.4. Absolute Value / Modulus

   You can make an absolute value of something by putting the |'s around it.
   For example:

 |a-b|

   In case the expression is a complex number the result will be the modulus
   (distance from the origin). For example: |3 * e^(1i*pi)| returns 3.

     ----------------------------------------------------------------------

5.5. Separator

   In GEL if you want to type more than one command you have to use the ;
   operator, which is a way to separate expressions, such a combined
   expression will return whatever is the result of the last one, so suppose
   you type the following:

 3 ; 5

   This expression will yield 5.

   This will require some parenthesizing to make it unambiguous sometimes,
   especially if the ; is not the top most primitive. This slightly differs
   from other programming languages where the ; is a terminator of
   statements, whereas in GEL it's actually a binary operator. If you are
   familiar with pascal this should be second nature. However genius can let
   you pretend it is a terminator somewhat, if a ; is found at the end of a
   parenthesis or a block, genius will itself append a null node to it as if
   you would have written ;null. This is usefull in case you do not want to
   return a value from say a loop, or if you handle the return differently.
   Note that it will slightly slow down the code if it is executed too often
   as there is one more operator involved.

     ----------------------------------------------------------------------

5.6. Modular Evaluation

   Sometimes when working with large numbers, it might be faster if results
   are modded after each calculation. To use it you just add "mod <integer>"
   after the expression. Example:

 2^(5!) * 3^(6!) mod 5

   You can calculate the inverses of numbers mod some integer by just using
   rational numbers (of course the inverse has to exist). Examples:

 10^-1 mod 101
 1/10 mod 101

   You can also do modular evaluation with matrices including taking
   inverses, powers and dividing. Example:

 A = [1,2;3,4]
 B = A^-1 mod 5
 A*B mod 5

   This should yield the identity matrix as B will be the inverse of A mod 5.

   Some functions such as sqrt or log work in a different way when in modulo
   mode. These will then work like their discrete versions working within the
   ring of integers you selected. For example:

 genius> sqrt(4) mod 7
 =
 [2, 5]
 genius> 2*2 mod 7
 = 4

   sqrt will actually return all the possible square roots.

     ----------------------------------------------------------------------

5.7. List of GEL Operators

   As everything in gel is really just an expression, it is really just all
   connected together with operators. Here is a list of the operators in GEL.

 a;b

           The separator, just evaluates both a and b, but returns only the
           result of b.

 a=b

           The assignment operator. This assigns b to a (a must be a valid
           lvalue) (note however that this operator may be translated to ==
           if used in a place where boolean expression is expected)

 a:=b

           The assignment operator. Assigns b to a (a must be a valid
           lvalue). This is different from = because it never gets translated
           to a ==.

 |a|

           Absolute value or modulus (if a is a complex number).

           See Mathworld for more information.

 a^b

           Exponentiation, raises a to the bth power.

 a.^b

           Element by element exponentiation. Raise each element of a matrix
           a to the bth power. Or if b is a matrix of the same size as a,
           then do the operation element by element. If a is a number and b
           is a matrix then it creates matrix of the same size as b with a
           raised to all the different powers in b.

 a+b

           Addition. Adds two numbers, matrices, functions or strings. If you
           add a string to anything the result will just be a string.

 a-b

           Subtraction. Subtract two numbers, matrices or functions.

 a*b

           Multiplication. This is the normal matrix multiplication.

 a.*b

           Element by element multiplication if a and b are matrices.

 a/b

           Division.

 a./b

           Element by element division.

 a\b

           Back division. That is this is the same as b/a.

 a.\b

           Element by element back division.

 a%b

           The mod operator. This does not turn on the modular mode, but just
           returns the remainder of a/b.

 a.%b

           Element by element the mod operator. Returns the remaineder after
           element by element a./b.

 a mod b

           Modular evaluation operator. The expression a is evaluated modulo
           b. See Section 5.6. Some functions and operators behave
           differently modulo an integer.

 a!

           Factorial operator. This is like 1*...*(n-2)*(n-1)*n.

 a!!

           Double factorial operator. This is like 1*...*(n-4)*(n-2)*n.

 a==b

           Equality operator (returns true or false).

 a!=b

           Inequality operator, returns true if a does not equal b else
           returns false.

 a<>b

           Alternative inequality operator, returns true if a does not equal
           b else returns false.

 a<=b

           Less than or equal operator, returns true if a is less than or
           equal to b else returns false.

 a>=b

           Greater than or equal operator, returns true if a is greater than
           or equal to b else returns false.

 a<=>b

           Comparison operator. If a is equal to b it returns 0, if a is less
           than b it returns -1 and if a is greater than b it returns 1.

 a and b

           Logical and.

 a or b

           Logical or.

 a xor b

           Logical xor.

 not a

           Logical not.

 -a

           Negation operator.

 &a

           Variable referencing (to pass a reference to something). See
           Section 6.7.

 *a

           Variable dereferencing (to access a referenced varible). See
           Section 6.7.

 a'

           Matrix conjugate transpose.

 a.'

           Matrix transpose, does not conjugate the entries.

 a@(b,c)

           Get element of a matrix in row b and column c. If b, c are
           vectors, then this gets the corresponding rows columns or
           submatrices.

 a@(b,)

           Get row of a matrix (or rows if b is a vector).

 a@(b,:)

           Same as above.

 a@(,c)

           Get column of a matrix (or columns if c is a vector).

 a@(:,c)

           Same as above.

 a@(b)

           Get an element from a matrix treating it as a vector. This will
           traverse the matrix row-wise.

 a:b

           Build a vector from a to b (or specify a row, column region for
           the @ operator). For example to get rows 2 to 4 of mamtrix A we
           could do

 A@(2:4,)
             

           as 2:4 will return a vector [2,3,4].

 a:b:c

           Build a vector from a to c with b as a step. That is for example

 genius> 1:2:9
 =
 `[1, 3, 5, 7, 9]

 (a)i

           Make a imaginary number (multiply a by the imaginary). Note that
           normally the number i is written as 1i. So the above is equal to

 (a)*1i
             

 `a

           Quote an identifier so that it doesn't get evaluated. Or quote a
           matrix so that it doesn't get expanded.

   Note The @() operator makes the : operator most useful. With this you can  
        specify regions of a matrix. So that a@(2:4,6) is the rows 2,3,4 of   
        the column 6. Or a@(,1:2) will get you the first two columns of a     
        matrix. You can also assign to the @() operator, as long as the right 
        value is a matrix that matches the region in size, or if it is any    
        other type of value.                                                  

   Note The comparison operators (except for the <=> operator which behaves   
        normally), are not strictly binary operators, they can in fact be     
        grouped in the normal mathematical way, e.g.: (1<x<=y<5) is a legal   
        boolean expression and means just what it should, that is (1<x and    
        x=<y and y<5)                                                         

   Note The unitary minus operates in a different fashion depending on where  
        it appears. If it appears before a number it binds very closely, if   
        it appears in front of an expression it binds less than the power and 
        factorial operators. So for example -1^k is really (-1)^k, but        
        -foo(1)^k is really -(foo(1)^k). So be careful how you use it and if  
        in doubt, add parentheses.                                            

     ----------------------------------------------------------------------

                        Chapter 6. Programming with GEL

6.1. Conditionals

   Syntax:

 if <expression1> then <expression2> [else <expression3>]

   If else is omitted, then if the expression1 yields false or 0, NULL is
   returned.

   Examples:

 if(a==5)then(a=a-1)
 if b<a then b=a
 if c>0 then c=c-1 else c=0
 a = ( if b>0 then b else 1 )

   Note that = will be translated to == if used inside the expression for if,
   so

 if a=5 then a=a-1

   will be interpreted as:

 if a==5 then a:=a-1

     ----------------------------------------------------------------------

6.2. Loops

  6.2.1. While Loops

   Syntax:

 while <expression1> do <expression2>
 until <expression1> do <expression2>
 do <expression2> while <expression1>
 do <expression2> until <expression1>

   These are similiar to other languages, however they return the result of
   the last iteration or NULL if no iteration was done. In the boolean
   expression, = is translated into == just as for the if statement.

     ----------------------------------------------------------------------

  6.2.2. For Loops

   Syntax:

 for <identifier> = <from> to <to> do <body>
 for <identifier> = <from> to <to> by <increment> do <body>

   Loop with identifier being set to all values from <from> to <to>,
   optionally using an increment other than 1. These are faster, nicer and
   more compact than the normal loops such as above, but less flexible. The
   identifier must be an identifier and can't be a dereference. The value of
   identifier is the last value of identifier, or <from> if body was never
   evaluated. The variable is guaranteed to be initialized after a loop, so
   you can safely use it. Also the <from>, <to> and <increment> must be non
   complex values. The <to> is not guaranteed to be hit, but will never be
   overshot, for example the following prints out odd numbers from 1 to 19:

 for i = 1 to 20 by 2 do print(i)

     ----------------------------------------------------------------------

  6.2.3. Foreach Loops

   Syntax:

 for <identifier> in <matrix> do <body>

   For each element, going row by row from left to right do the body. To
   print numbers 1,2,3 and 4 in this order you could do:

 for n in [1,2:3,4] do print(n)

   If you wish to run through the rows and columns of a matrix, you can use
   the RowsOf and ColumnsOf functions which return a vector of the rows or
   columns of the matrix. So,

 for n in RowsOf ([1,2:3,4]) do print(n)

   will print out [1,2] and then [3,4].

     ----------------------------------------------------------------------

  6.2.4. Break and Continue

   You can also use the break and continue commands in loops. The continue
   continue command will restart the current loop at its next iteration,
   while the break command exits the current loop.

 while(<expression1>) do (
   if(<expression2>) break
   else if(<expression3>) continue;
   <expression4>
 )

     ----------------------------------------------------------------------

6.3. Sums and Products

   Syntax:

 sum <identifier> = <from> to <to> do <body>
 sum <identifier> = <from> to <to> by <increment> do <body>
 sum <identifier> in <matrix> do <body>
 prod <identifier> = <from> to <to> do <body>
 prod <identifier> = <from> to <to> by <increment> do <body>
 prod <identifier> in <matrix> do <body>

   If you substitute for with sum or prod, then you will get a sum or a
   product instead of a for loop. Instead of returning the last value, these
   will return the sum or the product of the values respectively.

   If no body is executed (for example sum i=1 to 0 do ...) then sum returns
   0 and prod returns 1 as is the standard convention.

     ----------------------------------------------------------------------

6.4. Comparison Operators

   The following standard comparison operators are supported in GEL and have
   the obvious meaning: ==, >=, <=, !=, <>, <, >. They return true or false.
   The operators != and <> are the same thing and mean "is not equal to". GEL
   also supports the operator <=>, which returns -1 if left side is smaller,
   0 if both sides are equal, 1 if left side is larger.

   Normally = is translated to == if it happens to be somewhere where GEL is
   expecing a condition such as in the if condition. For example

 if a=b then c
 if a==b then c

   are the same thing in GEL. However you should really use == or := when you
   want to compare or assign respectively if you want your code to be easy to
   read and to avoid mistakes.

   All the comparison operators (except for the <=> operator which behaves
   normally), are not strictly binary operators, they can in fact be grouped
   in the normal mathematical way, e.g.: (1<x<=y<5) is a legal boolean
   expression and means just what it should, that is (1<x and x=<y and y<5)

   To build up logical expressions use the words not, and, or, xor. The
   operators or and and are special beasts as they evaluate their arguemnts
   one by one, so the usual trick for conditional evaluation works here as
   well. For example, 1 or a=1 will not set a=1 since the first argument was
   true.

     ----------------------------------------------------------------------

6.5. Global Variables and Scope of Variables

   Like most programming languages, GEL has two different types of variables:
   local and global. A local variable only exists in the context of the
   function where it is set and all functions called from inside this
   function. A global variable exists in all contexts. When you set a
   variable on the toplevel command line, outside of any function, then it
   will be a global. All functions will see it.

   When you set a variable inside a function, it will only be seen inside the
   function, including all function calls that are made inside this function.
   This is where GEL differs from a language such as C. One could describe
   local variables as being semi global in this sense. For example the
   following code will print out 5. but the function g cannot be called on
   the top level as a will not be defined.

 function f() = (a:=5; g());
 function g() = print(a);
 f();

   Suppose you assign a value to an identifier inside a function, and this
   identifier is also used for a global variable, or a variable set in a
   calling function. Then this has the effect of creating a new local
   variable inside the function. For example the following code will print
   out 6 and not 5.

 a=6;
 function f() = (a:=5);
 print(a);

   Sometimes however it is neccessary to set a global variable from inside a
   function. For this, use the set function. Passing a string or a quoted
   identifier to this function sets the variable globally. For example, to
   set a to the value 3 you could call:

 set(`a,3)

   or:

 set("a",3)

   The set function always sets the toplevel global. There is no way to set a
   local variable in some function from a subroutine. For this you must use
   passing by reference.

     ----------------------------------------------------------------------

6.6. Returning

   Normally a function is one or several expressions separated by a
   semicolon, and the value of the last expression is returned. This is fine
   for simple functions, but sometimes you do not want a function to return
   the last thing calculated. You may, for example, want to return from a
   middle of a function. In this case, you can use the return keyword. return
   takes one argument, which is the value to be returned.

   Example:

 function f(x) = (
   y=1;
   while true do (
     if x>50 then return y;
     y=y+1;
     x=x+1
   )
 )

     ----------------------------------------------------------------------

6.7. References

   It may be neccessary for some functions to return more than one value.
   This may be accomplished by returning a vector of values, but many times
   it is convenient to use passing a reference to a variable. You pass a
   reference to a variable to a function, and the function will set the
   variable for you using a dereference. You do not have to use references
   only for this purpose, but this is their main use.

   When using functions which return values through references in the
   argument list, just pass the variable name with an ampersand. For example
   the following code will compute an eigenvalue of a matrix A with initial
   eigenvector guess x, and store the computed eigenvector into the variable
   named v:

 RayleighQuotientIteration (A,x,0.001,100,&v)

   The details of how references work and the syntax is similar to the C
   language. The operator & references a variable and * dereferences a
   variable. Both can only be applied to an identifier, so **a is not a legal
   expression in GEL.

   References are best explained by an example:

 a=1;
 b=&a;
 *b=2;

   now a contains 2. You can also reference functions:

 function f(x) = x+1;
 t=&f;
 *t(3)

   gives us 4.

     ----------------------------------------------------------------------

6.8. Lvalues

   An lvalue is the left hand side of an assignment. In other words, an
   lvalue is what you assign something to. Valid lvalues are:

   a

           Identifier. Here we would be setting the varable of name a.

   *a

           Dereference of an identifier. This will set whatever variable a
           points to.

   a@(<region>)

           A region of a matrix. Here the region is specified normally as
           with the regular @() operator, and can be a single entry, or an
           entire region of the matrix.

   Examples:

 a:=4
 *tmp := 89
 a@(1,1) := 5
 a@(4:8,3) := [1,2,3,4,5]'

   Note that both := and = can be used interchangably. Except if the
   assignment appears in a condition. It is thus always safer to just use :=
   when you mean assignment, and == when you mean comparison.

     ----------------------------------------------------------------------

                    Chapter 7. Advanced Programming with GEL

7.1. Error Handling

   If you detect an error in your function, you can bail out of it. For
   normal errors, such as wrong types of arguments, you can fail to compute
   the function by adding the statement bailout. If something went really
   wrong and you want to completely kill the current computation, you can use
   exception.

   For example if you want to check for arguments in your function. You could
   use the following code.

 function f(M) = (
   if not IsMatrix (M) then (
     error ("M not a matrix!");
     bailout
   );
   ...
 )

     ----------------------------------------------------------------------

7.2. Toplevel Syntax

   The synatax is slightly different if you enter statements on the top level
   versus when they are inside parentheses or inside functions. On the top
   level, enter acts the same as if you press return on the command line.
   Therefore think of programs as just sequence of lines as if were entered
   on the command line. In particular, you do not need to enter the separator
   at the end of the line (unless it is of course part of several statements
   inside parenteses).

   The following code will produce an error when entered on the top level of
   a program, while it will work just fine in a function.

 if Something() then
   DoSomething()
 else
   DoSomethingElse()

   The problem is that after Genius Mathematics Tool sees the end of line
   after the second line, it will decide that we have whole statement and it
   will execute it. After the execution is done, Genius Mathematics Tool will
   go on to the next line, it will see else, and it will produce a parsing
   error. To fix this, use parentheses. Genius Mathematics Tool will not be
   satisfied until it has found that all parenteses are closed.

 if Something() then (
   DoSomething()
 ) else (
   DoSomethingElse()
 )

     ----------------------------------------------------------------------

7.3. Returning Functions

   It is possible to return functions as value. This way you can build
   functions which construct special purpose functions according to some
   parameters. The tricky bit is what variables does the function see. The
   way this works in GEL is that when a function returns another function,
   all identifiers referenced in the function body are prepended a private
   dictionary of the returned function. So the function will see all
   variables that were in scope when it was defined. For example we define a
   function which returns a function which adds 5 to its argument.

 function f() = (
   k = 5;
   `(x) = (x+k)
 )

   Notice that the function adds k to x. You could use this as follows.

 g = f();
 g(5)

   And g(5) should return 10.

   One thing to note is that the value of k that is used is the one that's in
   effect when the f returns. So for example

 function f() = (
   k = 5;
   r = `(x) = (x+k);
   k = 10;
   r
 )

   will return a function that adds 10 to its argument rather than 5. This is
   because the extra dictionary is created only when the context in which the
   function was defined ends, which is when the function f returns. This is
   consistent with how you would expect the function r to work inside the
   function f according to the rules of scope of variables in GEL. Only those
   variables are added to the extra dictionary that are in the context that
   just ended and no longer exists. Variables used in the function that are
   in still valid contexts will work as usual, using the current value of the
   variable.

     ----------------------------------------------------------------------

7.4. GEL Startup Procedure

   First the program looks for the installed library file (the compiled
   version lib.cgel) in the installed directory, then it looks into the
   current directory, and then it tries to load an uncompiled file called
   ~/.geniusinit.

   If you ever change the the library its installed place, you'll have to
   first compile it with genius --compile loader.gel > lib.cgel

     ----------------------------------------------------------------------

7.5. Loading Programs

   Sometimes you have a larger program that you wrote into a file and want to
   read in that file. In these situations, you have two options. You can keep
   the functions you use most inside the ~/.geniusinit file. Or if you want
   to load up a file in a middle of a session (or from within another file),
   you can type load <list of filenames> at the prompt. This has to be done
   on the top level and not inside any function or whatnot, and it cannot be
   part of any expression. It also has a slightly different syntax than the
   rest of genius, more similiar to a shell. You can enter the file in
   quotes. If you use the '' quotes, you will get exactly the string that you
   typed, if you use the "" quotes, special characters will be unescaped as
   they are for strings. Example:

 load program1.gel program2.gel
 load "Weird File Name With SPACES.gel"

   There are also cd, pwd and ls commands built in. cd will take one
   argument, ls will take an argument which is like the glob in the unix
   shell (i.e., you can use wildcards). pwd takes no arguments. For example:

 cd directory_with_gel_programs
 ls *.gel

     ----------------------------------------------------------------------

                           Chapter 8. Matrices in GEL

   Genius has support for vectors and matrices and a sizable library of
   matrix manipulation and linear algebra functions.

     ----------------------------------------------------------------------

8.1. Entering Matrices

   To enter matrixes, you can use one of the following two syntaxes. You can
   either enter the matrix on one line, separating values by commas and rows
   by semicolons. Or you can enter each row on one line, separating values by
   commas. You can also just combine the two methods. So to enter a 3x3
   matrix of numbers 1-9 you could do

 [1,2,3;4,5,6;7,8,9]

   or

 [1, 2, 3
  4, 5, 6
  7, 8, 9]

   Do not use both ';' and return at once on the same line though.

   You can also use the matrix expansion functionality to enter matricies.
   For example you can do:

 a = [ 1, 2, 3
       4, 5, 6
       7, 8, 9]
 b = [ a,  10
       11, 12]

   and you should get

 [1,   2,  3, 10
  4,   5,  6, 10
  7,   8,  9, 10
  11, 11, 11, 12]

   similiarly you can build matricies out of vectors and other stuff like
   that.

   Another thing is that non-specified spots are initialized to 0, so

 [1, 2, 3
  4, 5
  6]

   will end up being

 [1, 2, 3
  4, 5, 0
  6, 0, 0]

   When matrices are evaluated, they are evaluated and traversed row-wise.
   This is just like the M@(j) operator which traverses the matrix row-wise.

   Note Be careful about using returns for expressions inside the [ ]         
        brackets, as they have a slightly different meaning there. You will   
        start a new row.                                                      

     ----------------------------------------------------------------------

8.2. Conjugate Transpose and Transpose Operator

   You can conjugate transpose a matrix by using the ' operator. That is the
   entry in the ith column and the jth row will be the complex conjugate of
   the entry in the jth column and the ith row of the original matrix. For
   example:

 [1,2,3]*[4,5,6]'

   We transpose the second vector to make matrix multiplication possible. If
   you just want to transpose a matrix without conjugating it, you would use
   the .' operator. For example:

 [1,2,3]*[4,5,6i].'

   Note that normal transpose, that is the .' operator, is much faster and
   will not create a new copy of the matrix in memory. The conjugate
   transpose does create a new copy unfortunately. It is recommended to
   always use the .' operator when working with real matrices and vectors.

     ----------------------------------------------------------------------

8.3. Linear Algebra

   Genius implements many useful linear algebra and matrix manipulation
   routines. See the Linear Algebra and Matrix Manipulation sections of the
   GEL function listing.

   The linear algebra routines implemented in GEL do not currently come from
   a well tested numerical package, and thus should not be used for critical
   numerical computation. On the other hand, Genius implements very well many
   linear algebra operations with rational and integer coefficients. These
   are inherently exact and in fact will give you much better results than
   common double precision routines for linear algebra.

   For example, it is pointless to compute the rank and nullspace of a
   floating point matrix since for all practical purposes, we need to
   consider the matrix as having some slight errors. You are likely to get a
   different result than you expect. The problem is that under a small
   perturbation every matrix is of full rank and invertible. If the matrix
   however is of rational numbers, then the rank and nullspace are always
   exact.

   In general when Genius computes the basis of a certain vectorspace (for
   example with the NullSpace) it will give the basis as a matrix, in which
   the columns are the vectors of the basis. That is, when Genius talks of a
   linear subspace it means a matrix whose column space is the given linear
   subspace.

   It should be noted that Genius can remember certain properties of a
   matrix. For example, it will remember that a matrix is in row reduced
   form. If many calls are made to functions which internally use row reduced
   form of the matrix, we can just row reduce the matrix beforehand once.
   Successive calls to rref will be very fast.

     ----------------------------------------------------------------------

                         Chapter 9. Polynomials in GEL

   Currently Genius can handle polynomials of one variable written out as
   vectors, and do some basic operations with these. It is planned to expand
   this support further.

     ----------------------------------------------------------------------

9.1. Using Polynomials

   Currently polynomials in one variable are just horizontal vectors with
   value only nodes. The power of the term is the position in the vector,
   with the first position being 0. So,

 [1,2,3]

   translates to a polynomial of

 1 + 2*x + 3*x^2

   You can add, subtract and multiply polynomials using the AddPoly,
   SubtractPoly, and MultiplyPoly functions respectively. You can print a
   polynomial using the PolyToString function. For example,

 PolyToString([1,2,3],"y")

   gives

 3*y^2 + 2*y + 1

   You can also get a function representation of the polynomial so that you
   can evaluate it. This is done by using PolyToFunction, which returns an
   anonymous function which you can assign to something.

 f = PolyToFunction([0,1,1])
 f(2)

   It is also possible to find roots of polynomials of degrees 1 through 4 by
   using the function PolynomialRoots, which calls the appropriate formula
   function. Higher degree polynomials must be converted to functions and
   solved numerically using a function such as FindRootBisection,
   FindRootFalsePosition, FindRootMullersMethod, or FindRootSecant.

   See Section 11.15 in the function list for the rest of functions acting on
   polynomials.

     ----------------------------------------------------------------------

                         Chapter 10. Set Theory in GEL

   Genius has some basic set theoretic functionality built in. Currently a
   set is just a vector (or a matrix). Every distinct object is treated as a
   different element.

     ----------------------------------------------------------------------

10.1. Using Sets

   Just like vectors, objects in sets can include numbers, strings, null,
   matrices and vectors. It is planned in the future to have a dedicated type
   for sets, rather than using vectors. Note that floating point numbers are
   distinct from integers, even if they appear the same. That is, Genius will
   treat 0 and 0.0 as two distinct elements. The null is treated as an empty
   set.

   To build a set out of a vector, use the MakeSet function. Currently, it
   will just return a new vector where every element is unique.

 genius> MakeSet([1,2,2,3])
 = [1, 2, 3]

   Similarly there are functions Union, Intersection, SetMinus, which are
   rather self explanatory. For example:

 genius> Union([1,2,3], [1,2,4])
 = [1, 2, 4, 3]

   Note that no order is guaranteed for the return values. If you wish to
   sort the vector you should use the SortVector function.

   For testing membership, there are functions IsIn and IsSubset, which
   return a boolean value. For example:

 genius> IsIn (1, [0,1,2])
 = true

   The input IsIn(x,X) is of course equivalent to IsSubset([x],X). Note that
   since the empty set is a subset of every set, IsSubset(null,X) is always
   true.

     ----------------------------------------------------------------------

                       Chapter 11. List of GEL functions

   To get help on a specific function from the console type:

 help FunctionName

     ----------------------------------------------------------------------

11.1. Commands

   help

 help

 help FunctionName

           Print help (or help on a function/command).

   load

 load "file.gel"

           Load a file into the interpretor. The file will execute as if it
           were typed onto the command line.

   cd

 cd /directory/name

           Change working directory to /directory/name.

   pwd

 pwd

           Print the current working directory.

   ls

 ls

           List files in the current directory.

   plugin

 plugin plugin_name

           Load a plugin. Plugin of that name must be installed on the system
           in the proper directory.

     ----------------------------------------------------------------------

11.2. Basic

   Compose

 Compose (f,g)

           Compose two functions and return a function that is the
           composition of f and g.

   ComposePower

 ComposePower (f,n,x)

           Compose and execute a function with itself n times, passing x as
           argument. Returning x if n equals 0. Example:

 genius> function f(x) = x^2 ;
 genius> ComposePower (f,3,7)
 = 5764801
 genius> f(f(f(7)))
 = 5764801

   GetCurrentModulo

 GetCurrentModulo

           Get current modulo from the context outside the function. That is,
           if outside of the function was executed in modulo (using mod) then
           this returns what this modulo was. Normally the body of the
           function called is not executed in modular arithmetic, and this
           builtin function makes it possible to make GEL functions aware of
           modular arithmetic.

   Identity

 Identity (x)

           Identity function, returns its argument.

   IntegerFromBoolean

 IntegerFromBoolean (bval)

           Make integer (0 for false or 1 for true) from a boolean value.
           bval can also be a number in which case a non-zero value will be
           interpreted as true and zero will be interpretted as false.

   IsBoolean

 IsBoolean (arg)

           Check if argument is a boolean (and not a number).

   IsDefined

 IsDefined (id)

           Check if an id is defined. You should pass a string or and
           identifier. If you pass a matrix, each entry will be evaluated
           separately and the matrix should contain strings or identifiers.

   IsFunction

 IsFunction (arg)

           Check if argument is a function.

   IsFunctionOrIdentifier

 IsFunctionOrIdentifier (arg)

           Check if argument is a function or an identifier.

   IsFunctionRef

 IsFunctionRef (arg)

           Check if argument is a function reference. This includes variable
           references.

   IsMatrix

 IsMatrix (arg)

           Check if argument is a matrix. Even though null is sometimes
           considered an empty matrix, the function IsMatrix does not
           consider null a matrix.

   IsNull

 IsNull (arg)

           Check if argument is a null.

   IsString

 IsString (arg)

           Check if argument is a text string.

   IsValue

 IsValue (arg)

           Check if argument is a number.

   SetFunctionFlags

 SetFunctionFlags (id,flags...)

           Set flags for a function, currently "PropagateMod" and
           "NoModuloArguments". If "PropagateMod" is set, then the body of
           the function is evaluated in modular arithmetic when the function
           is called inside a block that was evaluated using modular
           arithmetic (using mod). If "NoModuloArguments", then the arguments
           of the function are never evaluated using modular arithmetic.

   SetHelp

 SetHelp (id,category,desc)

           Set the category and help description line for a function.

   SetHelpAlias

 SetHelpAlias (id,alias)

           Sets up a help alias.

   chdir

 chdir (dir)

           Changes current directory, same as the cd.

   display

 display (str,expr)

           Display a string and an expression with a colon to separate them.

   error

 error (str)

           Prints a string to the error stream (onto the console).

   exit

 exit

           Aliases: quit

           Exits the program.

   false

 false

           Aliases: False FALSE

           The false boolean value.

   manual

 manual

           Displays the user manual.

   print

 print (str)

           Prints an expression and then print a newline. The argument str
           can be any expression. It is made into a string before being
           printed.

   printn

 printn (str)

           Prints an expression without a trailing newline. The argument str
           can be any expression. It is made into a string before being
           printed.

   protect

 protect (id)

           Protect a variable from being modified. This is used on the
           internal GEL functions to avoid them being accidentally
           overridden.

   set

 set (id,val)

           Set a global variable. The id can be either a string or a quoted
           identifier as follows. For example:

 set(`x,1)
            

           will set the global variable x to the value 1.

   string

 string (s)

           Make a string. This will make a string out of any argument.

   true

 true

           Aliases: True TRUE

           The true boolean value.

   undefine

 undefine (id)

           Undefine a variable. This includes locals and globals, every value
           on all context levels is wiped. This function should really not be
           used on local variables.

   unprotect

 unprotect (id)

           Unprotect a variable from being modified.

   wait

 wait (secs)

           Waits a specified number of seconds. secs must be nonnegative.
           Zero is accepted and nothing happens in this case, except possibly
           user interface events are processed.

   version

 version

           Returns the version of Genius as a horizontal 3-vector with major
           version first, then minor version and finally patchlevel.

   warranty

 warranty

           Gives the warranty information.

     ----------------------------------------------------------------------

11.3. Parameters

   ChopTolerance

 ChopTolerance = number

           Tolerance of the Chop function.

   ContinuousNumberOfTries

 ContinuousNumberOfTries = number

           How many iterations to try to find the limit for continuity and
           limits.

   ContinuousSFS

 ContinuousSFS = number

           How many successive steps to be within tolerance for calculation
           of continuity.

   ContinuousTolerance

 ContinuousTolerance = number

           Tolerance for continuity of functions and for calculating the
           limit.

   DerivativeNumberOfTries

 DerivativeNumberOfTries = number

           How many iterations to try to find the limit for derivative.

   DerivativeSFS

 DerivativeSFS = number

           How many successive steps to be within tolerance for calculation
           of derivative.

   DerivativeTolerance

 DerivativeTolerance = number

           Tolerance for calculating the derivatives of functions.

   ErrorFunctionTolerance

 ErrorFunctionTolerance = number

           Tolerance of the ErrorFunction.

   FloatPrecision

 FloatPrecision = number

           Floating point precision.

   FullExpressions

 FullExpressions = boolean

           Print full expressions, even if more than a line.

   GaussDistributionTolerance

 GaussDistributionTolerance = number

           Tolerance of the GaussDistribution function.

   IntegerOutputBase

 IntegerOutputBase = number

           Integer output base.

   IsPrimeMillerRabinReps

 IsPrimeMillerRabinReps = number

           Number of extra Miller-Rabin tests to run on a number before
           declaring it a prime in IsPrime.

   LinePlotWindow

 LinePlotWindow = [x1,x2,y1,y2]

           Sets the limits for line plotting (See LinePlot).

   MaxDigits

 MaxDigits = number

           Maximum digits to display.

   MaxErrors

 MaxErrors = number

           Maximum errors to display.

   MixedFractions

 MixedFractions = boolean

           If true, mixed fractions are printed.

   NumericalIntegralFunction

 NumericalIntegralFunction = function

           The function used for numerical integration in NumericalIntegral.

   NumericalIntegralSteps

 NumericalIntegralSteps = number

           Steps to perform in NumericalIntegral.

   OutputChopExponent

 OutputChopExponent = number

           When another number in the object being printed (a matrix or a
           value) is greater than 10-OutputChopWhenExponent, and the number
           being printed is less than 10-OutputChopExponent, then display 0.0
           instead of the number.

           Output is never chopped if OutputChopExponent is zero. It must be
           a nonnegative integer.

           If you want output always chopped according to OutputChopExponent,
           then set OutputChopWhenExponent, to something greater than or
           equal to OutputChopExponent.

   OutputChopWhenExponent

 OutputChopWhenExponent = number

           When to chop output. See OutputChopExponent.

   OutputStyle

 OutputStyle = string

           Output style, this can be normal, latex, mathml or troff.

           This affects mostly how matrices and fractions are printed out and
           is useful for pasting into documents. For example you can set this
           to the latex by:

 OutputStyle = "latex"

   ResultsAsFloats

 ResultsAsFloats = boolean

           Convert all results to floats before printing.

   ScientificNotation

 ScientificNotation = boolean

           Use scientific notation.

   SumProductNumberOfTries

 SumProductNumberOfTries = number

           How many iterations to try for InfiniteSum and InfiniteProduct.

   SumProductSFS

 SumProductSFS = number

           How many successive steps to be within tolerance for InfiniteSum
           and InfiniteProduct.

   SumProductTolerance

 SumProductTolerance = number

           Tolerance for InfiniteSum and InfiniteProduct.

   SurfacePlotWindow

 SurfacePlotWindow = [x1,x2,y1,y2,z1,z2]

           Sets the limits for surface plotting (See SurfacePlot).

     ----------------------------------------------------------------------

11.4. Constants

   CatalanConstant

 CatalanConstant

           Catalan's Constant, approximately 0.915... It is defined to be the
           series where terms are (-1^k)/((2*k+1)^2), where k ranges from 0
           to infinity.

           See Mathworld for more information.

   EulerConstant

 EulerConstant

           Aliases: gamma

           Euler's Constant gamma. Sometimes called the Euler-Mascheroni
           constant.

           See Planetmath or Mathworld for more information.

   GoldenRatio

 GoldenRatio

           The Golden Ratio.

           See Planetmath or Mathworld for more information.

   Gravity

 Gravity

           Free fall acceleration.

   e

 e

           The base of the natural logarithm. e^x is the exponential function
           exp. This is the number approximately 2.71828182846...

           See Planetmath or Mathworld for more information.

   pi

 pi

           The number pi, that is the ratio of a circle's circumference to
           its diameter. This is approximately 3.14159265359...

           See Planetmath or Mathworld for more information.

     ----------------------------------------------------------------------

11.5. Numeric

   AbsoluteValue

 AbsoluteValue (x)

           Aliases: abs

           Absolute value of a number and if x is a complex value the modulus
           of x. I.e. this the distance of x to the origin.

           See Planetmath (absolute value), Planetmath (modulus), Mathworld
           (absolute value) or Mathworld (complex modulus) for more
           information.

   Chop

 Chop (x)

           Replace very small number with zero.

   ComplexConjugate

 ComplexConjugate (M)

           Aliases: conj Conj

           Calculates the conjugate.

   Denominator

 Denominator (x)

           Get the denominator of a rational number.

   FractionalPart

 FractionalPart (x)

           Return the fractional part of a number.

   Im

 Im (z)

           Aliases: ImaginaryPart

           Get the imaginary part of a complex number.

   IntegerQuotient

 IntegerQuotient (m,n)

           Division without remainder.

   IsComplex

 IsComplex (num)

           Check if argument is a complex (non-real) number.

   IsComplexRational

 IsComplexRational (num)

           Check if argument is a possibly complex rational number.

   IsFloat

 IsFloat (num)

           Check if argument is a floating point number (non-complex).

   IsGaussInteger

 IsGaussInteger (num)

           Aliases: IsComplexInteger

           Check if argument is a possibly complex integer.

   IsInteger

 IsInteger (num)

           Check if argument is an integer (non-complex).

   IsNonNegativeInteger

 IsNonNegativeInteger (num)

           Check if argument is a non-negative real integer.

   IsPositiveInteger

 IsPositiveInteger (num)

           Aliases: IsNaturalNumber

           Check if argument is a positive real integer. Note that we accept
           the convention that 0 is not a natural number.

   IsRational

 IsRational (num)

           Check if argument is a rational number (non-complex).

   IsReal

 IsReal (num)

           Check if argument is a real number.

   Numerator

 Numerator (x)

           Get the numerator of a rational number.

   Re

 Re (z)

           Aliases: RealPart

           Get the real part of a complex number.

   Sign

 Sign (x)

           Aliases: sign

           Return the sign of a number. That is returns -1 if value is
           negative, 0 if value is zero and 1 if value is positive. If x is a
           complex value then Sign returns the direction or 0.

   ceil

 ceil (x)

           Aliases: Ceiling

           Get the lowest integer more than or equal to n.

   exp

 exp (x)

           The exponential function. This is the function e^x where e is the
           base of the natural logarithm.

           See Planetmath or Mathworld for more information.

   float

 float (x)

           Make number a floating point value. That is returns the floating
           point representation of the number x.

   floor

 floor (x)

           Aliases: Floor

           Get the highest integer less than or equal to n.

   ln

 ln (x)

           The natural logarithm, the logarithm to base e.

   log

 log (x,b...)

           Logarithm of x base b (calls DiscreteLog if in modulo mode), if
           base is not given, e is used.

   log10

 log10 (x)

           Logarithm of x base 10.

   log2

 log2 (x)

           Aliases: lg

           Logarithm of x base 2.

   max

 max (a,args...)

           Aliases: Max Maximum

           Returns the maximum of arguments or matrix.

   min

 min (a,args...)

           Aliases: Min Minimum

           Returns the minimum of arguments or matrix.

   rand

 rand (size...)

           Generate random float in the range [0,1). If size is given then a
           matrix (if two numbers are specified) or vector (if one number is
           specified) of the given size returned.

   randint

 randint (max,size...)

           Generate random integer in the range [0,max). If size is given
           then a matrix (if two numbers are specified) or vector (if one
           number is specified) of the given size returned. For example

 genius> randint(4)
 = 3
 genius> randint(4,2)
 =
 [0      1]
 genius> randint(4,2,3)
 =
 [2      2       1
  0      0       3]

   round

 round (x)

           Aliases: Round

           Round a number.

   sqrt

 sqrt (x)

           Aliases: SquareRoot

           The square root. When operating modulo some integer will return
           either a null or a vector of the square roots. Examples:

 genius> sqrt(2)
 = 1.41421356237
 genius> sqrt(-1)
 = 1i
 genius> sqrt(4) mod 7
 =
 [2      5]
 genius> 2*2 mod 7
 = 4

           See Planetmath for more information.

   trunc

 trunc (x)

           Aliases: Truncate IntegerPart

           Truncate number to an integer (return the integer part).

     ----------------------------------------------------------------------

11.6. Trigonometry

   acos

 acos (x)

           Aliases: arccos

           The arccos (inverse cos) function.

   acosh

 acosh (x)

           Aliases: arccosh

           The arccosh (inverse cosh) function.

   acot

 acot (x)

           Aliases: arccot

           The arccot (inverse cot) function.

   acoth

 acoth (x)

           Aliases: arccoth

           The arccoth (inverse coth) function.

   acsc

 acsc (x)

           Aliases: arccsc

           The inverse cosecant function.

   acsch

 acsch (x)

           Aliases: arccsch

           The inverse hyperbolic cosecant function.

   asec

 asec (x)

           Aliases: arcsec

           The inverse secant function.

   asech

 asech (x)

           Aliases: arcsech

           The inverse hyperbolic secant function.

   asin

 asin (x)

           Aliases: arcsin

           The arcsin (inverse sin) function.

   asinh

 asinh (x)

           Aliases: arcsinh

           The arcsinh (inverse sinh) function.

   atan

 atan (x)

           Aliases: arctan

           Calculates the arctan (inverse tan) function.

           See Mathworld for more information.

   atanh

 atanh (x)

           Aliases: arctanh

           The arctanh (inverse tanh) function.

   atan2

 atan2 (y, x)

           Aliases: arctan2

           Calculates the arctan2 function. If x>0 then it returns atan(y/x).
           If x<0 then it returns sign(y) * (pi - atan(|y/x|). When x=0 it
           returns sign(y) * pi/2. atan2(0,0) returns 0 rather then failing.

           See Mathworld for more information.

   cos

 cos (x)

           Calculates the cosine function.

           See Planetmath for more information.

   cosh

 cosh (x)

           Calculates the hyperbolic cosine function.

           See Planetmath for more information.

   cot

 cot (x)

           The cotangent function.

           See Planetmath for more information.

   coth

 coth (x)

           The hyperbolic cotangent function.

           See Planetmath for more information.

   csc

 csc (x)

           The cosecant function.

           See Planetmath for more information.

   csch

 csch (x)

           The hyperbolic cosecant function.

           See Planetmath for more information.

   sec

 sec (x)

           The secant function.

           See Planetmath for more information.

   sech

 sech (x)

           The hyperbolic secant function.

           See Planetmath for more information.

   sin

 sin (x)

           Calculates the sine function.

           See Planetmath for more information.

   sinh

 sinh (x)

           Calculates the hyperbolic sine function.

           See Planetmath for more information.

   tan

 tan (x)

           Calculates the tan function.

           See Planetmath for more information.

   tanh

 tanh (x)

           The hyperbolic tangent function.

           See Planetmath for more information.

     ----------------------------------------------------------------------

11.7. Number Theory

   AreRelativelyPrime

 AreRelativelyPrime (a,b)

           Are the real integers a and b relatively prime? Returns true or
           false.

           See Planetmath or Mathworld for more information.

   BernoulliNumber

 BernoulliNumber (n)

           Return the nth Bernoulli number.

   ChineseRemainder

 ChineseRemainder (a,m)

           Aliases: CRT

           Find the x that solves the system given by the vector a and modulo
           the elements of m, using the Chinese Remainder Theorem.

           See Planetmath or Mathworld for more information.

   CombineFactorizations

 CombineFactorizations (a,b)

           Given two factorizations, give the factorization of the product.

           See Factorize.

   ConvertFromBase

 ConvertFromBase (v,b)

           Convert a vector of values indicating powers of b to a number.

   ConvertToBase

 ConvertToBase (n,b)

           Convert a number to a vector of powers for elements in base b.

   DiscreteLog

 DiscreteLog (n,b,q)

           Find discrete log of n base b in Fq, the finite field of order q,
           where q is a prime, using the Silver-Pohlig-Hellman algoritm.

           See Planetmath or Mathworld for more information.

   Divides

 Divides (m,n)

           Checks divisibility (if m divides n).

   EulerPhi

 EulerPhi (n)

           Compute the Euler phi function for n, that is the number of
           integers between 1 and n relatively prime to n.

           See Planetmath or Mathworld for more information.

   ExactDivision

 ExactDivision (n,d)

           Return n/d but only if d divides n. If d does not divide n then
           this function returns garbage. This is a lot faster for very large
           numbers than the operation n/d, but of course only useful if you
           know that the division is exact.

   Factorize

 Factorize (n)

           Return factorization of a number as a matrix. The first row is the
           primes in the factorization (including 1) and the second row are
           the powers. So for example:

 genius> Factorize(11*11*13)
 =
 [1      11      13
  1      2       1]

   Factors

 Factors (n)

           Return all factors of n in a vector. This includes all the
           non-prime factors as well. It includes 1 and the number itself. So
           for example to print all the perfect numbers (those that are sums
           of their factors) up to the number 1000 you could do (this is of
           course very inefficent)

 for n=1 to 1000 do (
     if MatrixSum (Factors(n)) == 2*n then
         print(n)
 )

   FermatFactorization

 FermatFactorization (n,tries)

           Attempt fermat factorization of n into (t-s)*(t+s), returns t and
           s as a vector if possible, null otherwise. tries specifies the
           number of tries before giving up.

           This is a fairly good factorization if your number is the product
           of two factors that are very close to each other.

   FindPrimitiveElementMod

 FindPrimitiveElementMod (q)

           Find the first primitive element in Fq, the finite group of order
           q. Of course q must be a prime.

   FindRandomPrimitiveElementMod

 FindRandomPrimitiveElementMod (q)

           Find a random primitive element in Fq, the finite group of order q
           (q must be a prime).

   IndexCalculus

 IndexCalculus (n,b,q,S)

           Compute discrete log base b of n in Fq, the finite group of order
           q (q a prime), using the factor base S. S should be a column of
           primes possibly with second column precalculated by
           IndexCalculusPrecalculation.

   IndexCalculusPrecalculation

 IndexCalculusPrecalculation (b,q,S)

           Run the precalculation step of IndexCalculus for logarithms base b
           in Fq, the finite group of order q (q a prime), for the factor
           base S (where S is a column vector of primes). The logs will be
           precalculated and returned in the second column.

   IsEven

 IsEven (n)

           Tests if an integer is even.

   IsMersennePrimeExponent

 IsMersennePrimeExponent (p)

           Tests if a positive integer p is a Mersenne prime exponent. That
           is if 2p-1 is a prime. It does this by looking it up in a table of
           known values which is relatively short. See also
           MersennePrimeExponents and LucasLehmer.

           See Planetmath, Mathworld or GIMPS for more information.

   IsNthPower

 IsNthPower (m,n)

           Tests if a rational number m is a perfect nth power. See also
           IsPerfectPower and IsPerfectSquare.

   IsOdd

 IsOdd (n)

           Tests if an integer is odd.

   IsPerfectPower

 IsPerfectPower (n)

           Check an integer is any perfect power, ab.

   IsPerfectSquare

 IsPerfectSquare (n)

           Check an integer for being a perfect square of an integer. The
           number must be a real integer. Negative integers are of course
           never perfect squares of real integers.

   IsPrime

 IsPrime (n)

           Tests primality of integers, for numbers less than 2.5e10 the
           answer is deterministic (if Riemann hypothesis is true). For
           numbers larger, the probability of a false positive depends on  
           IsPrimeMillerRabinReps. That is the probability of false positive
           is 1/4 to the power IsPrimeMillerRabinReps. The default value of
           22 yields a probability of about 5.7e-14.

           If false is returned, you can be sure that the number is a
           composite. If you want to be absolutely sure that you have a prime
           you can use   MillerRabinTestSure but it may take a lot longer.

           See Planetmath or Mathworld for more information.

   IsPrimitiveMod

 IsPrimitiveMod (g,q)

           Check if g is primitive in Fq, the finite group of order q, where
           q is a prime. If q is not prime results are bogus.

   IsPrimitiveModWithPrimeFactors

 IsPrimitiveModWithPrimeFactors (g,q,f)

           Check if g is primitive in Fq, the finite group of order q, where
           q is a prime and f is a vector of prime factors of q-1. If q is
           not prime results are bogus.

   IsPseudoprime

 IsPseudoprime (n,b)

           If n is a pseudoprime base b but not a prime, that is if b^(n-1)
           == 1 mod n. This calles the PseudoprimeTest

   IsStrongPseudoprime

 IsStrongPseudoprime (n,b)

           Test if n is a strong pseudoprime to base b but not a prime.

   Jacobi

 Jacobi (a,b)

           Aliases: JacobiSymbol

           Calculate the Jacobi symbol (a/b) (b should be odd).

   JacobiKronecker

 JacobiKronecker (a,b)

           Aliases: JacobiKroneckerSymbol

           Calculate the Jacobi symbol (a/b) with the Kronecker extension
           (a/2)=(2/a) when a odd, or (a/2)=0 when a even.

   LeastAbsoluteResidue

 LeastAbsoluteResidue (a,n)

           Return the residue of a mod n with the least absolute value (in
           the interval -n/2 to n/2).

   Legendre

 Legendre (a,p)

           Aliases: LegendreSymbol

           Calculate the Legendre symbol (a/p).

           See Planetmath or Mathworld for more information.

   LucasLehmer

 LucasLehmer (p)

           Test if 2p-1 is a Mersenne prime using the Lucas-Lehmer test. See
           also MersennePrimeExponents and IsMersennePrimeExponent.

           See Planetmath or Mathworld for more information.

   LucasNumber

 LucasNumber (n)

           Returns the nth Lucas number.

           See Planetmath or Mathworld for more information.

   MaximalPrimePowerFactors

 MaximalPrimePowerFactors (n)

           Return all maximal prime power factors of a number.

   MersennePrimeExponents

 MersennePrimeExponents

           A vector of known Mersenne prime exponents, that is a list of
           positive integers p such that 2p-1 is a prime. See also
           IsMersennePrimeExponent and LucasLehmer.

           See Planetmath, Mathworld or GIMPS for more information.

   MillerRabinTest

 MillerRabinTest (n,reps)

           Use the Miller-Rabin primality test on n, reps number of times.
           The probability of false positive is (1/4)^reps. It is probably
           usually better to use   IsPrime since that is faster and better on
           smaller integers.

           See Planetmath or Mathworld for more information.

   MillerRabinTestSure

 MillerRabinTestSure (n)

           Use the Miller-Rabin primality test on n with enough bases that
           assuming the Generalized Reimann Hypothesis the result is
           deterministic.

           See Planetmath or Mathworld for more information.

   ModInvert

 ModInvert (n,m)

           Returns inverse of n mod m.

           See Mathworld for more information.

   MoebiusMu

 MoebiusMu (n)

           Return the Moebius mu function evaluated in n. That is, it returns
           0 if n is not a product of distinct primes and (-1)^k if it is a
           product of k distinct primes.

           See Planetmath or Mathworld for more information.

   NextPrime

 NextPrime (n)

           Returns the least prime greater than n. Negatives of primes are
           considered prime and so to get the previous prime you can use
           -NextPrime(-n).

           This function uses the GMP's mpz_nextprime which in turn uses the
           probabilistic Miller-Rabin test (See also MillerRabinTest). The
           probability of false positive is not tunable, but is low enough
           for all practical purposes.

           See Planetmath or Mathworld for more information.

   PadicValuation

 PadicValuation (n,p)

           Returns the padic valuation (number of trailing zeros in base p).

           See Planetmath for more information.

   PowerMod

 PowerMod (a,b,m)

           Compute a^b mod m. The b's power of a modulo m. It is not
           neccessary to use this function as it is automatically used in
           modulo mode. Hence a^b mod m is just as fast.

   Prime

 Prime (n)

           Aliases: prime

           Return the nth prime (up to a limit).

           See Planetmath or Mathworld for more information.

   PrimeFactors

 PrimeFactors (n)

           Return all prime factors of a number as a vector.

           See Mathworld for more information.

   PseudoprimeTest

 PseudoprimeTest (n,b)

           Pseudoprime test, returns true if and only if b^(n-1) == 1 mod n

           See Planetmath or Mathworld for more information.

   RemoveFactor

 RemoveFactor (n,m)

           Removes all instances of the factor m from the number n. That is
           divides by the largest power of m, that divides n.

           See Planetmath or Mathworld for more information.

   SilverPohligHellmanWithFactorization

 SilverPohligHellmanWithFactorization (n,b,q,f)

           Find discrete log of n base b in Fq, the finite group of order q,
           where q is a prime using the Silver-Pohlig-Hellman algoritm, given
           f being the factorization of q-1.

   SqrtModPrime

 SqrtModPrime (n,p)

           Find square root of n modulo p (where p is a prime). Null is
           returned if not a quadratic residue.

           See Planetmath or Mathworld for more information.

   StrongPseudoprimeTest

 StrongPseudoprimeTest (n,b)

           Run the strong pseudoprime test base b on n.

           See Planetmath or Mathworld for more information.

   gcd

 gcd (a,args...)

           Aliases: GCD

           Greatest common divisor of integers. You can enter as many
           integers in the argument list, or you can give a vector or a
           matrix of integers. If you give more than one matrix of the same
           size then GCD is done element by element.

           See Planetmath or Mathworld for more information.

   lcm

 lcm (a,args...)

           Aliases: LCM

           Least common multiplier of integers. You can enter as many
           integers in the argument list, or you can give a vector or a
           matrix of integers. If you give more than one matrix of the same
           size then LCM is done element by element.

           See Planetmath or Mathworld for more information.

     ----------------------------------------------------------------------

11.8. Matrix Manipulation

   ApplyOverMatrix

 ApplyOverMatrix (a,func)

           Apply a function over all entries of a matrix and return a matrix
           of the results.

   ApplyOverMatrix2

 ApplyOverMatrix2 (a,b,func)

           Apply a function over all entries of 2 matrices (or 1 value and 1
           matrix) and return a matrix of the results.

   ColumnsOf

 ColumnsOf (M)

           Gets the columns of a matrix as a horizontal vector.

   ComplementSubmatrix

 ComplementSubmatrix (m,r,c)

           Remove column(s) and row(s) from a matrix.

   CompoundMatrix

 CompoundMatrix (k,A)

           Calculate the kth compund matrix of A.

   CountZeroColumns

 CountZeroColumns (M)

           Count the number of zero columns in a matrix. For example Once you
           column reduce a matrix you can use this to find the nullity. See
           cref and Nullity.

   DeleteColumn

 DeleteColumn (M,col)

           Delete a column of a matrix.

   DeleteRow

 DeleteRow (M,row)

           Delete a row of a matrix.

   DiagonalOf

 DiagonalOf (M)

           Gets the diagonal entries of a matrix as a column vector.

   DotProduct

 DotProduct (u,v)

           Get the dot product of two vectors. The vectors must be of the
           same size. No conjugates are taken so this is a bilinear form even
           if working over the complex numbers.

           See Planetmath for more information.

   ExpandMatrix

 ExpandMatrix (M)

           Expands a matrix just like we do on unquoted matrix input. That is
           we expand any internal matrices as blocks. This is a way to
           construct matrices out of smaller ones and this is normally done
           automatically on input unless the matrix is quoted.

   HermitianProduct

 HermitianProduct (u,v)

           Aliases: InnerProduct

           Get the hermitian product of two vectors. The vectors must be of
           the same size. This is a sesquilinear form using the identity
           matrix.

           See Mathworld for more information.

   I

 I (n)

           Aliases: eye

           Return an identity matrix of a given size, that is n by n. If n is
           zero, returns null.

           See Planetmath for more information.

   IndexComplement

 IndexComplement (vec,msize)

           Return the index complement of a vector of indexes. Everything is
           one based. For example for vector [2,3] and size 5, we return
           [1,4,5]. If msize is 0, we always return null.

   IsDiagonal

 IsDiagonal (M)

           Is a matrix diagonal.

           See Planetmath for more information.

   IsIdentity

 IsIdentity (x)

           Check if a matrix is the identity matrix. Automatically returns
           false if the matrix is not square. Also works on numbers, in which
           case it is equivalent to x==1. When x is null (we could think of
           that as a 0 by 0 matrix), no error is generated and false is
           returned.

   IsLowerTriangular

 IsLowerTriangular (M)

           Is a matrix lower triangular. That is, are all the entries below
           the diagonal zero.

   IsMatrixInteger

 IsMatrixInteger (M)

           Check if a matrix is a matrix of an integers (non-complex).

   IsMatrixNonnegative

 IsMatrixNonnegative (M)

           Check if a matrix is nonnegative, that is if each element is
           nonnegative. Do not confuse positive matrices with positive
           semi-definite matrices.

           See Wikipedia for more information.

   IsMatrixPositive

 IsMatrixPositive (M)

           Check if a matrix is positive, that is if each element is positive
           (and hence real). In particular, no element is 0. Do not confuse
           positive matrices with positive definite matrices.

           See Wikipedia for more information.

   IsMatrixRational

 IsMatrixRational (M)

           Check if a matrix is a matrix of rational (non-complex) numbers.

   IsMatrixReal

 IsMatrixReal (M)

           Check if a matrix is a matrix of real (non-complex) numbers.

   IsMatrixSquare

 IsMatrixSquare (M)

           Check if a matrix is square, that is its width is equal to its
           height.

   IsUpperTriangular

 IsUpperTriangular (M)

           Is a matrix upper triangular? That is, a matrix is upper
           triangular if all all the entries below the diagonal are zero.

   IsValueOnly

 IsValueOnly (M)

           Check if a matrix is a matrix of numbers only. Many internal
           functions make this check. Values can be any number including
           complex numbers.

   IsVector

 IsVector (v)

           Is argument a horizontal or a vertical vector. Genius does not
           distinguish between a matrix and a vector and a vector is just a 1
           by n or n by 1 matrix.

   IsZero

 IsZero (x)

           Check if a matrix is composed of all zeros. Also works on numbers,
           in which case it is equivalent to x==0. When x is null (we could
           think of that as a 0 by 0 matrix), no error is generated and true
           is returned as the condition is vacuous.

   LowerTriangular

 LowerTriangular (M)

           Returns a copy of the matrix M with all the entries above the
           diagonal set to zero.

   MakeDiagonal

 MakeDiagonal (v,arg...)

           Aliases: diag

           Make diagonal matrix from a vector.

           See Planetmath for more information.

   MakeVector

 MakeVector (A)

           Make column vector out of matrix by putting columns above each
           other. Returns null when given null.

   MatrixProduct

 MatrixProduct (A)

           Calculate the product of all elements in a matrix or vector. That
           is we multiply all the elements and return a number that is the
           product of all the elements.

   MatrixSum

 MatrixSum (A)

           Calculate the sum of all elements in a matrix or vecgtor. That is
           we add all the elements and return a number that is the sum of all
           the elements.

   MatrixSumSquares

 MatrixSumSquares (A)

           Calculate the sum of squares of all elements in a matrix or
           vector.

   OuterProduct

 OuterProduct (u,v)

           Get the outer product of two vectors. That is, suppose that u and
           v are vertical vectors, then the outer product is v * u.'.

   ReverseVector

 ReverseVector (v)

           Reverse elements in a vector.

   RowSum

 RowSum (m)

           Calculate sum of each row in a matrix and return a vertical vector
           with the result.

   RowSumSquares

 RowSumSquares (m)

           Calculate sum of squares of each row in a matrix.

   RowsOf

 RowsOf (M)

           Gets the rows of a matrix as a vertical vector. Each element of
           the vector is a horizontal vector which is the corresponding row
           of M. This function is useful if you wish to loop over the rows of
           a matrix. For example, as for r in RowsOf(M) do something(r).

   SetMatrixSize

 SetMatrixSize (M,rows,columns)

           Make new matrix of given size from old one. That is, a new matrix
           will be returned to which the old one is copied. Entries that
           don't fit are clipped and extra space is filled with zeros. if
           rows or columns are zero then null is returned.

   SortVector

 SortVector (v)

           Sort vector elements in an increasing order.

   StripZeroColumns

 StripZeroColumns (M)

           Removes any all-zero columns of M.

   StripZeroRows

 StripZeroRows (M)

           Removes any all-zero rows of M.

   Submatrix

 Submatrix (m,r,c)

           Return column(s) and row(s) from a matrix. This is just equivalent
           to m@(r,c). r and c should be vectors of rows and columns (or
           single numbers if only one row or column is needed).

   SwapRows

 SwapRows (m,row1,row2)

           Swap two rows in a matrix.

   UpperTriangular

 UpperTriangular (M)

           Returns a copy of the matrix M with all the entries below the
           diagonal set to zero.

   columns

 columns (M)

           Get the number of columns of a matrix.

   elements

 elements (M)

           Get the total number of elements of a matrix. This is the number
           of columns times the number of rows.

   ones

 ones (rows,columns...)

           Make an matrix of all ones (or a row vector if only one argument
           is given). Returns null if either rows or columns are zero.

   rows

 rows (M)

           Get the number of rows of a matrix.

   zeros

 zeros (rows,columns...)

           Make a matrix of all zeros (or a row vector if only one argument
           is given). Returns null if either rows or columns are zero.

     ----------------------------------------------------------------------

11.9. Linear Algebra

   AuxilliaryUnitMatrix

 AuxilliaryUnitMatrix (n)

           Get the auxilliary unit matrix of size n. This is a square matrix
           matrix with that is all zero except the superdiagonal being all
           ones. It is the Jordan block matrix of one zero eigenvalue.

           See Planetmath or Mathworld for more information on Jordan
           Cannonical Form.

   BilinearForm

 BilinearForm (v,A,w)

           Evaluate (v,w) with respect to the bilinear form given by the
           matrix A.

   BilinearFormFunction

 BilinearFormFunction (A)

           Return a function that evaluates two vectors with respect to the
           bilinear form given by A.

   CharacteristicPolynomial

 CharacteristicPolynomial (M)

           Aliases: CharPoly

           Get the characteristic polynomial as a vector. That is, return the
           coefficients of the polynomial starting with the constant term.
           This is the polynomial defined by det(M-xI). The roots of this
           polynomial are the eigenvalues of M. See also
           CharacteristicPolynomialFunction.

           See Planetmath for more information.

   CharacteristicPolynomialFunction

 CharacteristicPolynomialFunction (M)

           Get the characteristic polynomial as a function. This is the
           polynomial defined by det(M-xI). The roots of this polynomial are
           the eigenvalues of M. See also CharacteristicPolynomial.

           See Planetmath for more information.

   ColumnSpace

 ColumnSpace (M)

           Get a basis matrix for the columnspace of a matrix. That is,
           return a matrix whose columns are the basis for the column space
           of M. That is the space spanned by the columns of M.

   CommutationMatrix

 CommutationMatrix (m, n)

           Return the commutation matrix K(m,n) which is the unique m*n by
           m*n matrix such that K(m,n) * MakeVector(A) = MakeVector(A.') for
           all m by n matrices A.

   CompanionMatrix

 CompanionMatrix (p)

           Companion matrix of a polynomial (as vector).

   ConjugateTranspose

 ConjugateTranspose (M)

           Conjugate transpose of a matrix (adjoint). This is the same as the
           ' operator.

           See Planetmath for more information.

   Convolution

 Convolution (a,b)

           Aliases: convol

           Calculate convolution of two horizontal vectors.

   ConvolutionVector

 ConvolutionVector (a,b)

           Calculate convolution of two horizontal vectors. Return result as
           a vector and not added together.

   CrossProduct

 CrossProduct (v,w)

           CrossProduct of two vectors in R3.

   DeterminantalDivisorsInteger

 DeterminantalDivisorsInteger (M)

           Get the determinantal divisors of an integer matrix (not its
           characteristic).

   DirectSum

 DirectSum (M,N...)

           Direct sum of matrices.

   DirectSumMatrixVector

 DirectSumMatrixVector (v)

           Direct sum of a vector of matrices.

   Eigenvalues

 Eigenvalues (M)

           Aliases: eig

           Get the eigenvalues of a square matrix. Currently only works for
           matrices of size up to 4 by 4, or for triangular matrices (for
           which the eigenvalues are on the diagonal).

           See Planetmath or Mathworld for more information.

   GramSchmidt

 GramSchmidt (v,B...)

           Apply the Gram-Schmidt process (to the columns) with respect to
           inner product given by B. If B is not given then the standard
           hermitian product is used. B can either be a sesquilinear function
           of two arguments or it can be a matrix giving a sesquilinear form.
           The vectors will be made orthonormal with respect to B.

           See Planetmath for more information.

   HankelMatrix

 HankelMatrix (c,r)

           Hankel matrix.

   HilbertMatrix

 HilbertMatrix (n)

           Hilbert matrix of order n.

           See Planetmath for more information.

   Image

 Image (T)

           Get the image (columnspace) of a linear transform.

   InfNorm

 InfNorm (v)

           Get the Inf Norm of a vector, sometimes called the sup norm or the
           max norm.

   InvariantFactorsInteger

 InvariantFactorsInteger (M)

           Get the invariant factors of a square integer matrix (not its
           characteristic).

   InverseHilbertMatrix

 InverseHilbertMatrix (n)

           Inverse Hilbert matrix of order n.

           See Planetmath for more information.

   IsHermitian

 IsHermitian (M)

           Is a matrix hermitian. That is, is it equal to its conjugate
           transpose.

           See Planetmath for more information.

   IsInSubspace

 IsInSubspace (v,W)

           Test if a vector is in a subspace.

   IsInvertible

 IsInvertible (n)

           Is a matrix (or number) invertible (Integer matrix is invertible
           iff it's invertible over the integers).

   IsInvertibleField

 IsInvertibleField (n)

           Is a matrix (or number) invertible over a field.

   IsNormal

 IsNormal (M)

           Is M a normal matrix. That is, does M*M' == M'*M.

           See Planetmath or Mathworld for more information.

   IsPositiveDefinite

 IsPositiveDefinite (M)

           Is M a hermitian positive definite matrix. That is if
           HermitianProduct(M*v,v) is always strictly positive for any vector
           v. M must be square and hermitian to be positive definite. The
           check that is performed is that every principal submatrix has a
           nonnegative determinant. (See HermitianProduct)

           Note that some authors (for example Mathworld) do not require that
           M be hermitian, and then the condition is on the real part of the
           inner product, but we do not take this view. If you wish to
           perform this check, just check the hermitian part of the matrix M
           as follows: IsPositiveDefinite(M+M').

           See Planetmath or Mathworld for more information.

   IsPositiveSemidefinite

 IsPositiveSemidefinite (M)

           Is M a hermitian positive semidefinite matrix. That is if
           HermitianProduct(M*v,v) is always nonnegative for any vector v. M
           must be square and hermitian to be positive semidefinite. The
           check that is performed is that every principal submatrix has a
           nonnegative determinant. (See HermitianProduct)

           Note that some authors do not require that M be hermitian, and
           then the condition is on the real part of the inner product, but
           we do not take this view. If you wish to perform this check, just
           check the hermitian part of the matrix M as follows:
           IsPositiveSemidefinite(M+M').

           See Planetmath or Mathworld for more information.

   IsSkewHermitian

 IsSkewHermitian (M)

           Is a matrix skew-hermitian. That is, is the conjugate transpose
           equal to negative of the matrix.

           See Planetmath for more information.

   IsUnitary

 IsUnitary (M)

           Is a matrix unitary? That is, does M'*M and M*M' equal the
           identity.

           See Planetmath or Mathworld for more information.

   JordanBlock

 JordanBlock (n,lambda)

           Aliases: J

           Get the Jordan block corresponding to the eigenvalue lambda with
           multiplicity n.

           See Planetmath or Mathworld for more information.

   Kernel

 Kernel (T)

           Get the kernel (nullspace) of a linear transform.

           (See NullSpace)

   LUDecomposition

 LUDecomposition (A, L, U)

           Get the LU decomposition of A and store the result in the L and U
           which should be references. It returns true if successful. For
           example suppose that A is a square matrix, then after running:

 genius> LUDecomposition(A,&L,&U)

           You will have the lower matrix stored in a variable called L and
           the upper matrix in a variable called U.

           This is the LU decomposition of a matrix aka Crout and/or Cholesky
           reduction. (ISBN 0-201-11577-8 pp.99-103) The upper triangular
           matrix features a diagonal of values 1 (one). This is not
           Doolittle's Method which features the 1's diagonal on the lower
           matrix.

           Not all matrices have LU decompositions, for example [0,1;1,0]
           does not and this function returns false in this case and sets L
           and U to null.

           See Planetmath or Mathworld for more information.

   Minor

 Minor (M,i,j)

           Get the i-j minor of a matrix.

           See Planetmath for more information.

   NonPivotColumns

 NonPivotColumns (M)

           Return the columns that are not the pivot columns of a matrix.

   Norm

 Norm (v,p...)

           Aliases: norm

           Get the p Norm (or 2 Norm if no p is supplied) of a vector.

   NullSpace

 NullSpace (T)

           Get the nullspace of a matrix. That is the kernel of the linear
           mapping that the matrix represents. This is returned as a matrix
           whose column space is the nullspace of T.

           See Planetmath for more information.

   Nullity

 Nullity (M)

           Aliases: nullity

           Get the nullity of a matrix. That is, return the dimension of the
           nullspace; the dimension of the kernel of M.

           See Planetmath for more information.

   OrthogonalComplement

 OrthogonalComplement (M)

           Get the orthogonal complement of the columnspace.

   PivotColumns

 PivotColumns (M)

           Return pivot columns of a matrix, that is columns which have a
           leading 1 in row reduced form. Also returns the row where they
           occur.

   Projection

 Projection (v,W,B...)

           Projection of vector v onto subspace W with respect to inner
           product given by B. If B is not given then the standard hermitian
           product is used. B can either be a sesquilinear function of two
           arguments or it can be a matrix giving a sesquilinear form.

   QRDecomposition

 QRDecomposition (A, Q)

           Get the QR decomposition of a square matrix A, returns the upper
           triangular matrix R and sets Q to the orthogonal (unitary) matrix.
           Q should be a reference or null if you don't want any return. For
           example:

 genius> R = QRDecomposition(A,&Q)

           You will have the upper triangular matrix stored in a variable
           called R and the orthogonal (unitary) matrix stored in Q.

           See Planetmath or Mathworld for more information.

   RayleighQuotient

 RayleighQuotient (A,x)

           Return the Rayleigh quotient (also called the Rayleigh-Ritz
           quotient or ratio) of a matrix and a vector.

           See Planetmath for more information.

   RayleighQuotientIteration

 RayleighQuotientIteration (A,x,epsilon,maxiter,vecref)

           Find eigenvalues of A using the Rayleigh quotient iteration
           method. x is a guess at a eigenvector and could be random. It
           should have nonzero imaginary part if it will have any chance at
           finding complex eigenvalues. The code will run at most maxiter
           iterations and return null if we cannot get within an error of
           epsilon. vecref should either be null or a reference to a variable
           where the eigenvector should be stored.

           See Planetmath for more information on Rayleigh quotient.

   Rank

 Rank (M)

           Aliases: rank

           Get the rank of a matrix.

           See Planetmath for more information.

   RosserMatrix

 RosserMatrix ()

           Rosser matrix, a classic symmetric eigenvalue test problem.

   Rotation2D

 Rotation2D (angle)

           Aliases: RotationMatrix

           Return the matrix corresponding to rotation around origin in R2.

   Rotation3DX

 Rotation3DX (angle)

           Return the matrix corresponding to rotation around origin in R3
           about the x-axis.

   Rotation3DY

 Rotation3DY (angle)

           Return the matrix corresponding to rotation around origin in R3
           about the y-axis.

   Rotation3DZ

 Rotation3DZ (angle)

           Return the matrix corresponding to rotation around origin in R3
           about the z-axis.

   RowSpace

 RowSpace (M)

           Get a basis matrix for the rowspace of a matrix.

   SesquilinearForm

 SesquilinearForm (v,A,w)

           Evaluate (v,w) with respect to the sesquilinear form given by the
           matrix A.

   SesquilinearFormFunction

 SesquilinearFormFunction (A)

           Return a function that evaluates two vectors with respect to the
           sesquilinear form given by A.

   SmithNormalFormField

 SmithNormalFormField (A)

           Smith Normal Form for fields (will end up with 1's on the
           diagonal).

   SmithNormalFormInteger

 SmithNormalFormInteger (M)

           Smith Normal Form for square integer matrices (not its
           characteristic).

   SolveLinearSystem

 SolveLinearSystem (M,V,args...)

           Solve linear system Mx=V, return solution V if there is a unique
           solution, null otherwise. Extra two reference parameters can
           optionally be used to get the reduced M and V.

   ToeplitzMatrix

 ToeplitzMatrix (c, r...)

           Return the Toeplitz matrix constructed given the first column c
           and (optionally) the first row r. If only the column c is given
           then it is conjugated and the nonconjugated version is used for
           the first row to give a Hermitian matrix (if the first element is
           real of course).

           See Planetmath for more information.

   Trace

 Trace (M)

           Aliases: trace

           Calculate the trace of a matrix. That is the sum of the diagonal
           elements.

           See Planetmath for more information.

   Transpose

 Transpose (M)

           Transpose of a matrix. This is the same as the .' operator.

           See Planetmath for more information.

   VandermondeMatrix

 VandermondeMatrix (v)

           Aliases: vander

           Return the Vandermonde matrix.

   VectorAngle

 VectorAngle (v,w,B...)

           The angle of two vectors with respect to inner product given by B.
           If B is not given then the standard hermitian product is used. B
           can either be a sesquilinear function of two arguments or it can
           be a matrix giving a sesquilinear form.

   VectorSpaceDirectSum

 VectorSpaceDirectSum (M,N)

           The direct sum of the vector spaces M and N.

   VectorSubspaceIntersection

 VectorSubspaceIntersection (M,N)

           Intersection of the subspaces given by M and N.

   VectorSubspaceSum

 VectorSubspaceSum (M,N)

           The sum of the vector spaces M and N, that is {w | w=m+n, m in M,
           n in N}.

   adj

 adj (m)

           Aliases: Adjugate

           Get the classical adjoint (adjugate) of a matrix.

   cref

 cref (M)

           Aliases: CREF ColumnReducedEchelonForm

           Compute the Column Reduced Echelon Form.

   det

 det (M)

           Aliases: Determinant

           Get the determinant of a matrix.

           See Planetmath for more information.

   ref

 ref (M)

           Aliases: REF RowEchelonForm

           Get the row echelon form of a matrix. That is, apply gaussian
           elimination but not backaddition to M. The pivot rows are divided
           to make all pivots 1.

           See Planetmath for more information.

   rref

 rref (M)

           Aliases: RREF ReducedRowEchelonForm

           Get the reduced row echelon form of a matrix. That is, apply
           gaussian elimination together with backaddition to M.

           See Planetmath for more information.

     ----------------------------------------------------------------------

11.10. Combinatorics

   Catalan

 Catalan (n)

           Get n'th catalan number.

           See Planetmath for more information.

   Combinations

 Combinations (k,n)

           Get all combinations of k numbers from 1 to n as a vector of
           vectors. (See also NextCombination)

   DoubleFactorial

 DoubleFactorial (n)

           Double factorial: n(n-2)(n-4)...

           See Planetmath for more information.

   Factorial

 Factorial (n)

           Factorial: n(n-1)(n-2)...

           See Planetmath for more information.

   FallingFactorial

 FallingFactorial (n,k)

           Falling factorial: (n)_k = n(n-1)...(n-(k-1))

           See Planetmath for more information.

   Fibonacci

 Fibonacci (x)

           Aliases: fib

           Calculate nth fibonacci number. That is the number defined
           recursively by Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2) and
           Fibonacci(1) = Fibonacci(2) = 1.

           See Planetmath or Mathworld for more information.

   FrobeniusNumber

 FrobeniusNumber (v,arg...)

           Calculate the Frobenius number. That is calculate smallest number
           that cannot be given as a nonnegative integer linear combination
           of a given vector of nonnegative integers. The vector can be given
           as separate numbers or a single vector. All the numbers given
           should have GCD of 1.

           See Mathworld for more information.

   GaloisMatrix

 GaloisMatrix (combining_rule)

           Galois matrix given a linear combining rule
           (a_1*x_+...+a_n*x_n=x_(n+1)).

   GreedyAlgorithm

 FrobeniusNumber (n,v)

           Find the vector c of nonnegative integers such that taking the dot
           product with v is equal to n. If not possible returns null. v
           should be given sorted in increasing order and should consist of
           nonnegative integers.

           See Mathworld for more information.

   HarmonicNumber

 HarmonicNumber (n,r)

           Aliases: HarmonicH

           Harmonic Number, the n'th harmonic number of order r.

   Hofstadter

 Hofstadter (n)

           Hofstadter's function q(n) defined by q(1)=1, q(2)=1,
           q(n)=q(n-q(n-1))+q(n-q(n-2)).

   LinearRecursiveSequence

 LinearRecursiveSequence (seed_values,combining_rule,n)

           Compute linear recursive sequence using galois stepping.

   Multinomial

 Multinomial (v,arg...)

           Calculate multinomial coefficients. Takes a vector of k
           nonnegative integers and computes the multinomial coefficient.
           This corresponds to the coefficient in the homogeneous polynomial
           in k variables with the corresponding powers.

           The formula for Multinomial(a,b,c) can be written as:

 (a+b+c)! / (a!b!c!)

           In other words, if we would have only two elements, then
           Multinomial(a,b) is the same thing as Binomial(a+b,a) or
           Binomial(a+b,b).

           See Planetmath, Mathworld, or Wikipedia for more information.

   NextCombination

 NextCombination (v,n)

           Get combination that would come after v in call to combinations,
           first combination should be [1:k]. This function is useful if you
           have many combinations to go through and you don't want to waste
           memory to store them all.

           For example with Combination you would normally write a loop like:

 for n in Combinations (4,6) do (
   SomeFunction (n)
 );

           But with NextCombination you would write something like:

 n:=[1:4];
 do (
   SomeFunction (n)
 ) while not IsNull(n:=NextCombination(n,6));

           See also Combinations.

   Pascal

 Pascal (i)

           Get the Pascal's triangle as a matrix. This will return an i+1 by
           i+1 lower diagonal matrix which is the Pascal's triangle after i
           iterations.

           See Planetmath for more information.

   Permutations

 Permutations (k,n)

           Get all permutations of k numbers from 1 to n as a vector of
           vectors.

           See Mathworld or Wikipedia for more information.

   RisingFactorial

 RisingFactorial (n,k)

           Aliases: Pochhammer

           (Pochhammer) Rising factorial: (n)_k = n(n+1)...(n+(k-1)).

           See Planetmath for more information.

   StirlingNumberFirst

 StirlingNumberFirst (n,m)

           Aliases: StirlingS1

           Stirling number of the first kind.

           See Planetmath or Mathworld for more information.

   StirlingNumberSecond

 StirlingNumberSecond (n,m)

           Aliases: StirlingS2

           Stirling number of the second kind.

           See Planetmath or Mathworld for more information.

   Subfactorial

 Subfactorial (n)

           Subfactorial: n! times sum_{k=1}^n (-1)^k/k!.

   Triangular

 Triangular (nth)

           Calculate the n'th triangular number.

           See Planetmath for more information.

   nCr

 nCr (n,r)

           Aliases: Binomial

           Calculate combinations, that is, the binomial coefficient. n can
           be any real number.

           See Planetmath for more information.

   nPr

 nPr (n,r)

           Calculate the number of permutations of size rof numbers from 1 to
           n.

           See Mathworld or Wikipedia for more information.

     ----------------------------------------------------------------------

11.11. Calculus

   CompositeSimpsonsRule

 CompositeSimpsonsRule (f,a,b,n)

           Integration of f by Composite Simpson's Rule on the interval [a,b]
           with n subintervals with error of max(f'''')*h^4*(b-a)/180, note
           that n should be even.

           See Planetmath for more information.

   CompositeSimpsonsRuleTolerance

 CompositeSimpsonsRuleTolerance (f,a,b,FourthDerivativeBound,Tolerance)

           Integration of f by Composite Simpson's Rule on the interval [a,b]
           with the number of steps calculated by the fourth derivative bound
           and the desired tolerance.

           See Planetmath for more information.

   Derivative

 Derivative (f,x0)

           Attempt to calculate derivative by trying first symbolically and
           then numerically.

   InfiniteProduct

 InfiniteProduct (func,start,inc)

           Try to calculate an infinite product for a single parameter
           function.

   InfiniteProduct2

 InfiniteProduct2 (func,arg,start,inc)

           Try to calculate an infinite product for a double parameter
           function with func(arg,n).

   InfiniteSum

 InfiniteSum (func,start,inc)

           Try to calculate an infinite sum for a single parameter function.

   InfiniteSum2

 InfiniteSum2 (func,arg,start,inc)

           Try to calculate an infinite sum for a double parameter function
           with func(arg,n).

   IsContinuous

 IsContinuous (f,x0)

           Try and see if a real-valued function is continuous at x0 by
           calculating the limit there.

   IsDifferentiable

 IsDifferentiable (f,x0)

           Test for differentiability by approximating the left and right
           limits and comparing.

   LeftLimit

 LeftLimit (f,x0)

           Calculate the left limit of a real-valued function at x0.

   Limit

 Limit (f,x0)

           Calculate the limit of a real-valued function at x0. Tries to
           calculate both left and right limits.

   MidpointRule

 MidpointRule (f,a,b,n)

           Integration by midpoint rule.

   NumericalDerivative

 NumericalDerivative (f,x0)

           Aliases: NDerivative

           Attempt to calculate numerical derivative.

   NumericalIntegral

 NumericalIntegral (f,a,b)

           Integration by rule set in NumericalIntegralFunction of f from a
           to b using NumericalIntegralSteps steps.

   NumericalLeftDerivative

 NumericalLeftDerivative (f,x0)

           Attempt to calculate numerical left derivative.

   NumericalLimitAtInfinity

 NumericalLimitAtInfinity (_f,step_fun,tolerance,successive_for_success,N)

           Attempt to calculate the limit of f(step_fun(i)) as i goes from 1
           to N.

   NumericalRightDerivative

 NumericalRightDerivative (f,x0)

           Attempt to calculate numerical right derivative.

   OneSidedFivePointFormula

 OneSidedFivePointFormula (f,x0,h)

           Compute one-sided derivative using five point formula.

   OneSidedThreePointFormula

 OneSidedThreePointFormula (f,x0,h)

           Compute one-sided derivative using three-point formula.

   RightLimit

 RightLimit (f,x0)

           Calculate the right limit of a real-valued function at x0.

   TwoSidedFivePointFormula

 TwoSidedFivePointFormula (f,x0,h)

           Compute two-sided derivative using five-point formula.

   TwoSidedThreePointFormula

 TwoSidedThreePointFormula (f,x0,h)

           Compute two-sided derivative using three-point formula.

     ----------------------------------------------------------------------

11.12. Functions

   Argument

 Argument (z)

           Aliases: Arg arg

           argument (angle) of complex number.

   DirichletKernel

 DirichletKernel (n,t)

           Dirichlet kernel of order n.

   DiscreteDelta

 DiscreteDelta (v)

           Returns 1 iff all elements are zero.

   ErrorFunction

 ErrorFunction (x)

           Aliases: erf

           The error function, 2/sqrt(pi) * int_0^x e^(-t^2) dt.

           See Planetmath for more information.

   FejerKernel

 FejerKernel (n,t)

           Fejer kernel of order n evaluated at t

           See Planetmath for more information.

   GammaFunction

 GammaFunction (x)

           Aliases: Gamma

           The Gamma function. Currently only implemented for real values.

           See Planetmath for more information.

   KroneckerDelta

 KroneckerDelta (v)

           Returns 1 iff all elements are equal.

   MinimizeFunction

 MinimizeFunction (func,x,incr)

           Find the first value where f(x)=0.

   MoebiusDiskMapping

 MoebiusDiskMapping (a,z)

           Moebius mapping of the disk to itself mapping a to 0.

           See Planetmath for more information.

   MoebiusMapping

 MoebiusMapping (z,z2,z3,z4)

           Moebius mapping using the cross ratio taking z2,z3,z4 to 1,0, and
           infinity respectively.

           See Planetmath for more information.

   MoebiusMappingInftyToInfty

 MoebiusMappingInftyToInfty (z,z2,z3)

           Moebius mapping using the cross ratio taking infinity to infinity
           and z2,z3 to 1 and 0 respectively.

           See Planetmath for more information.

   MoebiusMappingInftyToOne

 MoebiusMappingInftyToOne (z,z3,z4)

           Moebius mapping using the cross ratio taking infinity to 1 and
           z3,z4 to 0 and infinity respectively.

           See Planetmath for more information.

   MoebiusMappingInftyToZero

 MoebiusMappingInftyToZero (z,z2,z4)

           Moebius mapping using the cross ratio taking infinity to 0 and
           z2,z4 to 1 and infinity respectively.

           See Planetmath for more information.

   PoissonKernel

 PoissonKernel (r,sigma)

           Poisson kernel on D(0,1) (not normalized to 1, that is integral of
           this is 2pi).

   PoissonKernelRadius

 PoissonKernelRadius (r,sigma)

           Poisson kernel on D(0,R) (not normalized to 1).

   RiemannZeta

 RiemannZeta (x)

           Aliases: zeta

           The Riemann zeta function. Currently only implemented for real
           values.

           See Planetmath for more information.

   UnitStep

 UnitStep (x)

           The unit step function is 0 for x<0, 1 otherwise. This is the
           integral of the Dirac Delta function.

   cis

 cis (x)

           The cis function, that is the same as cos(x)+1i*sin(x)

   deg2rad

 deg2rad (x)

           Convert degrees to radians.

   rad2deg

 rad2deg (x)

           Convert radians to degrees.

     ----------------------------------------------------------------------

11.13. Equation Solving

   CubicFormula

 CubicFormula (p)

           Compute roots of a cubic (degree 3) polynomial using the cubic
           formula. The polynomial should be given as a vector of
           coefficients. That is 4*x^3 + 2*x + 1 corresponds to the vector
           [1,2,0,4]. Returns a column vector of the three solutions. The
           first solution is always the real one as a cubic always has one
           real solution.

           See Planetmath, Mathworld, or Wikipedia for more information.

   EulerMethod

 EulerMethod (f,x0,y0,x1,n)

           Use classical Euler's method to numerically solve y'=f(x,y) for
           initial x0, y0 going to x1 with n increments, returns y at x1.

           See Mathworld for more information.

   FindRootBisection

 FindRootBisection (f,a,b,TOL,N)

           Find root of a function using the bisection method.

   FindRootFalsePosition

 FindRootFalsePosition (f,a,b,TOL,N)

           Find root of a function using the method of false position.

   FindRootMullersMethod

 FindRootMullersMethod (f,x1,x2,x3,TOL,N)

           Find root of a function using the Muller's method.

   FindRootSecant

 FindRootSecant (f,a,b,TOL,N)

           Find root of a function using the secant method.

   PolynomialRoots

 PolynomialRoots (p)

           Compute roots of a polynomial (degrees 1 through 4) using one of
           the formulas for such polynomials. The polynomial should be given
           as a vector of coefficients. That is 4*x^3 + 2*x + 1 corresponds
           to the vector [1,2,0,4]. Returns a column vector of the solutions.

           The function calls QuadraticFormula, CubicFormula, and
           QuarticFormula.

   QuadraticFormula

 QuadraticFormula (p)

           Compute roots of a quadratic (degree 2) polynomial using the
           quadratic formula. The polynomial should be given as a vector of
           coefficients. That is 3*x^2 + 2*x + 1 corresponds to the vector
           [1,2,3]. Returns a column vector of the two solutions.

           See Planetmath or Mathworld for more information.

   QuarticFormula

 QuarticFormula (p)

           Compute roots of a quartic (degree 4) polynomial using the quartic
           formula. The polynomial should be given as a vector of
           coefficients. That is 5*x^4 + 2*x + 1 corresponds to the vector
           [1,2,0,0,5]. Returns a column vector of the four solutions.

           See Planetmath, Mathworld, or Wikipedia for more information.

   RungeKutta

 RungeKutta (f,x0,y0,x1,n)

           Use classical non-adaptive Runge-Kutta method to numerically solve
           y'=f(x,y) for initial x0, y0 going to x1 with n increments,
           returns y at x1.

           See Mathworld for more information.

     ----------------------------------------------------------------------

11.14. Statistics

   Average

 Average (m)

           Aliases: average Mean mean

           Calculate average of an entire matrix.

           See Mathworld for more information.

   GaussDistribution

 GaussDistribution (x,sigma)

           Integral of the GaussFunction from 0 to x (area under the normal
           curve).

           See Mathworld for more information.

   GaussFunction

 GaussFunction (x,sigma)

           The normalized Gauss distribution function (the normal curve).

           See Mathworld for more information.

   Median

 Median (m)

           Aliases: median

           Calculate median of an entire matrix.

           See Mathworld for more information.

   PopulationStandardDeviation

 PopulationStandardDeviation (m)

           Aliases: stdevp

           Calculate the population standard deviation of a whole matrix.

   RowAverage

 RowAverage (m)

           Aliases: RowMean

           Calculate average of each row in a matrix.

           See Mathworld for more information.

   RowMedian

 RowMedian (m)

           Calculate median of each row in a matrix and return a column
           vector of the medians.

           See Mathworld for more information.

   RowPopulationStandardDeviation

 RowPopulationStandardDeviation (m)

           Aliases: rowstdevp

           Calculate the population standard deviations of rows of a matrix
           and return a vertical vector.

   RowStandardDeviation

 RowStandardDeviation (m)

           Aliases: rowstdev

           Calculate the standard deviations of rows of a matrix and return a
           vertical vector.

   StandardDeviation

 StandardDeviation (m)

           Aliases: stdev

           Calculate the standard deviation of a whole matrix.

     ----------------------------------------------------------------------

11.15. Polynomials

   AddPoly

 AddPoly (p1,p2)

           Add two polynomials (vectors).

   DividePoly

 DividePoly (p,q,&r)

           Divide two polynomials (as vectors) using long division. Returns
           the quotient of the two polynomials. The optional argument r is
           used to return the remainder. The remainder will have lower degree
           than q.

           See Planetmath for more information.

   IsPoly

 IsPoly (p)

           Check if a vector is usable as a polynomial.

   MultiplyPoly

 MultiplyPoly (p1,p2)

           Multiply two polynomials (as vectors).

   NewtonsMethodPoly

 NewtonsMethodPoly (poly,guess,epsilon,maxn)

           Run newton's method on a polynomial to attempt to find a root,
           returns after two successive values are within epsilon or after
           maxn tries (then returns null).

   Poly2ndDerivative

 Poly2ndDerivative (p)

           Take second polynomial (as vector) derivative.

   PolyDerivative

 PolyDerivative (p)

           Take polynomial (as vector) derivative.

   PolyToFunction

 PolyToFunction (p)

           Make function out of a polynomial (as vector).

   PolyToString

 PolyToString (p,var...)

           Make string out of a polynomial (as vector).

   SubtractPoly

 SubtractPoly (p1,p2)

           Subtract two polynomials (as vectors).

   TrimPoly

 TrimPoly (p)

           Trim zeros from a polynomial (as vector).

     ----------------------------------------------------------------------

11.16. Set Theory

   Intersection

 Intersection (X,Y)

           Returns a set theoretic intersection of X and Y (X and Y are
           vectors pretending to be sets).

   IsIn

 IsIn (x,X)

           Returns true if the element x is in the set X (where X is a vector
           pretending to be a set).

   IsSubset

 IsSubset (X, Y)

           Returns true if X is a subset of Y (X and Y are vectors pretending
           to be sets).

   MakeSet

 MakeSet (X)

           Returns a vector where every element of X appears only once.

   SetMinus

 SetMinus (X,Y)

           Returns a set theoretic difference X-Y (X and Y are vectors
           pretending to be sets).

   Union

 Union (X,Y)

           Returns a set theoretic union of X and Y (X and Y are vectors
           pretending to be sets).

     ----------------------------------------------------------------------

11.17. Miscellaneous

   ASCIIToString

 ASCIIToString (vec)

           Convert a vector of ASCII values to a string.

   AlphabetToString

 AlphabetToString (vec,alphabet)

           Convert a vector of 0-based alphabet values (positions in the
           alphabet string) to a string.

   StringToASCII

 StringToASCII (str)

           Convert a string to a vector of ASCII values.

   StringToAlphabet

 StringToAlphabet (str,alphabet)

           Convert a string to a vector of 0-based alphabet values (positions
           in the alphabet string), -1's for unknown letters.

     ----------------------------------------------------------------------

11.18. Symbolic Operations

   SymbolicDerivative

 SymbolicDerivative (f)

           Attempt to symbolically differentiate the function f, where f is a
           function of one variable.

           Examples:

 genius> SymbolicDerivative(sin)
 genius> (`(x)=cos(x))
 genius> SymbolicDerivative(`(x)=7*x^2)
 genius> (`(x)=(7*(2*x)))

   SymbolicDerivativeTry

 SymbolicDerivativeTry (f)

           Attempt to symbolically differentiate the function f, where f is a
           function of one variable, returns null if unsuccessful but is
           silent. (See SymbolicDerivative)

   SymbolicNthDerivative

 SymbolicNthDerivative (f,n)

           Attempt to symbolically differentiate a function n times. (See
           SymbolicDerivative)

   SymbolicNthDerivativeTry

 SymbolicNthDerivativeTry (f,n)

           Attempt to symbolically differentiate a function n times quietly
           and return null on failure (See SymbolicNthDerivative)

   SymbolicTaylorApproximationFunction

 SymbolicTaylorApproximationFunction (f,x0,n)

           Attempt to construct the taylor approximation function around x0
           to the nth degree. (See SymbolicDerivative)

     ----------------------------------------------------------------------

11.19. Plotting

   LinePlot

 LinePlot (func1,func2,func3,...)

 LinePlot (func1,func2,func3,x1,x2,y1,y2)

           Plot a function (or several functions) with a line. First up to 10
           arguments are functions, then optionally you can specify the
           limits of the plotting window as x1, x2, y1, y2. If limits are not
           specified, then the currently set limits apply (See
           LinePlotWindow)

           Examples:

 genius> LinePlot(sin,cos)
 genius> LinePlot(`(x)=x^2,-1,1,0,1)

   LinePlotClear

 LinePlotClear ()

           Show the line plot window and clear out functions and any other
           lines that were drawn.

   LinePlotDrawLine

 LinePlotDrawLine (x1,y1,x2,y2,...)

 LinePlotDrawLine (v,...)

           Draw a line from x1,y1 to x2,y2. x1,y1, x2,y2 can be replaced by
           an n by 2 matrix for a longer line.

           Extra parameters can be added to specify line color and thickness,
           by adding a string "color" or "thickness" and the color and
           thickness after as a string or integer respectively.

           Examples:

 genius> LinePlotDrawLine(0,0,1,1,"color","blue","thickness",3)
 genius> LinePlotDrawLine([0,0;1,-1;-1,-1])

   LinePlotParametric

 LinePlotParametric (xfunc,yfunc,...)

 LinePlotParametric (xfunc,yfunc,t1,t2,tinc)

 LinePlotParametric (xfunc,yfunc,t1,t2,tinc,x1,x2,y1,y2)

           Plot a parametric function with a line. First come the functions
           for x and y then optionally the t limits as t1,t2,tinc, then
           optionally the limits as x1,x2,y1,y2.

   LinePlotCParametric

 LinePlotCParametric (func,...)

 LinePlotCParametric (func,t1,t2,tinc)

 LinePlotCParametric (func,t1,t2,tinc,x1,x2,y1,y2)

           Plot a parametric complex valued function with a line. First comes
           the function that returns x+iy, then optionally the t limits as
           t1,t2,tinc, then optionally the limits as x1,x2,y1,y2.

   SurfacePlot

 SurfacePlot (func)

 SurfacePlot (func,x1,x2,y1,y2,z1,z2)

           Plot a surface function which takes either two arguments or a
           complex number. First comes the function then optionally limits as
           x1, x2, y1, y2, z1, z2. If limits are not specified, then the
           currently set limits apply (See SurfacePlotWindow). Genius can
           only plot a single surface function at this time.

           Examples:

 genius> SurfacePlot(|sin|,-1,1,-1,1,0,1.5)
 genius> SurfacePlot(`(x,y)=x^2+y,-1,1,-1,1,-2,2)
 genius> SurfacePlot(`(z)=|z|^2,-1,1,-1,1,0,2)

     ----------------------------------------------------------------------

                      Chapter 12. Example Programs in GEL

   Here is a function that calculates factorials:

 function f(x) = if x <= 1 then 1 else (f(x-1)*x)

   With indentation it becomes:

 function f(x) = (
   if x <= 1 then
     1
   else
     (f(x-1)*x)
 )

   This is a direct port of the factorial function from the bc manpage. The
   syntax seems similar to bc, but different in that in GEL, the last
   expression is the one that is returned. Using the return function instead,
   it would be:

 function f(x) = (
   if (x <= 1) then return (1);
   return (f(x-1) * x)
 )

   By far the easiest way to define a factorial function would be using the
   product loop as follows. This is not only the shortest and fastest, but
   also probably the most readable version.

 function f(x) = prod k=1 to x do k

   Here is a larger example, this basically redefines the internal ref
   function to calculate the row echelon form of a matrix. The function ref
   is built in and much faster, but this example demonstrates some of the
   more complex features of GEL.

 # Calculate the row-echelon form of a matrix
 function MyOwnREF(m) = (
   if not IsMatrix(m) or not IsValueOnly(m) then
     (error("ref: argument not a value only matrix");bailout);
   s := min(rows(m), columns(m));
   i := 1;
   d := 1;
   while d <= s and i <= columns(m) do (

     # This just makes the anchor element non-zero if at
     # all possible
     if m@(d,i) == 0 then (
       j := d+1;
       while j <= rows(m) do (
         if m@(j,i) == 0 then
           (j=j+1;continue);
         a := m@(j,);
         m@(j,) := m@(d,);
         m@(d,) := a;
         j := j+1;
         break
       )
     );
     if m@(d,i) == 0 then
       (i:=i+1;continue);
    
     # Here comes the actual zeroing of all but the anchor
     # element rows
     j := d+1;
     while j <= rows(m)) do (
       if m@(j,i) != 0 then (
         m@(j,) := m@(j,)-(m@(j,i)/m@(d,i))*m@(d,)
       );
       j := j+1
     );
     m@(d,) := m@(d,) * (1/m@(d,i));
     d := d+1;
     i := i+1
   );
   m
 )

     ----------------------------------------------------------------------

                              Chapter 13. Settings

   To configure Genius Mathematics Tool, choose Settings->Preferences. There
   are several basic parameters provided by the calculator in addition to the
   ones provided by the standard library. These control how the calculator
   behaves.

   Note Changing Settings with GEL                                            
        Many of the settings in Genius are simply global variables, and can   
        be evaluated and assigned to in the same way as normal variables. See 
        Section 5.2 about evaluating and assigning to variables, and Section  
        11.3 for a list of settings that can be modified in this way.         
                                                                              
        As an example, you can set the maximum number of digits in a result   
        to 12 by typing:                                                      
                                                                              
        MaxDigits = 12                                                        

     ----------------------------------------------------------------------

13.1. Output

   Maximum digits to output

           The maximum digits in a result (MaxDigits)

   Results as floats

           If the results should be always printed as floats
           (ResultsAsFloats)

   Floats in scientific notation

           If floats should be in scientific notation (ScientificNotation)

   Always print full expressions

           Should we print out full expressions for non-numeric return values
           (longer than a line) (FullExpressions)

   Use mixed fractions

           If fractions should be printed as mixed fractions such as "1 1/3"
           rather than "4/3". (MixedFractions)

   Display 0.0 when floating point number is less than 10^-x (0=never chop)

           How to chop output. But only when other numbers nearby are large.
           See the documentation of the paramter OutputChopExponent.

   Only chop numbers when another number is greater than 10^-x

           When to chop output. This is set by the paramter
           OutputChopWhenExponent. See the documentation of the paramter
           OutputChopExponent.

   Remember output settings across sessions

           Should the output settings in the Number/Expression output options
           frame be remembered for next session. Does not apply to the
           Error/Info output options frame.

           If unchecked, either the default or any previously saved settings
           are used each time Genius starts up. Note that settings are saved
           at the end of the session, so if you wish to change the defaults
           check this box, restart Genius Mathematics Tool and then uncheck
           it again.

   Display errors in a dialog

           If set the errors will be displayed in a seprate dialog, if unset
           the errors will be printed on the console.

   Display information messages in a dialog

           If set the information messages will be displayed in a seprate
           dialog, if unset the information messages will be printed on the
           console.

   Maximum errors to display

           The maximum number of errors to return on one evaluation
           (MaxErrors). If you set this to 0 then all errors are always
           returned. Usually if some loop causes many errors, then it is
           unlikely that you will be able to make sense out of more than a
           few of these, so seeing a long list of errors is usually not
           helpful.

   In addition to these preferences, there are some preferences that can only
   be changed by setting them in the workspace console. For others that may
   affect the output see Section 11.3.

   IntegerOutputBase

           The base that will be used to output integers

   OutputStyle

           A string, can be "normal", "latex", "mathml" or "troff" and it
           will effect how matrices (and perhaps other stuff) is printed,
           useful for pasting into documents. Normal style is the default
           human readable printing style of Genius Mathematics Tool. The
           other styles are for typsetting in LaTeX, MathML (XML), or in
           Troff.

     ----------------------------------------------------------------------

13.2. Precision

   Floating point precision

           The floating point precision in bits (FloatPrecision). Note that
           changing this only affects newly computed quantities. Old values
           stored in variables are obviously still in the old precision and
           if you want to have them more precise you will have to recompute
           them. Exceptions to this are the system constants such as pi or e.

   Remember precision setting across sessions

           Should the precision setting be remembered for the next session.
           If unchecked, either the default or any previously saved setting
           is used each time Genius starts up. Note that settings are saved
           at the end of the session, so if you wish to change the default
           check this box, restart genius and then uncheck it again.

     ----------------------------------------------------------------------

13.3. Terminal

   Terminal refers to the console in the work area.

   Scrollback lines

           Lines of scrollback in the terminal.

   Font

           The font to use on the terminal.

   Black on white

           If to use black on white on the terminal.

   Blinking cursor

           If the cursor in the terminal should blink when the terminal is in
           focus. This can sometimes be annoying and it generates idle
           traffic if you are using Genius remotely.

     ----------------------------------------------------------------------

13.4. Memory

   Maximum number of nodes to allocate

           Internally all data is put onto small nodes in memory. This gives
           a limit on the maximum number of nodes to allocate for
           computations. This avoids the problem of running out of memory if
           you do something by mistake which uses too much memory, such as a
           recursion without end. This could slow your computer and make it
           hard to even interrupt the program.

           Once the limit is reached, Genius Mathematics Tool asks if you
           wish to interrupt the computation or if you wish to continue. If
           you continue, no limit is applied and it will be possible to run
           your computer out of memory. The limit will be applied again next
           time you execute a program or an expression on the Console
           regardless of how you answered the question.

           Setting the limit to zero means there is no limit to the amount of
           memory that genius uses.

     ----------------------------------------------------------------------

                   Chapter 14. About Genius Mathematics Tool

   Genius Mathematics Tool was written by Jiri (George) Lebl
   (<jirka@5z.com>). The history of Genius Mathematics Tool goes back to late
   1997. It was the first calculator program for GNOME, but it then grew
   beyond being just a desktop calculator. To find more information about
   Genius Mathematics Tool, please visit the Genius Web page.

   To report a bug or make a suggestion regarding this application or this
   manual, follow the directions in this document.

   This program is distributed under the terms of the GNU General Public
   license as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version. A copy of this license
   can be found at this link, or in the file COPYING included with the source
   code of this program.
