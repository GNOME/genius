
Genius Manual

Jiri Lebl

   University of California, San Diego

    <jirka@5z.com>

Kai Willadsen

   University of Queensland, Australia

    <kaiw@itee.uq.edu.au>

   Copyright  (c)  1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Jiri (George) Lebl

   Copyright (c) 2004 Kai Willadsen

   Permission  is  granted to copy, distribute and/or modify this
   document under the terms of the GNU Free Documentation License
   (GFDL), Version 1.1 or any later version published by the Free
   Software Foundation with no Invariant Sections, no Front-Cover
   Texts,  and  no  Back-Cover  Texts. You can find a copy of the
   GFDL at this link or in the file COPYING-DOCS distributed with
   this manual.

   This   manual  is  part  of  a  collection  of  GNOME  manuals
   distributed  under  the  GFDL.  If you want to distribute this
   manual separately from the collection, you can do so by adding
   a copy of the license to the manual, as described in section 6
   of the license.

   Many  of  the  names  used  by  companies to distinguish their
   products  and  services are claimed as trademarks. Where those
   names  appear  in  any GNOME documentation, and the members of
   the  GNOME  Documentation  Project  are  made  aware  of those
   trademarks,  then  the names are in capital letters or initial
   capital letters.

   DOCUMENT  AND  MODIFIED  VERSIONS OF THE DOCUMENT ARE PROVIDED
   UNDER THE TERMS OF THE GNU FREE DOCUMENTATION LICENSE WITH THE
   FURTHER UNDERSTANDING THAT:

    1. DOCUMENT IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTY
       OF  ANY  KIND,  EITHER  EXPRESSED  OR  IMPLIED, INCLUDING,
       WITHOUT   LIMITATION,  WARRANTIES  THAT  THE  DOCUMENT  OR
       MODIFIED  VERSION  OF  THE  DOCUMENT  IS  FREE  OF DEFECTS
       MERCHANTABLE,    FIT   FOR   A   PARTICULAR   PURPOSE   OR
       NON-INFRINGING.   THE  ENTIRE  RISK  AS  TO  THE  QUALITY,
       ACCURACY,  AND  PERFORMANCE  OF  THE  DOCUMENT OR MODIFIED
       VERSION  OF  THE DOCUMENT IS WITH YOU. SHOULD ANY DOCUMENT
       OR  MODIFIED  VERSION  PROVE DEFECTIVE IN ANY RESPECT, YOU
       (NOT THE INITIAL WRITER, AUTHOR OR ANY CONTRIBUTOR) ASSUME
       THE COST OF ANY NECESSARY SERVICING, REPAIR OR CORRECTION.
       THIS  DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART
       OF  THIS  LICENSE.  NO  USE  OF  ANY  DOCUMENT OR MODIFIED
       VERSION  OF  THE  DOCUMENT  IS AUTHORIZED HEREUNDER EXCEPT
       UNDER THIS DISCLAIMER; AND
    2. UNDER  NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY, WHETHER
       IN  TORT  (INCLUDING  NEGLIGENCE), CONTRACT, OR OTHERWISE,
       SHALL  THE AUTHOR, INITIAL WRITER, ANY CONTRIBUTOR, OR ANY
       DISTRIBUTOR  OF  THE  DOCUMENT  OR MODIFIED VERSION OF THE
       DOCUMENT,  OR  ANY  SUPPLIER  OF  ANY  OF SUCH PARTIES, BE
       LIABLE  TO  ANY  PERSON FOR ANY DIRECT, INDIRECT, SPECIAL,
       INCIDENTAL,  OR  CONSEQUENTIAL  DAMAGES  OF  ANY CHARACTER
       INCLUDING,   WITHOUT   LIMITATION,  DAMAGES  FOR  LOSS  OF
       GOODWILL,  WORK STOPPAGE, COMPUTER FAILURE OR MALFUNCTION,
       OR  ANY  AND ALL OTHER DAMAGES OR LOSSES ARISING OUT OF OR
       RELATING  TO  USE OF THE DOCUMENT AND MODIFIED VERSIONS OF
       THE  DOCUMENT, EVEN IF SUCH PARTY SHALL HAVE BEEN INFORMED
       OF THE POSSIBILITY OF SUCH DAMAGES.

   Feedback

   To report a bug or make a suggestion regarding the Genius Math
   Tool  application or this manual, follow the directions in the
   GNOME Feedback Page.
   This manual describes version 0.7.2 of Genius.
     _________________________________________________________

   Table of Contents
   Introduction
   Getting Started

        To Start Genius Math Tool
        When You Start Genius

   Basic usage

        Using the workarea
        To Create a New Program
        To Open and Run a Program

   GEL Basics

        Values

              Numbers
              Booleans
              Strings
              Null

        Using Variables

              Setting Variables
              Global variables
              Built-in variables
              Previous result variable

        Using Functions

              Defining functions
              Variable argument lists
              Passing functions to functions
              Operations on functions

        Absolute value / Modulus
        Separator
        Modular evaluation
        List of GEL operators

   Programming with GEL

        Conditionals
        Loops

              While loops
              For loops
              Foreach loops
              Break and continue

        Sums and products
        Comparison operators
        Returning
        References
        Lvalues

   Advanced Programming with GEL

        Error handling
        GEL startup procedure
        Loading programs

   Matrices in GEL

        Matrix support
        Conjugate transpose and transpose operator

   Polynomials in GEL

        Using Polynomials

   List of GEL functions

        Commands
        Basic
        Parameters
        Constants
        Numeric
        Trigonometry
        Number Theory
        Matrix Manipulation
        Linear Algebra
        Combinatorics
        Calculus
        Functions
        Equation Solving
        Statistics
        Polynomials
        Set Theory
        Miscellaneous

   Example programs in GEL
   Settings

        Output
        Precision
        Terminal

   About Genius Math Tool
     _________________________________________________________

Introduction

   The  Genius  Math Tool application is a general calculator for
   use   as   a   desktop  calculator,  an  educational  tool  in
   mathematics,  and is useful even for rudimentary research. The
   language  tries to be more `mathematical' in the sense that it
   should  be  `what  you mean is what you get', though of course
   that's  not  an  entirely  attainable  goal. It features using
   rationals, arbitrary precision integers and multiple precision
   floats  using  the GMP library. It also fully supports complex
   numbers.  It  can  work  with  matrices  and  vectors  and  do
   rudimetary  linear algebra. The language can have user-defined
   functions, variables and parameters.

   This  manual  describes  mostly  the  graphical version of the
   calculator,  but  the  language  is  of  course  the same. The
   command  line only version lacks the graphing capabilities and
   all   other  capabilities  that  require  the  graphical  user
   interface.
     _________________________________________________________

Getting Started

To Start Genius Math Tool

   You can start Genius Math Tool in the following ways:

   Applications menu
          Choose Office->Genius Math Tool.

          Note  that  depending  on your system installation this
          menu  item  may not be available. If it is not, you can
          open the Run dialog and executing gnome-genius.

   Command line
          Execute  the  following command: genius. Note that this
          will start the command line only version of genius, the
          graphical environment will not start and some functions
          such  as  plotting  will not be available. To start the
          full GNOME version of Genius execute gnome-genius.
     _________________________________________________________

When You Start Genius

   When  you  start  Genius  Math  Tool,  the following window is
   displayed.

   [genius_window.png]

   Figure 1. Genius Math Tool Window

   The Genius Math Tool window contains the following elements:

   Menubar.
          The  menus  on  the menubar contain all of the commands
          that you need to work with files in Genius Math Tool.

   Toolbar.
          The  toolbar contains a subset of the commands that you
          can access from the menubar.

   Working area
          The  working  area is the primary method of interacting
          with the application.

          The  working  area  initially  has just the Console tab
          which   is   the  main  way  of  interacting  with  the
          calculator.  Here  you type expressions and the results
          are immediately returned after you hit the Enter key.

          Alternatively  you  can write longer programs and those
          can  appear in separate tabs and can be stored in files
          for later retrieval.
     _________________________________________________________

Basic usage

Using the workarea

   Normally  you  interact with the calculator in the Console tab
   of  the  work  area.  If you are running the text only version
   then  the  console will be the only thing that is available to
   you.

   Type your expression into the Console workarea and press enter
   and the expression will be evaluated. To load a program, type
   genius> load path/to/program.gel

   To  list  files  in  the  current directory type ls, to change
   directory do cd directory as in the unix command shell.

   To get a list of functions and commands, type:
   genius> help

   If you wish to get more help on a specific function, type:
   genius> help FunctionName

   To view this manual, type:
   genius> manual

   The  most  simple  GEL  (The  Genius  Extension  Language,  or
   George`s Ego Leverage) expression just looks like mathematics.
   For example
   genius> 30*70 + 67^3.0 + ln(7) * (88.8/100)

   or
genius> 62734 + 812634 + 77^4 mod 5

   or
genius> | sin(37) - e^7 |

   or
genius> sum n=1 to 70 do 1/n

   (Last is the harmonic sum from 1 to 70)
     _________________________________________________________

To Create a New Program

   To  start  writing  a new program, choose File->New Program. A
   new  tab  will  appear  in  the  workarea. You can write a GEL
   program in this workarea.

   To  save  the  program  you've just written, choose File->Save
   As...
     _________________________________________________________

To Open and Run a Program

   To  open  a  file  in  order,  choose  File->Open.  A  new tab
   containing  the  file will appear in the workarea. You can use
   this to edit the file.

   To run a program from a file, choose File->Load and Run....
     _________________________________________________________

GEL Basics

   GEL  stands  for  Genius  Extension Language. Alternatively it
   also  stands for George's Ego Leverage. It is the language you
   use to write programs in Genius. A program in GEL is simply an
   expression that evaluates to a number.
     _________________________________________________________

Values

   Values  in GEL can be numbers, Booleans or strings. Values can
   be  used  in  calculations, assigned to variables and returned
   from functions, among other uses.
     _________________________________________________________

Numbers

   Integers  are  the  first  type of number in GEL. Integers are
   written in the normal way.
   1234

   Hexidecimal and octal numbers can be written using C notation.
   For example:
0x123ABC
01234

   Or   you   can   type  numbers  in  an  arbitrary  base  using
   <base>\<number>.  Digits  higher  than  10  use  letters  in a
   similar  way  to hexidecimal. For example, a number in base 23
   could be written:
23\1234ABCD

   The  second  type  of  GEL  number is rationals. Rationals are
   simply achieved by dividing two integers. So one could write:
   3/4

   to  get  three  quarters. Rationals also accept mixed fraction
   notation.  So  in  order to get one and three tenths you could
   write:
1 3/10

   The  next  type if number is floating point. These are entered
   in  a  similar fashion to C notation. You can use E, e or @ as
   the exponent delimiter. Note that using the exponent delimiter
   gives a float even if there is no decimal point in the number.
   Examples:
1.315
7.887e77
7.887e-77
.3
0.3
77e5

   The  final  type  of number in gel is the complex numbers. You
   can  enter  a  complex  number  as a sum of real and imaginary
   parts. The imaginary part ends with an i. Here are examples of
   entering complex numbers:
1+2i
8.01i
77*e^(1.3i)

   Important When entering imaginary numbers, a number must be in
   front of the i. If you use i by itself, Genius will interpret
   this as referring to the variable i. If you need to refer to i
   by itself, use 1i instead.

   In order to use mixed fraction notation with imaginary numbers
   you must have the mixed fraction in parentheses. (i.e., (1
      2/5)i)
     _________________________________________________________

Booleans

   Genius  also  supports  native Boolean values. The two Boolean
   constants are defined as true and false; these identifiers can
   be  used  like  any  other  variable.  You  can  also  use the
   identifiers  True,  TRUE,  False  and FALSE as aliases for the
   above.

   At  any  place where a Boolean expression is expected, you can
   use  a  Boolean value or any expression that produces either a
   number or a Boolean. If Genius needs to evaluate a number as a
   Boolean  it  will interpret 0 as false and any other number as
   true.

   In  addition,  you  can do arithmetic with Boolean values. For
   example:
   ( (1 + true) - false ) * true

   is the same as:
( (true or true) or not false ) and true

   Only  addition,  subtraction and multiplication are supported.
   If  you  mix  numbers  with Booleans in an expression then the
   numbers  are  converted  to  Booleans as described above. This
   means that, for example:
1 == true

   always  evaluates  to  true  since 1 will be converted to true
   before being compared to true.
     _________________________________________________________

Strings

   Like  numbers  and  Booleans,  strings in GEL can be stored as
   values  inside variables and passed to functions. You can also
   concatenate  a  string  with  another  value  using  the  plus
   operator. For example:
   a=2+3;"The result is: "+a

   will create the string:
The result is: 5

   You  can  also use C-like escape sequences such as \n,\t,\b,\a
   and  \r. To get a \ or " into the string you can quote it with
   a \. For example:
"Slash: \\ Quotes: \" Tabs: \t1\t2\t3"

   will make a string:
Slash: \ Quotes: " Tabs:        1       2       3

   In  addition,  you  can  use  the  library  function string to
   convert anything to a string. For example:
   string(22)

   will return
"22"

   Strings can also be compared with ==, != and <=> operators
     _________________________________________________________

Null

   Null is a special value. No operations can be performed on it,
   and nothing is printed when it is returned. Therefore, Null is
   useful  when  you  do not want output from an expression. Null
   can be obtained as an expression when you type . or nothing.

   Example:
x=5;.
x=5;
     _________________________________________________________

Using Variables

   Syntax:
   VariableName

   Example:
genius> e
= 2.71828182846

   To  evaluate  a variable by itself, just enter the name of the
   variable.  This will return the value of the variable. You can
   use  a  variable  anywhere  you would normally use a number or
   string.  In  addition,  variables  are necessary when defining
   functions that take arguments (see the Section called Defining
   functions).

   Tip Using Tab completion
       You can use Tab completion to get Genius to complete
   variable names for you. Try typing the first few letters of
      the name and pressing Tab.

   Important Variable names are case sensitive
             The names of variables are case sensitive. That means that
   variables named hello, HELLO and Hello are all different
      variables.
     _________________________________________________________

Setting Variables

   Syntax:
<identifier> = <value>
<identifier> := <value>

   Example:
x = 3
x := 3

   To  assign  to  a  variable,  use the = or := operators. These
   operators  set the value of the variable and return the number
   you set, so you can do things like
   a = b = 5

   The  = and := operators can both be used to set variables. The
   difference between them is that the := operator always acts as
   an   assignment  operator,  whereas  the  =  operator  may  be
   interpreted  as  testing  for  equality when used in a context
   where a Boolean expression is expected.
     _________________________________________________________

Global variables

   Sometimes  you'd  like  to set a global variable from inside a
   function.  For this, use the set function. Passing a string or
   a  quoted  identifier  to  this  function  sets  the  variable
   globally. For example, to set a to the value 3 you could call:
   set(`a,3)

   or:
set("a",3)

   Like  most  programming  languages,  Genius  has two different
   types  of  variables:  local (a variable set inside a function
   will  not  exist  outside  the  function)  and global (doesn't
   matter where you set them).
     _________________________________________________________

Built-in variables

   GEL has a number of built-in `variables', such as e. These are
   widely  used constants with a preset value, and they cannot be
   assigned  new  values.  There  are  a number of other built-in
   variables,  such as pi and GoldenRatio. See the Section called
   Constants  in  the  chapter called List of GEL functions for a
   full list.
     _________________________________________________________

Previous result variable

   The Ans and ans variables can be used to get the result of the
   last  expression.  For  example,  if  you  had  performed some
   calculation, to add 389 to the result you could do:
   Ans+389
     _________________________________________________________

Using Functions

   Syntax:
   FunctionName([argument1, argument2, ...])

   Example:
Factorial(5)
cos(2*pi)

   To  evaluate  a  function,  enter  the  name  of the function,
   followed  by  the  arguments  (if  any)  to  the  function  in
   parentheses.  This  will  return  the  result  of applying the
   function  to  its  arguments.  The  number of arguments to the
   function is, of course, different for each function.

   There  are  many built-in functions, such as sin, cos and tan.
   You  can  use  the  help  built-in  function  to get a list of
   available  functions,  or  see  the chapter called List of GEL
   functions for a full listing.

   Tip Using Tab completion
       You can use Tab completion to get Genius to complete
   function names for you. Try typing the first few letters of
      the name and pressing Tab.

   Important Function names are case sensitive
             The names of functions are case sensitive. That means that
   functions named dosomething, DOSOMETHING and DoSomething are
      all different functions.
     _________________________________________________________

Defining functions

   Syntax:
function <identifier>(<comma separated arguments>) = <function body>
<identifier> = (`() = <function body>)

   The  `  is the backquote character, and signifies an anonymous
   function.  By  setting  it  to a variable name you effectively
   define a function.

   A  function  takes zero or more comma separated arguments, and
   returns  the  result  of  the function body. Defining your own
   functions  is  primarily a matter of convenience; one possible
   use  is  to  have sets of functions defined in GEL files which
   Genius can load in order to make available.

   Example:
   function addup(a,b,c) = a+b+c

   then addup(1,4,9) yields 14
     _________________________________________________________

Variable argument lists

   If  you  include  ...  after  the  last  argument  name in the
   function  declaration,  then  Genius  will allow any number of
   arguments  to  be  passed  in  place  of  that argument. If no
   arguments  were passed then that argument will be set to null.
   Otherwise,  it  will be a horizontal vector containing all the
   arguments. For example:
   function f(a,b...) = b

   Then f(1,2,3) yields [2,3], while f(1) yields null.
     _________________________________________________________

Passing functions to functions

   In Genius, it is possible to pass a function as an argument to
   another  function.  This  can  be  done using either `function
   nodes' or anonymous functions.

   If  you  do  not  enter the parentheses after a function name,
   instead  of  being  evaluated,  the  function  will instead be
   returned  as  a `function node'. The function node can then be
   passed to another function.

   Example:
function f(a,b) = a(b)+1;
function b(x) = x*x;
f(b,2)

   If you want to pass a function that doesn't exist yet, you can
   use  an  anonymous  function  (see the Section called Defining
   functions).

   Syntax:
function(<comma separated arguments>) = <function body>
`(<comma separated arguments>) = <function body>

   Example:
function f(a,b) = a(b)+1;
f(`(x) = x*x,2)
     _________________________________________________________

Operations on functions

   Some  functions  allow  arithmetic operations, and some single
   argument  functions  such  as  exp  or  ln,  to operate on the
   function. For example,
   exp(sin*cos+4)

   will return a function that does
exp(sin(x)*cos(x)+4)

   This  can  be  useful  when  quickly  defining  functions. For
   example  to  create a function to perform the above operation,
   you can just type:
f = exp(sin*cos+4)

   This  can  also  be used in plotting. For example, to plot sin
   squared you can enter:
   LinePlot(sin^2)

   Warning Not all functions can be used in this way. In
   addition, when you use a binary operation the functions must
      take the same arguments.
     _________________________________________________________

Absolute value / Modulus

   You can make an absolute value of something by putting the |'s
   around it.
   |a-b|

   In  case the expression is a complex number the result will be
   the modulus (distance from the origin). So for example:
   |3 * e^(1i*pi)|

   returns 3.
     _________________________________________________________

Separator

   In  GEL  if you want to type more than one command you have to
   use  the  ;  operator, which is a way to separate expressions,
   such  a combined expression will return whatever is the result
   of the last one, so
   3 ; 5

   yields 5.

   This  will  require some parenthesizing to make it unambiguous
   sometimes,  especially if the ; is not the top most primitive.
   This  slightly  differs from other programming languages where
   the  ;  is  a  terminator  of  statements, whereas in GEL it's
   actually  a  binary  operator. If you are familiar with pascal
   this  should  be  second  nature.  However  genius can let you
   pretend  it's  a terminator somewhat, if a ";" is found at the
   end  of  a parenthesis or a block, genius will itself append a
   null  node  to  it  as  if you would have written ";". This is
   usefull  in  case  you don't want to return a value from say a
   loop,  or  if  you handle the return differently. Note that it
   will slow down the code if it's executed too often as there is
   one more operator involved.
     _________________________________________________________

Modular evaluation

   Sometimes  when working with large numbers, it might be faster
   if  results  are  modded after each calculation. To use it you
   just add "mod <integer>" after the expression.

   Example:
   2^(5!) * 3^(6!) mod 5

   You  can calculate the inverses of numbers mod some integer by
   just  using  rational  numbers  (of  course the inverse has to
   exist).

   Examples:
10^-1 mod 101
1/10 mod 101

   You  can  also  do  modular evaluation with matrices including
   taking inverses, powers and dividing.

   Example:
A = [1,2;3,4]
B = A^-1 mod 5
A*B mod 5

   This should yield the identity matrix as B will be the inverse
   of A mod 5.

   Some  functions  such  as  sqrt or log work in a different way
   when  in modulo mode. These will then work like their discrete
   versions working within the ring of integers you selected. For
   example:
genius> sqrt(4) mod 7
=
[2      5]
genius> 2*2 mod 7
= 4

   sqrt will actually return all the possible square roots.
     _________________________________________________________

List of GEL operators

   As  everything  in  gel  is  really  just an expression, it is
   really  just  all connected together with operators. Here is a
   list of the operators in GEL.

          a;b

          The separator, just evaluates both a and b, but returns
          only the result of b.

          a=b

          The assignment operator. This assigns b to a (a must be
          a valid lvalue) (note however that this operator may be
          translated  to  ==  if  used  in  a place where boolean
          expression is expected)

          a:=b

          The  assignment  operator.  Assigns b to a (a must be a
          valid  lvalue).  This  is  different  from = because it
          never gets translated to a ==.

          |a|

          Absolute value or modulus (if a is a complex number).

          See Mathworld for more information.

          a^b

          Exponentiation, raises a to the bth power.

          a.^b

          Element  by  element exponentiation. Raise each element
          of  a matrix a to the bth power. Or if b is a matrix of
          the  same  size  as a, then do the operation element by
          element.  If  a  is  a number and b is a matrix then it
          creates  matrix  of the same size as b with a raised to
          all the different powers in b.

          a+b

          Addition.  Adds  two  numbers,  matrices,  functions or
          strings.  If  you  add  a string to anything the result
          will just be a string.

          a-b

          Subtraction.   Subtract   two   numbers,   matrices  or
          functions.

          a*b

          Multiplication.    This    is    the    normal   matrix
          multiplication.

          a.*b

          Element  by  element  multiplication  if  a  and  b are
          matrices.

          a/b

          Division.

          a./b

          Element by element division.

          a\b

          Back division. That is this is the same as b/a.

          a.\b

          Element by element back division.

          a%b

          The  mod  operator.  This  does not turn on the modular
          mode, but just returns the remainder of a/b.

          a.%b

          Element  by  element  the  mod  operator.  Returns  the
          remaineder after element by element a./b.

          a mod b

          Modular   evaluation  operator.  The  expression  a  is
          evaluated  modulo  b.  See  the  Section called Modular
          evaluation.   Some   functions   and  operators  behave
          differently modulo an integer.

          a!

          Factorial operator. This is like 1*...*(n-2)*(n-1)*n.

          a!!

          Double     factorial    operator.    This    is    like
          1*...*(n-4)*(n-2)*n.

          a==b

          Equality operator (returns true or false).

          a!=b

          Inequality operator, returns true if a does not equal b
          else returns false.

          a<>b

          Alternative inequality operator, returns true if a does
          not equal b else returns false.

          a<=b

          Less  than or equal operator, returns true if a is less
          than or equal to b else returns false.

          a>=b

          Greater  than  or  equal operator, returns true if a is
          greater than or equal to b else returns false.

          a<=>b

          Comparison  operator.  If a is equal to b it returns 0,
          if  a  is less than b it returns -1 and if a is greater
          than b it returns 1.

          a and b

          Logical and.

          a or b

          Logical or.

          a xor b

          Logical xor.

          not a

          Logical not.

          -a

          Negation operator.

          &a

          Variable   referencing   (to   pass   a   reference  to
          something).  See  the  Section called References in the
          chapter called Programming with GEL.

          *a

          Variable   dereferencing   (to   access   a  referenced
          varible).  See  the  Section  called  References in the
          chapter called Programming with GEL.

          a'

          Matrix conjugate transpose.

          a.'

          Matrix transpose, does not conjugate the entries.

          a@(b,c)

          Get  element of a matrix in row b and column c. If b, c
          are  vectors,  then  this  gets  the corresponding rows
          columns or submatrices.

          a@(b,)

          Get row of a matrix (or rows if b is a vector).

          a@(b,:)

          Same as above.

          a@(,c)

          Get column of a matrix (or columns if c is a vector).

          a@(:,c)

          Same as above.

          a@(b)

          Get  an  element from a matrix treating it as a vector.
          This will traverse the matrix row-wise.

          a:b

          Build  a  vector  from a to b (or specify a row, column
          region  for  the @ operator). For example to get rows 2
          to 4 of mamtrix A we could do

          A@(2:4,)

          as 2:4 will return a vector [2,3,4].

          a:b:c

          Build  a  vector  from a to c with b as a step. That is
          for example

genius> 1:2:9
=
   `[1     3       5       7       9]

          (a)i

          Make  a imaginary number (multiply a by the imaginary).
          Note  that  normally  the number i is written as 1i. So
          the above is equal to

          (a)*1i

          `a

          Quote  an  identifier so that it doesn't get evaluated.
          Or quote a matrix so that it doesn't get expanded.

   Note The @() operator makes the : operator most useful. With
   this you can specify regions of a matrix. So that a@(2:4,6) is
   the rows 2,3,4 of the column 6. Or a@(,1:2) will get you the
   first two columns of a matrix. You can also assign to the @()
   operator, as long as the right value is a matrix that matches
      the region in size, or if it is any other type of value.

   Note The comparison operators (except for the <=> operator
   which behaves normally), are not strictly binary operators,
   they can in fact be grouped in the normal mathematical way,
   e.g.: (1<x<=y<5) is a legal boolean expression and means just
      what it should, that is (1<x and x=<y and y<5)

   Note The unitary minus operates in a different fashion
   depending on where it appears. If it appears before a number
   it binds very closely, if it appears in front of an expression
   it binds less than the power and factorial operators. So for
   example -1^k is really (-1)^k, but -foo(1)^k is really
   -(foo(1)^k). So be careful how you use it and if in doubt, add
      parentheses.
     _________________________________________________________

Programming with GEL

Conditionals

   Syntax:
   if <expression1> then <expression2> [else <expression3>]

   If  else is omitted, then if the expression1 yields 0, NULL is
   returned.

   Examples:
if(a==5)then(a=a-1)
if b<a then b=a
if c>0 then c=c-1 else c=0
a = ( if b>0 then b else 1 )

   Note  that  =  will  be  translated  to  == if used inside the
   expression for if, so
if a=5 then a=a-1

   will be interpreted as:
if a==5 then a:=a-1
     _________________________________________________________

Loops

While loops

   Syntax:
while <expression1> do <expression2>
until <expression1> do <expression2>
do <expression2> while <expression1>
do <expression2> until <expression1>

   These are similiar to other languages, however they return the
   result of the last iteration or NULL if no iteration was done.
   In the boolean expression, = is translated into == just as for
   the if statement.
     _________________________________________________________

For loops

   Syntax:
for <identifier> = <from> to <to> do <body>
for <identifier> = <from> to <to> by <increment> do <body>

   Loop  with  identifier  being set to all values from <from> to
   <to>,  optionally  using  an increment other than 1. These are
   faster,  nicer  and more compact than the normal loops such as
   above, but less flexible. The identifier must be an identifier
   and  can't  be  a  dereference. The value of identifier is the
   last  value  of  identifier,  or  <from>  if  body  was  never
   evaluated.  The variable is guaranteed to be initialized after
   a  loop,  so  you can safely use it. Also the <from>, <to> and
   <increment>  must  be  non  complex  values.  The  <to> is not
   guaranteed  to be hit, but will never be overshot, for example
   the following prints out odd numbers from 1 to 19:
   for i = 1 to 20 by 2 do print(i)
     _________________________________________________________

Foreach loops

   Syntax:
     for <identifier> in <matrix> do <body>

   For  each  element, going row by row from left to right do the
   body. To print numbers 1,2,3 and 4 in this order you could do:
   for n in [1,2:3,4] do print(n)

   If  you  wish to run through the rows and columns of a matrix,
   you  can use the RowsOf and ColumnsOf functions which return a
   vector of the rows or columns of the matrix. So,
   for n in RowsOf ([1,2:3,4]) do print(n)

   will print out [1,2] and then [3,4].
     _________________________________________________________

Break and continue

   You can also use the break and continue commands in loops. The
   continue continue command will restart the current loop at its
   next  iteration,  while  the  break  command exits the current
   loop.
while(<expression1>) do (
  if(<expression2>) break
  else if(<expression3>) continue;
  <expression4>
)
     _________________________________________________________

Sums and products

   Syntax:
sum <identifier> = <from> to <to> do <body>
sum <identifier> = <from> to <to> by <increment> do <body>
sum <identifier> in <matrix> do <body>
prod <identifier> = <from> to <to> do <body>
prod <identifier> = <from> to <to> by <increment> do <body>
prod <identifier> in <matrix> do <body>

   If  you  substitute  for with sum or prod, then you will get a
   sum  or  a product instead of a for loop. Instead of returning
   the  last  value,  these will return the sum or the product of
   the values respectively.

   If  no body is executed (for example sum i=1 to 0 do ...) then
   sum   returns  0  and  prod  returns  1  as  is  the  standard
   convention.
     _________________________________________________________

Comparison operators

   ==, >=, <=, !=, <>, <, > return true or false.

   != and <> are the same thing and mean "is not equal to".

   Normally  =  is translated to == if it happens to be somewhere
   where GEL is expecing a condition such as in the if condition.
   For example
if a=b then c
if a==b then c

   are the same thing in GEL. However you should really use == or
   := when you want to compare or assign respectively if you want
   your code to be easy to read and to avoid mistakes.

   All  the  comparison  operators  (except  for the <=> operator
   which  behaves  normally),  are not strictly binary operators,
   they  can  in  fact be grouped in the normal mathematical way,
   e.g.:  (1<x<=y<5) is a legal boolean expression and means just
   what it should, that is (1<x and x=<y and y<5)

   The <=> operator returns -1 if left side is smaller, 0 if both
   sides are equal, 1 if left side is larger.

   To  build  up  logical expressions use the words not, and, or,
   xor.

   "or"  and  "and"  are  special  beasts  as they evaluate their
   arguemnts  one  by  one,  so  the  usual trick for conditional
   evaluation  works here as well. (e.g., "1 or a=1" will not set
   a=1 since the first argument was true)
     _________________________________________________________

Returning

   Sometimes  you don't want to return the last thing calculated.
   You  may,  for  example,  want  to  return  from a middle of a
   function. In this case, you can use the return keyword. return
   takes one argument, which is the value to be returned.

   Example:
function f(x) = (
  y=1;
  while true do (
    if x>50 then return y;
    y=y+1;
    x=x+1
  )
)
     _________________________________________________________

References

   GEL  contains  references with a C like syntax. & references a
   variable  and  *  dereferences  a  variable.  Both can only be
   applied to an identifier, so **a is not legal in GEL.

   Example:
a=1;
b=&a;
*b=2;

   now 'a' contains 2.
function f(x) = x+1;
t=&f;
*t(3)

   gives us 4.
     _________________________________________________________

Lvalues

   An  lvalue  is  the  left hand side of an assignment. In other
   words,  an  lvalue  is  what  you  assign  something to. Valid
   lvalues are:

   a
          Identifier.  Here  we  would  be setting the varable of
          name a.

   *a
          Dereference  of  an  identifier. This will set whatever
          variable a points to.

   a@(<region>)
          A  region  of  a  matrix.  Here the region is specified
          normally as with the regular @() operator, and can be a
          single entry, or an entire region of the matrix.

   Examples:
a:=4
*tmp := 89
a@(1,1) := 5
a@(4:8,3) := [1,2,3,4,5]'

   Note  that  both  := and = can be used interchangably. That is
   except  if  the  assignment appears in a condition. It is thus
   always safer to just use := when you mean assignment.
     _________________________________________________________

Advanced Programming with GEL

Error handling

   If  you  detect an error in your function, you can bail out of
   it.  For  normal errors, such as wrong types of arguments, you
   can fail to compute the function by adding the empty statement
   bailout.  If  something  went  really  wrong  and  you want to
   completely   kill   the   current  computation,  you  can  use
   exception.

   Look at lib.gel for some examples.
     _________________________________________________________

GEL startup procedure

   First  the  program  looks for the installed library file (the
   compiled version lib.cgel) in the installed directory, then it
   looks into the current directory, and then it tries to load an
   uncompiled file called ~/.geniusinit.

   If you ever change the the library its installed place, you'll
   have  to  first  compile it with genius --compile loader.gel >
   lib.cgel
     _________________________________________________________

Loading programs

   Sometimes you have a larger program that you wrote into a file
   and  want  to read in that file. In these situations, you have
   two  options.  You  can keep the functions you use most inside
   the  ~/.geniusinit file. Or if you want to load up a file in a
   middle  of  a  session  (or from within another file), you can
   type  load  <list  of filenames> at the prompt. This has to be
   done  on the top level and not inside any function or whatnot,
   and  it  cannot  be  part  of  any  expression.  It also has a
   slightly  different  syntax  than  the  rest  of  genius, more
   similiar  to a shell. You can enter the file in quotes. If you
   use  the  ''  quotes, you will get exactly the string that you
   typed,  if  you  use the "" quotes, special characters will be
   unescaped as they are for strings. Example:
load program1.gel program2.gel
load "Weird File Name With SPACES.gel"

   There  are also cd, pwd and ls commands built in. cd will take
   one  argument, ls will take an argument which is like the glob
   in  the unix shell (i.e., you can use wildcards). pwd takes no
   arguments. For example:
cd directory_with_gel_programs
ls *.gel
     _________________________________________________________

Matrices in GEL

Matrix support

   To  enter  matrixes use one of the following two syntaxes. You
   can  either  enter  the matrix separating values by commas and
   rows  by semicolons, or separating values by tabs (not usually
   easily  possible  on  the  console, only in files) and rows by
   returns,  or  any  combination  of  the two. So to enter a 3x3
   matrix of numbers 1-9 you could do
   [1,2,3;4,5,6;7,8,9]

   or
[1 2 3
 4 5 6
 7 8 9]

   or
[1, 2, 3
 4, 5, 6
 7, 8, 9]

   Do  not  use  both  ';'  and  return  at once on the same line
   though.  Also do not mix tabs and commas. It is just safest to
   use commas as separators.

   You  can  also use the matrix expansion functionality to enter
   matricies. For example you can do:
a = [ 1, 2, 3
      4, 5, 6
      7, 8, 9]
b = [ a,  10
      11, 12]

   and you should get
[1  2  3  10
 4  5  6  10
 7  8  9  10
 11 11 11 12]

   similiarly  you  can  build matricies out of vectors and other
   stuff like that.

   Another  thing  is that non-specified spots are initialized to
   0, so
[1, 2, 3
 4, 5
 6]

   will end up being
[1 2 3
 4 5 0
 6 0 0]

   Note Be careful about using whitespace and returns for
   expressions inside the [ ] brackets, as they have a slightly
      different meaning and could mess you up.
     _________________________________________________________

Conjugate transpose and transpose operator

   You  can conjugate transpose a matrix by using the ' operator.
   For example:
   [1,2,3]*[4,5,6]'

   We  transpose  the second vector to make matrix multiplication
   possible.

   If you just want to transpose a matrix without conjugating it,
   you would use the .' operator. For example:
   [1,2,3]*[4,5,6i].'
     _________________________________________________________

Polynomials in GEL

   Currently  Genius  can  handle  polynomials  of  one  variable
   written out as vectors and do some basic operations with them.
   It is planned to expand this support further.
     _________________________________________________________

Using Polynomials

   Genius  can  do  some  things  on  polynomials. Polynomials in
   Genius  are just horizontal vectors with value only nodes. The
   power  of  the  term  is  the position in the vector, with the
   first position being 0. So,
   [1,2,3]

   translates to a polynomial of
1 + 2*x + 3*x^2

   You  can  add,  subtract  and  multiply  polynomials using the
   AddPoly, SubtractPoly and MultiplyPoly functions respectively.
   You  can  print  a polynomial using the PolyToString function.
   For example,
   PolyToString([1,2,3],"y")

   gives
3*y^2 + 2*y + 1

   You  can  also get a function representation of the polynomial
   so   that   you  can  evaluate  it.  This  is  done  by  using
   PolyToFunction,  which returns an anonymous function which you
   can assign to something.
f = PolyToFunction([0,1,1])
f(2)

   Look  at  the  function  table  for  the  rest  of  polynomial
   functions.
     _________________________________________________________

List of GEL functions

   To get help on a specific function from the console type:
   help FunctionName
     _________________________________________________________

Commands

   help

          help

          help FunctionName

          Print help (or help on a function/command).

   load

          load "file.gel"

          Load a file into the interpretor.

   cd

          cd /directory/name

          Change working directory.

   pwd

          pwd

          Change working directory.

   ls

          ls

          List files in the current directory.

   plugin

          plugin plugin_name

          Load a plugin.
     _________________________________________________________

Basic

   Compose

          Compose (f,g)

          Compose two functions

   GetCurrentModulo

          GetCurrentModulo

          Get   current  modulo  from  the  context  outside  the
          function

   Identity

          Identity (x)

          Identity function, returns its argument

   IntegerFromBoolean

          IntegerFromBoolean (bval)

          Make integer (0 for false or 1 for true) from a boolean
          value.  bval  can  also  be  a  number  in which case a
          non-zero  value  will  be  interpreted as true and zero
          will be interpretted as false.

   IsBoolean

          IsBoolean (arg)

          Check if argument is a boolean (and not a number)

   IsFunction

          IsFunction (arg)

          Check if argument is a function

   IsFunctionRef

          IsFunctionRef (arg)

          Check if argument is a function reference

   IsMatrix

          IsMatrix (arg)

          Check if argument is a matrix

   IsNull

          IsNull (arg)

          Check if argument is a null

   IsString

          IsString (arg)

          Check if argument is a text string

   IsValue

          IsValue (arg)

          Check if argument is a number

   SetFunctionFlags

          SetFunctionFlags (id,flags...)

          Set  flags for a function, currently "PropagateMod" and
          "NoModuloArguments"

   SetHelp

          SetHelp (id,category,desc)

          Set  the  category  and  help  description  line  for a
          function

   SetHelpAlias

          SetHelpAlias (id,alias)

          Sets up a help alias

   chdir

          chdir (dir)

          Changes current directory

   display

          display (str,expr)

          Display a string and an expression

   error

          error (str)

          Prints a string to the error stream

   exit

          exit

          Aliases: quit

          Exits the program

   false

          false

          Aliases: False FALSE

          The false boolean value

   manual

          manual

          Displays the user manual

   print

          print (str)

          Prints an expression

   printn

          printn (str)

          Prints an expression without a trailing newline

   protect

          protect (id)

          Protect a variable from being modified

   set

          set (id,val)

          Set a global variable. The id can be either a string or
          a quoted identifier as follows. For example:

          set(`x,1)

          will set the global variable x to the value 1.

   string

          string (s)

          Make  a  string.  This  will  make  a string out of any
          argument.

   true

          true

          Aliases: True TRUE

          The true boolean value

   unprotect

          unprotect (id)

          Unprotect a variable from being modified

   warranty

          warranty

          Gives the warranty information
     _________________________________________________________

Parameters

   ChopTolerance

          ChopTolerance = number

          Tolerance of the Chop function

   ContinuousNumberOfTries

          ContinuousNumberOfTries = number

          How  many  iterations  to  try  to  find  the limit for
          continuity and limits

   ContinuousSFS

          ContinuousSFS = number

          How  many  successive  steps to be within tolerance for
          calculation of continuity

   ContinuousTolerance

          ContinuousTolerance = number

          Tolerance   for   continuity   of   functions  and  for
          calculating the limit

   DerivativeNumberOfTries

          DerivativeNumberOfTries = number

          How  many  iterations  to  try  to  find  the limit for
          derivative

   DerivativeSFS

          DerivativeSFS = number

          How  many  successive  steps to be within tolerance for
          calculation of derivative

   DerivativeTolerance

          DerivativeTolerance = number

          Tolerance for calculating the derivatives of functions

   ErrorFunctionTolerance

          ErrorFunctionTolerance = number

          Tolerance of the ErrorFunction

   FloatPrecision

          FloatPrecision = number

          Floating point precision

   FullExpressions

          FullExpressions = boolean

          Print full expressions, even if more than a line

   GaussDistributionTolerance

          GaussDistributionTolerance = number

          Tolerance of the GaussDistribution function

   IntegerOutputBase

          IntegerOutputBase = number

          Integer output base

   IsPrimeMillerRabinReps

          IsPrimeMillerRabinReps = number

          Number  of  extra Miller-Rabin tests to run on a number
          before declaring it a prime in IsPrime

   MaxDigits

          MaxDigits = number

          Maximum digits to display

   MaxErrors

          MaxErrors = number

          Maximum errors to display

   MixedFractions

          MixedFractions = boolean

          If true, mixed fractions are printed

   NumericalIntegralFunction

          NumericalIntegralFunction = function

          The   function   used   for  numerical  integration  in
          NumericalIntegral

   NumericalIntegralSteps

          NumericalIntegralSteps = number

          Steps to perform in NumericalIntegral

   OutputStyle

          OutputStyle = string

          Output  style,  this  can  be  normal, latex, mathml or
          troff.

          This  affects  mostly  how  matrices  and fractions are
          printed  out  and is useful for pasting into documents.
          For example you can set this to the latex by:

          OutputStyle = "latex"

   ResultsAsFloats

          ResultsAsFloats = boolean

          Convert all results to floats before printing

   ScientificNotation

          ScientificNotation = boolean

          Use scientific notation

   SumProductNumberOfTries

          SumProductNumberOfTries = number

          How   many   iterations  to  try  for  InfiniteSum  and
          InfiniteProduct

   SumProductSFS

          SumProductSFS = number

          How  many  successive  steps to be within tolerance for
          InfiniteSum and InfiniteProduct

   SumProductTolerance

          SumProductTolerance = number

          Tolerance for InfiniteSum and InfiniteProduct
     _________________________________________________________

Constants

   EulerConstant

          EulerConstant

          Aliases: gamma

          Euler's    Constant   gamma.   Sometimes   called   the
          Euler-Mascheroni constant.

          See Planetmath or Mathworld for more information.

   GoldenRatio

          GoldenRatio

          The Golden Ratio

          See Planetmath or Mathworld for more information.

   Gravity

          Gravity

          Free fall acceleration

   e

          e

          The   base   of  the  natural  logarithm.  e^x  is  the
          exponential   function   exp.   This   is   the  number
          approximately 2.71828182846...

          See Planetmath or Mathworld for more information.

   pi

          pi

          The  number  pi,  that  is  the  ratio  of  a  circle's
          circumference  to  it's diameter. This is approximately
          3.14159265359...

          See Planetmath or Mathworld for more information.
     _________________________________________________________

Numeric

   AbsoluteValue

          AbsoluteValue (x)

          Aliases: abs

          Absolute  value of a number and if x is a complex value
          the modulus of x.

          See Mathworld for more information.

   Chop

          Chop (x)

          Replace very small number with zero

   ComplexConjugate

          ComplexConjugate (M)

          Aliases: conj Conj

          Calculates the conjugate

   Denominator

          Denominator (x)

          Get the denominator of a rational number

   FractionalPart

          FractionalPart (x)

          Return the fractional part of a number

   Im

          Im (z)

          Aliases: ImaginaryPart

          Get the imaginary part of a complex number

   IntegerQuotient

          IntegerQuotient (m,n)

          Division w/o remainder

   IsComplex

          IsComplex (num)

          Check if argument is a complex (non-real) number

   IsComplexRational

          IsComplexRational (num)

          Check if argument is a possibly complex rational number

   IsFloat

          IsFloat (num)

          Check   if   argument   is   a  floating  point  number
          (non-complex)

   IsGaussInteger

          IsGaussInteger (num)

          Aliases: IsComplexInteger

          Check if argument is a possibly complex integer

   IsGaussianInteger

          IsGaussianInteger (z)

          Check if argument is a gaussian integer

   IsInteger

          IsInteger (num)

          Check if argument is an integer (non-complex)

   IsNonNegativeInteger

          IsNonNegativeInteger (num)

          Check if argument is a non-negative real integer.

   IsPositiveInteger

          IsPositiveInteger (num)

          Aliases: IsNaturalNumber

          Check if argument is a positive real integer.

   IsRational

          IsRational (num)

          Check if argument is a rational number (non-complex)

   IsReal

          IsReal (num)

          Check if argument is a real number

   Numerator

          Numerator (x)

          Get the numerator of a rational number

   Re

          Re (z)

          Aliases: RealPart

          Get the real part of a complex number

   Sign

          Sign (x)

          Aliases: sign

          Return  the  sign  of  a  number. That is returns -1 if
          value is negative, 0 if value is zero and 1 if value is
          positive. If x is a complex value then Sign returns the
          direction or 0.

   ceil

          ceil (x)

          Aliases: Ceiling

          Get the lowest integer more than or equal to n

   exp

          exp (x)

          The  exponential  function.  This  is  the function e^x
          where e is the base of the natural logarithm.

          See Planetmath or Mathworld for more information.

   float

          float (x)

          Make number a floating point value. That is returns the
          floating point representation of the number x.

   floor

          floor (x)

          Aliases: Floor

          Get the highest integer less than or equal to n

   ln

          ln (x)

          The natural logarithm, the logarithm to base e.

   log

          log (x,b...)

          Logarithm  of  x base b (calls DiscreteLog if in modulo
          mode), if base is not given, e is used.

   log10

          log10 (x)

          Logarithm of x base 10

   log2

          log2 (x)

          Aliases: lg

          Logarithm of x base 2

   max

          max (a,args...)

          Aliases: Max Maximum

          Returns the maximum of arguments or matrix

   min

          min (a,args...)

          Aliases: Min Minimum

          Returns the minimum of arguments or matrix

   rand

          rand (size...)

          Generate  random  float  in the range [0,1). If size is
          given  then  a matrix (if two numbers are specified) or
          vector  (if  one number is specified) of the given size
          returned.

   randint

          randint (max,size...)

          Generate  random  integer in the range [0,max). If size
          is  given  then a matrix (if two numbers are specified)
          or  vector  (if  one  number is specified) of the given
          size returned. For example

genius> randint(4)
= 3
genius> randint(4,2)
=
[0      1]
genius> randint(4,2,3)
=
[2      2       1
    0      0       3]

   round

          round (x)

          Aliases: Round

          Round a number

   sqrt

          sqrt (x)

          Aliases: SquareRoot

          The  square  root.  When  operating modulo some integer
          will  return  either  a  null or a vector of the square
          roots. Examples:

genius> sqrt(2)
= 1.41421356237
genius> sqrt(-1)
= 1i
genius> sqrt(4) mod 7
=
[2      5]
genius> 2*2 mod 7
   = 4

          See Planetmath for more information.

   trunc

          trunc (x)

          Aliases: Truncate IntegerPart

          Truncate number to an integer (return the integer part)
     _________________________________________________________

Trigonometry

   acos

          acos (x)

          Aliases: arccos

          The arccos (reverse cos) function

   acosh

          acosh (x)

          Aliases: arccosh

          The arccosh (reverse cosh) function

   acot

          acot (x)

          Aliases: arccot

          The arccot (reverse cot) function

   acoth

          acoth (x)

          Aliases: arccoth

          The arccoth (reverse coth) function

   acsc

          acsc (x)

          Aliases: arccsc

          The reverse cosecant function

   acsch

          acsch (x)

          Aliases: arccsch

          The reverse hyperbolic cosecant function

   asec

          asec (x)

          Aliases: arcsec

          The reverse secant function

   asech

          asech (x)

          Aliases: arcsech

          The reverse hyperbolic secant function

   asin

          asin (x)

          Aliases: arcsin

          The arcsin (reverse sin) function

   asinh

          asinh (x)

          Aliases: arcsinh

          The arcsinh (reverse sinh) function

   atan

          atan (x)

          Aliases: arctan

          Calculates the arctan function

   atanh

          atanh (x)

          Aliases: arctanh

          The arctanh (reverse tanh) function

   cos

          cos (x)

          Calculates the cosine function.

          See Planetmath for more information.

   cosh

          cosh (x)

          Calculates the hyperbolic cosine function

          See Planetmath for more information.

   cot

          cot (x)

          The cotangent function

          See Planetmath for more information.

   coth

          coth (x)

          The hyperbolic cotangent function

          See Planetmath for more information.

   csc

          csc (x)

          The cosecant function

          See Planetmath for more information.

   csch

          csch (x)

          The hyperbolic cosecant function

          See Planetmath for more information.

   sec

          sec (x)

          The secant function

          See Planetmath for more information.

   sech

          sech (x)

          The hyperbolic secant function

          See Planetmath for more information.

   sin

          sin (x)

          Calculates the sine function.

          See Planetmath for more information.

   sinh

          sinh (x)

          Calculates the hyperbolic sine function

          See Planetmath for more information.

   tan

          tan (x)

          Calculates the tan function

          See Planetmath for more information.

   tanh

          tanh (x)

          The hyperbolic tangent function

          See Planetmath for more information.
     _________________________________________________________

Number Theory

   AreRelativelyPrime

          AreRelativelyPrime (a,b)

          Are the real integers a and b relatively prime? Returns
          true or false.

          See Mathworld for more information.

   BernoulliNumber

          BernoulliNumber (n)

          Return the nth Bernoulli number

   ChineseRemainder

          ChineseRemainder (a,m)

          Aliases: CRT

          Find the x that solves the system given by the vector a
          and  modulo  the  elements  of  m,  using  the  Chinese
          Remainder Theorem.

          See Planetmath or Mathworld for more information.

   CombineFactorizations

          CombineFactorizations (a,b)

          Given two factorizations, give the factorization of the
          product.

          See Factorize.

   ConvertFromBase

          ConvertFromBase (v,b)

          Convert  a vector of values indicating powers of b to a
          number

   ConvertToBase

          ConvertToBase (n,b)

          Convert  a number to a vector of powers for elements in
          base b

   DiscreteLog

          DiscreteLog (n,b,q)

          Find discrete log of n base b in F_q where q is a prime
          using the Silver-Pohlig-Hellman algoritm

          See Mathworld for more information.

   Divides

          Divides (m,n)

          Checks divisibility (if m divides n)

   EulerPhi

          EulerPhi (n)

          Compute  the  Euler  phi  function  for  n, that is the
          number  of integers between 1 and n relatively prime to
          n.

          See Planetmath or Mathworld for more information.

   ExactDivision

          ExactDivision (n,d)

          Return  n/d  but  only  if  d  divides n. If d does not
          divide  n then this function returns garbage. This is a
          lot  faster  for  very large numbers than the operation
          n/d,  but  of  course  only useful if you know that the
          division is exact.

   Factorize

          Factorize (n)

          Return factorization of a number as a matrix. The first
          row  is  the  primes in the factorization (including 1)
          and the second row are the powers. So for example:

genius> Factorize(11*11*13)
=
[1      11      13
    1      2       1]

   Factors

          Factors (n)

          Return  all factors of n in a vector. This includes all
          the  non-prime  factors  as well. It includes 1 and the
          number  itself. So for example to print all the perfect
          numbers  (those  that  are sums of their factors) up to
          the  number  1000  you could do (this is of course very
          inefficent)

for n=1 to 1000 do (
    if MatrixSum (Factors(n)) == 2*n then
        print(n)
   )

   FermatFactorization

          FermatFactorization (n,tries)

          Attempt  fermat  factorization  of  n into (t-s)*(t+s),
          returns   t  and  s  as  a  vector  if  possible,  null
          otherwise.  tries  specifies the number of tries before
          giving up.

          This  is  a fairly good factorization if your number is
          the  product of two factors that are very close to each
          other.

   FindPrimitiveElementMod

          FindPrimitiveElementMod (q)

          Find  the  first  primitive element in F_q (q must be a
          prime)

   FindRandomPrimitiveElementMod

          FindRandomPrimitiveElementMod (q)

          Find  a  random  primitive  element in F_q (q must be a
          prime)

   IndexCalculus

          IndexCalculus (n,b,q,S)

          Compute  discrete  log  base  b of n in F_q (q a prime)
          using the factor base S. S should be a column of primes
          possibly    with   second   column   precalculated   by
          IndexCalculusPrecalculation.

   IndexCalculusPrecalculation

          IndexCalculusPrecalculation (b,q,S)

          Run   the  precalculation  step  of  IndexCalculus  for
          logarithms  base  b  in  F_q (q a prime) for the factor
          base S (where S is a column vector of primes). The logs
          will  be  precalculated  and  returned  in  the  second
          column.

   IsEven

          IsEven (n)

          Tests if an integer is even.

   IsNthPower

          IsNthPower (m,n)

          Tests  if  a  rational number m is a perfect nth power.
          See also IsPerfectPower and IsPerfectSquare.

   IsOdd

          IsOdd (n)

          Tests if an integer is odd

   IsPerfectPower

          IsPerfectPower (n)

          Check a number for being any perfect power (a^b)

   IsPerfectSquare

          IsPerfectSquare (n)

          Check  a  number for being a perfect square. The number
          must be a real integer. Negative integers are of course
          never perfect squares.

   IsPrime

          IsPrime (n)

          Tests  primality  of  integers,  for  numbers less than
          25*10^9   the   answer  is  deterministic  (if  Riemann
          hypothesis   is   true).   For   numbers   larger,  the
          probability    of   a   false   positive   depends   on
          IsPrimeMillerRabinReps.  That  is  the  probability  of
          false positive is 1/4 to the power
          IsPrimeMillerRabinReps.  The default value of 22 yields
          a probability of about 5.7e-14.

          If  false  is returned, you can be sure that the number
          is  a composite. If you want to be absolutely sure that
          you have a prime you can use MillerRabinTestSure but it
          may take a lot longer.

          See Mathworld for more information.

   IsPrimitiveMod

          IsPrimitiveMod (g,q)

          Check  if g is primitive in F_q, where q is a prime. If
          q is not prime results are bogus.

   IsPrimitiveModWithPrimeFactors

          IsPrimitiveModWithPrimeFactors (g,q,f)

          Check  if g is primitive in F_q, where q is a prime and
          f  is  a  vector  of  prime factors of q-1. If q is not
          prime results are bogus.

   IsPseudoprime

          IsPseudoprime (n,b)

          If  n  is a pseudoprime base b but not a prime, that is
          if b^(n-1) == 1 mod n

   IsStrongPseudoprime

          IsStrongPseudoprime (n,b)

          Test  if  n is a strong pseudoprime to base b but not a
          prime

   Jacobi

          Jacobi (a,b)

          Aliases: JacobiSymbol

          Calculate the Jacobi symbol (a/b) (b should be odd)

   JacobiKronecker

          JacobiKronecker (a,b)

          Aliases: JacobiKroneckerSymbol

          Calculate  the  Jacobi  symbol (a/b) with the Kronecker
          extension  (a/2)=(2/a)  when  a  odd, or (a/2)=0 when a
          even

   LeastAbsoluteResidue

          LeastAbsoluteResidue (a,n)

          Return  the  residue of a mod n with the least absolute
          value (in the interval -n/2 to n/2)

   Legendre

          Legendre (a,p)

          Aliases: LegendreSymbol

          Calculate the Legendre symbol (a/p).

          See Mathworld for more information.

   LucasLehmer

          LucasLehmer (p)

          Test  if  Mp is a Mersenne prime using the Lucas-Lehmer
          test

          See Mathworld for more information.

   LucasNumber

          LucasNumber (n)

          Returns the n'th Lucas number

          See Mathworld for more information.

   MaximalPrimePowerFactors

          MaximalPrimePowerFactors (n)

          Return all maximal prime power factors of a number

   MillerRabinTest

          MillerRabinTest (n,reps)

          Use  the  Miller-Rabin primality test on n, reps number
          of   times.   The  probability  of  false  positive  is
          (1/4)^reps.  It  is  probably  usually  better  to  use
          IsPrime  since  that  is  faster  and better on smaller
          integers.

          See Mathworld for more information.

   MillerRabinTestSure

          MillerRabinTestSure (n)

          Use  the  Miller-Rabin  primality test on n with enough
          bases  that assuming the Generalized Reimann Hypothesis
          the result is deterministic.

          See Mathworld for more information.

   ModInvert

          ModInvert (n,m)

          Returns inverse of n mod m

   MoebiusMu

          MoebiusMu (n)

          Return the Moebius mu function evaluated in n. That is,
          it  returns  0 if n is not a product of distinct primes
          and (-1)^k if it is a product of k distinct primes.

          See Mathworld for more information.

   NextPrime

          NextPrime (n)

          Returns  the  least  prime greater than n. Negatives of
          primes  are considered prime and so to get the previous
          prime you can use -NextPrime(-n).

          This  uses  the  GMP's mpz_nextprime which in turn uses
          the probabilistic Miller-Rabin test. The probability of
          false  positive  is  not tunable, but is low enough for
          all practical purposes.

   PadicValuation

          PadicValuation (n,p)

          Returns  the  padic valuation (number of trailing zeros
          in base p).

   PowerMod

          PowerMod (a,b,m)

          Compute a^b mod m

   Prime

          Prime (n)

          Aliases: prime

          Return the n'th prime (up to a limit)

          See Mathworld for more information.

   PrimeFactors

          PrimeFactors (n)

          Return all prime factors of a number

   PseudoprimeTest

          PseudoprimeTest (n,b)

          Pseudoprime test, true iff b^(n-1) == 1 (mod n)

   RemoveFactor

          RemoveFactor (n,m)

          Removes all instances of the factor m from the number n

   SilverPohligHellmanWithFactorization

          SilverPohligHellmanWithFactorization (n,b,q,f)

          Find discrete log of n base b in F_q where q is a prime
          using the Silver-Pohlig-Hellman algoritm, given f being
          the factorization of q-1

   SqrtModPrime

          SqrtModPrime (n,p)

          Find square root of n mod p (a prime). Null is returned
          if not a quadratic residue.

   StrongPseudoprimeTest

          StrongPseudoprimeTest (n,b)

          Run the strong pseudoprime test base b on n

   gcd

          gcd (a,args...)

          Aliases: GCD

          Greatest  common  divisor of integers. You can enter as
          many  integers  in the argument list, or you can give a
          vector  or  a matrix of integers. If you give more than
          one matrix of the same size then GCD is done element by
          element.

          See Mathworld for more information.

   lcm

          lcm (a,args...)

          Aliases: LCM

          Least  common  multiplier of integers. You can enter as
          many  integers  in the argument list, or you can give a
          vector  or  a matrix of integers. If you give more than
          one matrix of the same size then LCM is done element by
          element.

          See Mathworld for more information.
     _________________________________________________________

Matrix Manipulation

   ApplyOverMatrix

          ApplyOverMatrix (a,func)

          Apply  a  function  over  all  entries  of a matrix and
          return a matrix of the results

   ApplyOverMatrix2

          ApplyOverMatrix2 (a,b,func)

          Apply  a  function over all entries of 2 matrices (or 1
          value and 1 matrix) and return a matrix of the results

   ColumnsOf

          ColumnsOf (M)

          Gets the columns of a matrix as a horizontal vector

   ComplementSubmatrix

          ComplementSubmatrix (m,r,c)

          Remove column(s) and row(s) from a matrix

   CompoundMatrix

          CompoundMatrix (k,A)

          Calculate the kth compund matrix of A

   DeleteColumn

          DeleteColumn (M,col)

          Delete a column of a matrix

   DeleteRow

          DeleteRow (M,row)

          Delete a row of a matrix

   DiagonalOf

          DiagonalOf (M)

          Gets  the  diagonal entries of a matrix as a horizontal
          vector

   DotProduct

          DotProduct (u,v)

          Aliases: InnerProduct

          Get the dot product of two vectors

   ExpandMatrix

          ExpandMatrix (M)

          Expands  a  matrix  just  like we do on unquoted matrix
          input

   I

          I (n)

          Aliases: eye

          Make an identity matrix of a given size

   IndexComplement

          IndexComplement (vec,msize)

          Return the index complement of a vector of indexes

   IsDiagonal

          IsDiagonal (M)

          Is a matrix diagonal

   IsLowerTriangular

          IsLowerTriangular (M)

          Is a matrix lower triangular

   IsMatrixInteger

          IsMatrixInteger (M)

          Check if a matrix is an integer (non-complex) matrix

   IsMatrixRational

          IsMatrixRational (M)

          Check if a matrix is a rational (non-complex) matrix

   IsMatrixReal

          IsMatrixReal (M)

          Check if a matrix is a real (non-complex) matrix

   IsMatrixSquare

          IsMatrixSquare (M)

          Is a matrix square

   IsUpperTriangular

          IsUpperTriangular (M)

          Is a matrix upper triangular

   IsValueOnly

          IsValueOnly (M)

          Check if a matrix is a matrix of numbers

   IsVector

          IsVector (v)

          Is argument a horizontal or a vertical vector

   LowerTriangular

          LowerTriangular (M)

          Zero out entries above the diagonal

   MakeDiagonal

          MakeDiagonal (v,arg...)

          Aliases: diag

          Make diagonal matrix from a vector

   MatrixProduct

          MatrixProduct (a)

          Calculate the product of all elements in a matrix

   MatrixSum

          MatrixSum (a)

          Calculate the sum of all elements in a matrix

   MatrixSumSquares

          MatrixSumSquares (a)

          Calculate  the  sum  of  squares  of  all elements in a
          matrix

   OuterProduct

          OuterProduct (u,v)

          Get the outer product of two vectors

   ReverseVector

          ReverseVector (v)

          Reverse elements in a vector

   RowSum

          RowSum (m)

          Calculate sum of each row in a matrix

   RowSumSquares

          RowSumSquares (m)

          Calculate sum of squares of each row in a matrix

   RowsOf

          RowsOf (M)

          Gets the rows of a matrix as a vertical vector

   SetMatrixSize

          SetMatrixSize (M,rows,columns)

          Make new matrix of given size from old one

   SortVector

          SortVector (v)

          Sort vector elements

   StripZeroColumns

          StripZeroColumns (M)

          Removes any all-zero columns of M

   StripZeroRows

          StripZeroRows (M)

          Removes any all-zero rows of M

   Submatrix

          Submatrix (m,r,c)

          Return column(s) and row(s) from a matrix

   SwapRows

          SwapRows (m,row1,row2)

          Swap two rows in a matrix

   UpperTriangular

          UpperTriangular (M)

          Zero out entries below the diagonal

   columns

          columns (M)

          Get the number of columns of a matrix

   elements

          elements (M)

          Get the number of elements of a matrix

   ones

          ones (rows,columns...)

          Make an matrix of all ones (or a row vector)

   rows

          rows (M)

          Get the number of rows of a matrix

   zeros

          zeros (rows,columns...)

          Make an matrix of all zeros (or a row vector)
     _________________________________________________________

Linear Algebra

   AuxilliaryUnitMatrix

          AuxilliaryUnitMatrix (n)

          Get the auxilliary unit matrix of size n

   BilinearForm

          BilinearForm (v,A,w)

          Evaluate  (v,w) with respect to the bilinear form given
          by the matrix A

   BilinearFormFunction

          BilinearFormFunction (A)

          Return  a  function  that  evaluates  two  vectors with
          respect to the bilinear form given by A

   CharacteristicPolynomial

          CharacteristicPolynomial (M)

          Aliases: CharPoly

          Get the characteristic polynomial as a vector

   CharacteristicPolynomialFunction

          CharacteristicPolynomialFunction (M)

          Get the characteristic polynomial as a function

   ColumnSpace

          ColumnSpace (M)

          Get a basis matrix for the columnspace of a matrix

   CompanionMatrix

          CompanionMatrix (p)

          Companion matrix of a polynomial (as vector)

   ConjugateTranspose

          ConjugateTranspose (M)

          Conjugate transpose of a matrix (adjoint)

   Convolution

          Convolution (a,b)

          Aliases: convol

          Calculate convolution of two horizontal vectors

   ConvolutionVector

          ConvolutionVector (a,b)

          Calculate convolution of two horizontal vectors

   CrossProduct

          CrossProduct (v,w)

          CrossProduct of two vectors in R^3

   DeterminantalDivisorsInteger

          DeterminantalDivisorsInteger (M)

          Get  the  determinantal  divisors  of an integer matrix
          (not its characteristic)

   DirectSum

          DirectSum (M,N...)

          Direct sum of matrices

   DirectSumMatrixVector

          DirectSumMatrixVector (v)

          Direct sum of a vector of matrices

   Eigenvalues

          Eigenvalues (M)

          Aliases: eig

          Get the eigenvalues of a matrix (Currently only for 2x2
          and triangular matrices)

   GramSchmidt

          GramSchmidt (v,B)

          Apply  the  Gram-Schmidt  process (to the columns) with
          respect to innter product given by #2

   GramSchmidtDot

          GramSchmidtDot (M)

          Apply  the  Gram-Schmidt process (to the columns) using
          the dot product

   HankelMatrix

          HankelMatrix (c,r)

          Hankel matrix

   HilbertMatrix

          HilbertMatrix (n)

          Hilbert matrix of order n

   Image

          Image (T)

          Get the image (columnspace) of a linear transform

   InfNorm

          InfNorm (v)

          Get the Inf Norm of a vector

   InvariantFactorsInteger

          InvariantFactorsInteger (M)

          Get  the  invariant  factors of a square integer matrix
          (not its characteristic)

   InverseHilbertMatrix

          InverseHilbertMatrix (n)

          Inverse Hilbert matrix of order n

   IsHermitian

          IsHermitian (M)

          Is a matrix hermitian

   IsInSubspace

          IsInSubspace (v,W)

          Test if a vector is in a subspace

   IsInvertible

          IsInvertible (n)

          Is  a  matrix (or number) invertible (Integer matrix is
          invertible iff it's invertible over the integers)

   IsInvertibleField

          IsInvertibleField (n)

          Is a matrix (or number) invertible over a field

   IsNormal

          IsNormal (M)

          Is a matrix normal

   IsSkewHermitian

          IsSkewHermitian (M)

          Is a matrix skew-hermitian

   IsUnitary

          IsUnitary (M)

          Is a matrix unitary

   JordanBlock

          JordanBlock (n,lambda)

          Aliases: J

          Get the jordan block corresponding to lambda and n

   Kernel

          Kernel (T)

          Get the kernel (nullspace) of a linear transform

   LUDecomposition

          LUDecomposition (A, L, U)

          Get  the  LU decomposition of A and store the result in
          the  L  and  U  which  should be references. It returns
          null.  For  example  suppose that A is a square matrix,
          then after running:

          genius> LUDecomposition(A,&L,&U)

          You  will  have  the  lower matrix stored in a variable
          called L and the upper matrix in a variable called U.

          This  is  the  LU  decomposition  of a matrix aka Crout
          and/or    Cholesky   reduction.   (ISBN   0-201-11577-8
          pp.99-103)  The  upper  triangular  matrix  features  a
          diagonal  of  values  1  (one). This is not Doolittle's
          Method  which  features  the  1's diagonal on the lower
          matrix.

          Not  all  matrices  have LU decompositions, for example
          [0,1;1,0]  does  not and this function returns false in
          this case and sets L and U to null.

          See Mathworld for more information.

   Minor

          Minor (M,i,j)

          Get the i-j minor of a matrix

   NonPivotColumns

          NonPivotColumns (M)

          Return  the columns that are not the pivot columns of a
          matrix

   Norm

          Norm (v,p...)

          Aliases: norm

          Get  the  p  Norm  (or 2 Norm if no p is supplied) of a
          vector

   NullSpace

          NullSpace (T)

          Get the nullspace of a matrix

   Nullity

          Nullity (M)

          Aliases: nullity

          Get the nullity of a matrix

   OrthogonalComplement

          OrthogonalComplement (M)

          Get the orthogonal complement of the columnspace

   PivotColumns

          PivotColumns (M)

          Return pivot columns of a matrix, that is columns which
          have  a  leading  1  in rref form, also returns the row
          where they occur

   Projection

          Projection (v,W,B)

          Projection of vector v onto subspace W given a bilinear
          form B

   RaleighQuotient

          RaleighQuotient (A,x)

          Return the Raleigh Quotient of a matrix and a vector

   Rank

          Rank (M)

          Aliases: rank

          Get the rank of a matrix

   RosserMatrix

          RosserMatrix ()

          Rosser  matrix,  a  classic  symmetric  eigenvalue test
          problem

   Rotation2D

          Rotation2D (angle)

          Aliases: RotationMatrix

          Rotation around origin in R^2

   Rotation3DX

          Rotation3DX (angle)

          Rotation around origin in R^3 about the x-axis

   Rotation3DY

          Rotation3DY (angle)

          Rotation around origin in R^3 about the y-axis

   Rotation3DZ

          Rotation3DZ (angle)

          Rotation around origin in R^3 about the z-axis

   RowSpace

          RowSpace (M)

          Get a basis matrix for the rowspace of a matrix

   SmithNormalFormField

          SmithNormalFormField (A)

          Smith  Normal  Form for fields (will end up with 1's on
          the diagonal)

   SmithNormalFormInteger

          SmithNormalFormInteger (M)

          Smith  Normal Form for square integer matrices (not its
          characteristic)

   SolveLinearSystem

          SolveLinearSystem (M,V,args...)

          Solve linear system Mx=V, return solution V if there is
          a  unique solution, null otherwise. Extra two reference
          parameters  can optionally be used to get the reduced M
          and V.

   Trace

          Trace (m)

          Aliases: trace

          Calculate the trace of a matrix

   Transpose

          Transpose (M)

          Transpose of a matrix

   VandermondeMatrix

          VandermondeMatrix (v)

          Aliases: vander

          Return the Vandermonde matrix

   VectorAngle

          VectorAngle (v,w,B)

          The angle of two vectors, given an inner product

   VectorSpaceDirectSum

          VectorSpaceDirectSum (M,N)

          The direct sum of the vector spaces M and N

   VectorSubspaceIntersection

          VectorSubspaceIntersection (M,N)

          Intersection of the subspaces given by M and N

   VectorSubspaceSum

          VectorSubspaceSum (M,N)

          The  sum  of  the  vector  spaces M and N, that is {w |
          w=m+n, m in M, n in N}

   adj

          adj (m)

          Aliases: Adjugate

          Get the classical adjoint (adjugate) of a matrix

   cref

          cref (M)

          Aliases: CREF ColumnReducedEchelonForm

          Compute the Column Reduced Echelon Form

   det

          det (M)

          Aliases: Determinant

          Get the determinant of a matrix

   ref

          ref (M)

          Aliases: REF RowEchelonForm

          Get the row echelon form of a matrix

   rref

          rref (M)

          Aliases: RREF ReducedRowEchelonForm

          Get the reduced row echelon form of a matrix
     _________________________________________________________

Combinatorics

   Catalan

          Catalan (n)

          Get n'th catalan number

   Combinations

          Combinations (k,n)

          Get  all  combinations  of  k  numbers from 1 to n as a
          vector of vectors

   DoubleFactorial

          DoubleFactorial (n)

          Double factorial: n(n-2)(n-4)...

   Factorial

          Factorial (n)

          Factorial: n(n-1)(n-2)...

   FallingFactorial

          FallingFactorial (n,k)

          Falling factorial: (n)_k = n(n-1)...(n-(k-1))

   Fibbonachi

          Fibbonachi (x)

          Aliases: fib

          Calculate  nth  fibbonachi  number.  That is the number
          defined  recursively by Fibbonachi(n) = Fibbonachi(n-1)
          +  Fibbonachi(n-2)  and Fibbonachi(1) = Fibbonachi(2) =
          1.

          See Mathworld for more information.

   GaloisMatrix

          GaloisMatrix (combining_rule)

          Galois   matrix   given   a   linear   combining   rule
          (a_1*x_+...+a_n*x_n=x_(n+1))

   HarmonicNumber

          HarmonicNumber (n,r)

          Aliases: HarmonicH

          Harmonic Number, the nth harmonic number of order r

   Hofstadter

          Hofstadter (n)

          Hofstadter's  function  q(n) defined by q(1)=1, q(2)=1,
          q(n)=q(n-q(n-1))+q(n-q(n-2))

   LinearRecursiveSequence

          LinearRecursiveSequence (seed_values,combining_rule,n)

          Compute linear recursive sequence using galois stepping

   Multinomial

          Multinomial (v,arg...)

          Calculate multinomial coefficients

   Pascal

          Pascal (i)

          Get the pascal's triangle as a matrix

   Permutations

          Permutations (k,n)

          Get  all  permutations  of  k  numbers from 1 to n as a
          vector of vectors

   RisingFactorial

          RisingFactorial (n,k)

          Aliases: Puchhammer

          (Puchhammer)      Rising     factorial:     (n)_k     =
          n(n+1)...(n+(k-1))

   Subfactorial

          Subfactorial (n)

          Subfactorial: n! times sum_{k=1}^n (-1)^k/k!

   Triangular

          Triangular (nth)

          Calculate the nth triangular number

   nCr

          nCr (n,r)

          Aliases: Binomial

          Calculate combinations (binomial coefficient)

   nPr

          nPr (n,r)

          Calculate permutations
     _________________________________________________________

Calculus

   CompositeSimpsonsRule

          CompositeSimpsonsRule (f,a,b,n)

          Integration  of  f  by  Composite Simpson's Rule on the
          interval  [a,b]  with  n  subintervals  with  error  of
          max(f'''')*h^4*(b-a)/180, note that n should be even

   CompositeSimpsonsRuleTolerance

 CompositeSimpsonsRuleTolerance (f,a,b,FourthDerivativeBound,Tolerance)

          Integration  of  f  by  Composite Simpson's Rule on the
          interval  [a,b]  with the number of steps calculated by
          the fourth derivative bound and the desired tolerance

   InfiniteProduct

          InfiniteProduct (func,start,inc)

          Try  to  calculate  an  infinite  product  for a single
          parameter function

   InfiniteProduct2

          InfiniteProduct2 (func,arg,start,inc)

          Try  to  calculate  an  infinite  product  for a double
          parameter function with func(arg,n)

   InfiniteSum

          InfiniteSum (func,start,inc)

          Try to calculate an infinite sum for a single parameter
          function

   InfiniteSum2

          InfiniteSum2 (func,arg,start,inc)

          Try to calculate an infinite sum for a double parameter
          function with func(arg,n)

   IsContinuous

          IsContinuous (f,x0)

          Try  and see if a real-valued function is continuous at
          x0 by calculating the limit there

   IsDifferentiable

          IsDifferentiable (f,x0)

          Test  for  differentiability  by approximating the left
          and right limits and comparing

   LeftLimit

          LeftLimit (f,x0)

          Calculate  the  left limit of a real-valued function at
          x0

   Limit

          Limit (f,x0)

          Calculate  the  limit  of a real-valued function at x0.
          Tries to calculate both left and right limits.

   MidpointRule

          MidpointRule (f,a,b,n)

          Integration by midpoint rule

   NumericalDerivative

          NumericalDerivative (f,x0)

          Aliases: NDerivative

          Attempt to calculate numerical derivative

   NumericalIntegral

          NumericalIntegral (f,a,b)

          Integration by rule set in NumericalIntegralFunction of
          f from a to b using NumericalIntegralSteps steps

   NumericalLeftDerivative

          NumericalLeftDerivative (f,x0)

          Attempt to calculate numerical left derivative

   NumericalLimitAtInfinity

NumericalLimitAtInfinity (_f,step_fun,tolerance,successive_for_success,
   N)

          Attempt  to  calculate the limit of f(step_fun(i)) as i
          goes from 1 to N

   NumericalRightDerivative

          NumericalRightDerivative (f,x0)

          Attempt to calculate numerical right derivative

   OneSidedFivePointFormula

          OneSidedFivePointFormula (f,x0,h)

          Compute one-sided derivative using five point formula

   OneSidedThreePointFormula

          OneSidedThreePointFormula (f,x0,h)

          Compute one-sided derivative using three-point formula

   RightLimit

          RightLimit (f,x0)

          Calculate  the right limit of a real-valued function at
          x0

   TwoSidedFivePointFormula

          TwoSidedFivePointFormula (f,x0,h)

          Compute two-sided derivative using five-point formula

   TwoSidedThreePointFormula

          TwoSidedThreePointFormula (f,x0,h)

          Compute two-sided derivative using three-point formula
     _________________________________________________________

Functions

   Argument

          Argument (z)

          Aliases: Arg arg

          argument (angle) of complex number

   DirichletKernel

          DirichletKernel (n,t)

          Dirichlet kernel of order n

   DiscreteDelta

          DiscreteDelta (v)

          Returns 1 iff all elements are zero

   ErrorFunction

          ErrorFunction (x)

          Aliases: erf

          The error function, 2/sqrt(pi) * int_0^x e^(-t^2) dt

   FejerKernel

          FejerKernel (n,t)

          Fejer kernel of order n

   KroneckerDelta

          KroneckerDelta (v)

          Returns 1 iff all elements are equal

   MinimizeFunction

          MinimizeFunction (func,x,incr)

          Find the first value where f(x)=0

   MoebiusDiskMapping

          MoebiusDiskMapping (a,z)

          Moebius mapping of the disk to itself mapping a to 0

   MoebiusMapping

          MoebiusMapping (z,z2,z3,z4)

          Moebius  mapping  using the cross ratio taking z2,z3,z4
          to 1,0, and infinity respectively

   MoebiusMappingInftyToInfty

          MoebiusMappingInftyToInfty (z,z2,z3)

          Moebius  mapping  using the cross ratio taking infinity
          to infinity and z2,z3 to 1 and 0 respectively

   MoebiusMappingInftyToOne

          MoebiusMappingInftyToOne (z,z3,z4)

          Moebius  mapping  using the cross ratio taking infinity
          to 1 and z3,z4 to 0 and infinity respectively

   MoebiusMappingInftyToZero

          MoebiusMappingInftyToZero (z,z2,z4)

          Moebius  mapping  using the cross ratio taking infinity
          to 0 and z2,z4 to 1 and infinity respectively

   PoissonKernel

          PoissonKernel (r,sigma)

          Poisson  kernel on D(0,1) (not normalized to 1, that is
          integral of this is 2pi)

   PoissonKernelRadius

          PoissonKernelRadius (r,sigma)

          Poisson kernel on D(0,R) (not normalized to 1)

   UnitStep

          UnitStep (x)

          The  unit step function is 0 for x<0, 1 otherwise. This
          is the integral of the Dirac Delta function.

   cis

          cis (x)

          The cis function, that is the same as cos(x)+1i*sin(x)

   deg2rad

          deg2rad (x)

          Convert degrees to radians

   rad2deg

          rad2deg (x)

          Convert radians to degrees
     _________________________________________________________

Equation Solving

   EulerMethod

          EulerMethod (f,x0,y0,x1,n)

          Use  classical  Euler's  method  to  numerically  solve
          y'=f(x,y)  for  initial  x0,  y0  going  to  x1  with n
          increments, returns y at x1.

          See Mathworld for more information.

   FindRootBisection

          FindRootBisection (f,a,b,TOL,N)

          Find root of a function using the bisection method

   FindRootFalsePosition

          FindRootFalsePosition (f,a,b,TOL,N)

          Find  root  of  a  function  using  the method of false
          position

   FindRootMullersMethod

          FindRootMullersMethod (f,x1,x2,x3,TOL,N)

          Find root of a function using the Muller's method

   FindRootSecant

          FindRootSecant (f,a,b,TOL,N)

          Find root of a function using the secant method

   RungeKutta

          RungeKutta (f,x0,y0,x1,n)

          Use   classical   non-adaptive  Runge-Kutta  method  to
          numerically solve y'=f(x,y) for initial x0, y0 going to
          x1 with n increments, returns y at x1.

          See Mathworld for more information.
     _________________________________________________________

Statistics

   Average

          Average (m)

          Aliases: average Mean mean

          Calculate average of an entire matrix

          See Mathworld for more information.

   GaussDistribution

          GaussDistribution (x,sigma)

          Integral  of  the GaussFunction from 0 to x (area under
          the normal curve)

          See Mathworld for more information.

   GaussFunction

          GaussFunction (x,sigma)

          The  normalized Gauss distribution function (the normal
          curve)

          See Mathworld for more information.

   Median

          Median (m)

          Aliases: median

          Calculate median of an entire matrix

          See Mathworld for more information.

   PopulationStandardDeviation

          PopulationStandardDeviation (m)

          Aliases: stdevp

          Calculate  the population standard deviation of a whole
          matrix

   RowAverage

          RowAverage (m)

          Aliases: RowMean

          Calculate average of each row in a matrix

          See Mathworld for more information.

   RowMedian

          RowMedian (m)

          Calculate  median  of each row in a matrix and return a
          column vector of the medians.

          See Mathworld for more information.

   RowPopulationStandardDeviation

          RowPopulationStandardDeviation (m)

          Aliases: rowstdevp

          Calculate the population standard deviations of rows of
          a matrix and return a vertical vector

   RowStandardDeviation

          RowStandardDeviation (m)

          Aliases: rowstdev

          Calculate  the  standard deviations of rows of a matrix
          and return a vertical vector

   StandardDeviation

          StandardDeviation (m)

          Aliases: stdev

          Calculate the standard deviation of a whole matrix
     _________________________________________________________

Polynomials

   AddPoly

          AddPoly (p1,p2)

          Add two polynomials (vectors)

   IsPoly

          IsPoly (p)

          Check if a vector is usable as a polynomial

   MultiplyPoly

          MultiplyPoly (p1,p2)

          Multiply two polynomials (as vectors)

   Poly2ndDerivative

          Poly2ndDerivative (p)

          Take second polynomial (as vector) derivative

   PolyDerivative

          PolyDerivative (p)

          Take polynomial (as vector) derivative

   PolyToFunction

          PolyToFunction (p)

          Make function out of a polynomial (as vector)

   PolyToString

          PolyToString (p,var...)

          Make string out of a polynomial (as vector)

   SubtractPoly

          SubtractPoly (p1,p2)

          Subtract two polynomials (as vectors)

   TrimPoly

          TrimPoly (p)

          Trim zeros from a polynomial (as vector)
     _________________________________________________________

Set Theory

   Intersection

          Intersection (X,Y)

          Returns  a set theoretic intersection of X and Y (X and
          Y are vectors pretending to be sets)

   IsIn

          IsIn (x,X)

          Returns  true if the element x is in the set X (where X
          is a vector pretending to be a set)

   MakeSet

          MakeSet (X)

          Returns  a  set  where  every element of X appears only
          once

   SetMinus

          SetMinus (X,Y)

          Returns  a  set  theoretic  difference X-Y (X and Y are
          vectors pretending to be sets)

   Union

          Union (X,Y)

          Returns  a  set theoretic union of X and Y (X and Y are
          vectors pretending to be sets)
     _________________________________________________________

Miscellaneous

   ASCIIToString

          ASCIIToString (vec)

          Convert a vector of ASCII values to a string

   AlphabetToString

          AlphabetToString (vec,alphabet)

          Convert  a vector of 0-based alphabet values (positions
          in the alphabet string) to a string

   StringToASCII

          StringToASCII (str)

          Convert a string to a vector of ASCII values

   StringToAlphabet

          StringToAlphabet (str,alphabet)

          Convert a string to a vector of 0-based alphabet values
          (positions  in  the  alphabet string), -1's for unknown
          letters
     _________________________________________________________

Example programs in GEL

   Here is a function that calculates factorials:
   function f(x) = if x <= 1 then 1 else (f(x-1)*x)

   With indentation it becomes:
function f(x) = (
  if x <= 1 then
    1
  else
    (f(x-1)*x)
)

   This  is  a  direct port of the factorial function from the bc
   manpage. The syntax seems similar to bc, but different in that
   in GEL, the last expression is the one that is returned. Using
   the return function instead, it would be:
function f(x) = (
  if (x <= 1) then return (1);
  return (f(x-1) * x)
)

   This  is  a  smaller,  nicer, iterative version, that uses the
   product loop:
   function f(x) = prod k=1 to x do k

   Here  is  a  larger  example,  this  basically  redefines  the
   internal  ref  function  to  calculate  the same thing, but is
   written in GEL:
# Calculate the row-echelon form of a matrix
function MyOwnREF(m) = (
  if not IsMatrix(m) or not IsValueOnly(m) then
    (error("ref: argument not a value only matrix");bailout);
  s := min(rows(m), columns(m));
  i := 1;
  d := 1;
  while d <= s and i <= columns(m) do (

    # This just makes the anchor element non-zero if at
    # all possible
    if m@(d,i) == 0 then (
      j := d+1;
      while j <= rows(m) do (
        if m@(j,i) == 0 then
          (j=j+1;continue);
        a := m@(j,);
        m@(j,) := m@(d,);
        m@(d,) := a;
        j := j+1;
        break
      )
    );
    if m@(d,i) == 0 then
      (i:=i+1;continue);

    # Here comes the actual zeroing of all but the anchor
    # element rows
    j := d+1;
    while j <= rows(m)) do (
      if m@(j,i) != 0 then (
        m@(j,) := m@(j,)-(m@(j,i)/m@(d,i))*m@(d,)
      );
      j := j+1
    );
    m@(d,) := m@(d,) * (1/m@(d,i));
    d := d+1;
    i := i+1
  );
  m
)
     _________________________________________________________

Settings

   To  configure  Genius Math Tool, choose Settings->Preferences.
   There  are several basic parameters provided by the calculator
   in  addition  to  the  ones  provided by the standard library.
   These control how the calculator behaves.

   Note Changing settings with GEL
     Many of the settings in Genius are simply global variables,
   and can be evaluated and assigned to in the same way as normal
   variables. See the Section called Using Variables in the
   chapter called GEL Basics about evaluating and assigning to
   variables, and the Section called Parameters in the chapter
   called List of GEL functions for a list of settings that can
   be modified in this way.

   As an example, you can set the maximum number of digits in a
   result to 12 by typing:
   MaxDigits = 12
     _________________________________________________________

Output

   Maximum digits to output
          The maximum digits in a result (MaxDigits)

   Results as floats
          If  the  results  should  be  always  printed as floats
          (ResultsAsFloats)

   Floats in scientific notation
          If    floats   should   be   in   scientific   notation
          (ScientificNotation)

   Always print full expressions
          Should  we  print  out full expressions for non-numeric
          return values (longer than a line) (FullExpressions)

   Display errors in a dialog
          If  set  the  errors  will  be  displayed  in a seprate
          dialog,  if  unset  the  errors  will be printed on the
          console.

   Display information messages in a dialog
          If  set the information messages will be displayed in a
          seprate  dialog, if unset the information messages will
          be printed on the console.

   Maximum errors to display
          The   maximum   number  of  errors  to  return  on  one
          evaluation  (MaxErrors).  If you set this to 0 then all
          errors are always returned. Usually if some loop causes
          many  errors, then it is unlikely that you will be able
          to  make  sense  out  of  more  than a few of these, so
          seeing a long list of errors is usually not helpful.

   In  addition  to these preferences, there are some preferences
   that  can  only  be  changed  by setting them in the workspace
   console. For others that may affect the output see the Section
   called Parameters in the chapter called List of GEL functions.

   MixedFractions
          If  fractions should be printed as mixed fractions such
          as "1 1/3" rather than "4/3"

   IntegerOutputBase
          The base that will be used to output integers

   OutputStyle
          A string, can be "normal", "latex", "mathml" or "troff"
          and  it  will  effect  how  matrices (and perhaps other
          stuff) is printed, useful for pasting into documents
     _________________________________________________________

Precision

   Floating point precision
          The  floating point precision in bits (FloatPrecision).
          Note  that  changing  this  only affects newly computed
          quantities.   Old   values   stored  in  variables  are
          obviously still in the old precision and if you want to
          have them more precise you will have to recompute them.
          Exceptions  to this are the system constants such as pi
          or e.
     _________________________________________________________

Terminal

   Terminal refers to the console in the workarea.

   Scrollback lines
          Lines of scrollback in the terminal.

   Font
          The font to use on the terminal.

   Black on white
          If to use black on white on the terminal.
     _________________________________________________________

About Genius Math Tool

   Genius   Math   Tool   was   written  by  Jiri  (George)  Lebl
   (<jirka@5z.com>).  To  find more information about Genius Math
   Tool, please visit the Genius Web page.

   To   report   a  bug  or  make  a  suggestion  regarding  this
   application  or  this  manual,  follow  the directions in this
   document.

   This program is distributed under the terms of the GNU General
   Public  license  as published by the Free Software Foundation;
   either version 2 of the License, or (at your option) any later
   version.  A copy of this license can be found at this link, or
   in  the  file  COPYING  included  with the source code of this
   program.
