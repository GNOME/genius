<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
  <!ENTITY app "<application>Genius Mathematics Tool</application>">
  <!ENTITY appname "Genius">
  <!ENTITY appversion "1.0.6">
  <!ENTITY manrevision "0.2.3">
  <!ENTITY date "March 2009">

  <!ENTITY legal SYSTEM "legal.xml">

  <!ENTITY gel-function-list SYSTEM "gel-function-list.xml">
]>

<!-- 
      (Do not remove this comment block.)
  Maintained by the GNOME Documentation Project
  http://developer.gnome.org/projects/gdp
  Template version: 2.0 beta
  Template last modified Apr 11, 2002
-->

<!-- =============Document Header ============================= -->
<book id="index" lang="en">
<!-- please do not change the id; for translations, change lang to -->
<!-- appropriate code -->
  <bookinfo> 
    <title>&appname; Manual</title>       

    <copyright>
      <year>1997-2009</year>
      <holder>Ji&#345;&iacute; (George) Lebl</holder>
    </copyright>
    <copyright>
      <year>2004</year>
      <holder>Kai Willadsen</holder>
    </copyright>
<!-- translators: uncomment this:
  <copyright>
   <year>2002</year>
   <holder>ME-THE-TRANSLATOR (Latin translation)</holder>
  </copyright>
-->

    <publisher> 
      <publishername></publishername> 
    </publisher> 

   &legal;
   <!-- This file  contains link to license for the documentation (GNU FDL), and 
        other legal stuff such as "NO WARRANTY" statement. Please do not change 
	any of this. -->

    <authorgroup> 
      <author> 
		<firstname>Ji&#345;&iacute;</firstname> 
		<surname>Lebl</surname> 
		<affiliation> 
	  		<orgname>University of Illinois, Urbana-Champaign</orgname> 
	  		<address> <email>jirka@5z.com</email> </address> 
		</affiliation> 
      </author> 
      <author> 
		<firstname>Kai</firstname> 
		<surname>Willadsen</surname> 
		<affiliation> 
	  		<orgname>University of Queensland, Australia</orgname> 
	  		<address> <email>kaiw@itee.uq.edu.au</email> </address> 
		</affiliation> 
      </author> 
      
<!-- This is appropriate place for other contributors: translators,
     maintainers,  etc. Commented out by default.
     
      <othercredit role="translator">
		<firstname>Latin</firstname> 
		<surname>Translator 1</surname> 
		<affiliation> 
	  		<orgname>Latin Translation Team</orgname> 
	  		<address> <email>translator@gnome.org</email> </address> 
		</affiliation>
		<contrib>Latin translation</contrib>
      </othercredit>
-->
    </authorgroup>


<!-- According to GNU FDL, revision history is mandatory if you are -->
<!-- modifying/reusing someone else's document.  If not, you can omit it. -->
<!-- Remember to remove the &manrevision; entity from the revision entries other
-->
<!-- than the current revision. -->
<!-- The revision numbering system for GNOME manuals is as follows: -->
<!-- * the revision number consists of two components -->
<!-- * the first component of the revision number reflects the release version of the GNOME desktop. -->
<!-- * the second component of the revision number is a decimal unit that is incremented with each revision of the manual. -->
<!-- For example, if the GNOME desktop release is V2.x, the first version of the manual that -->
<!-- is written in that desktop timeframe is V2.0, the second version of the manual is V2.1, etc. -->
<!-- When the desktop release version changes to V3.x, the revision number of the manual changes -->
<!-- to V3.0, and so on. -->  
<!--  This is unmaintained quite a bit so screw this it just makes things
      ugly and we don't update the manrevision stuff anyway
    <revhistory>
      <revision> 
		<revnumber>&manrevision;</revnumber> 
		<date>&date;</date> 
		<revdescription> 
	  		<para role="author">Jiri (George) Lebl
	    	<email>jirka@5z.com</email>
	  		</para>
		</revdescription> 
      </revision> 
      <revision> 
		<revnumber>0.1</revnumber> 
		<date>September 2004</date> 
		<revdescription> 
	  		<para role="author">Kai Willadsen
	    	<email>kaiw@itee.uq.edu.au</email>
	  		</para>
		</revdescription> 
      </revision> 
      <revision> 
		<revnumber>Genius Calculator Manual</revnumber> 
		<date>August 2004</date> 
		<revdescription> 
	  		<para role="author">Jiri (George) Lebl
	    	<email>jirka@5z.com</email>
	  		</para>
		</revdescription> 
      </revision> 
    </revhistory> 
-->

    <releaseinfo>This manual describes version &appversion; of &appname;.
    </releaseinfo> 
    <legalnotice> 
      <title>Feedback</title> 
      <para>To report a bug or make a suggestion regarding the &app; application or
      this manual, follow the directions in the <ulink url="ghelp:gnome-feedback"
	  type="help">GNOME Feedback Page</ulink>. 
      </para>
<!-- Translators may also add here feedback address for translations -->
    </legalnotice> 
  </bookinfo> 

<!-- ============= Introduction =============================== -->
  <chapter id="genius-introduction"> 
    <title>Introduction</title> 
    <para>
	The &app; application is a general calculator for use as a desktop
	calculator, an educational tool in mathematics, and is useful even for
	research.  The language used in &app; is designed to be
	&lsquo;mathematical&rsquo; in the sense that it should be &lsquo;what
	you mean is what you get&rsquo;.  Of course that is not an
	entirely attainable goal.  &app; features rationals, arbitrary
	precision integers and multiple precision floats using the GMP library.
	It handles complex numbers using cartesian notation.  It has good
	vector and matrix manipulation and can handle basic linear algebra.
	The programming language allows user defined functions, variables and
	modification of parameters.
    </para> 

    <para>
	&app; comes in two versions.  One version is the graphical GNOME
	version, which features an IDE style interface and the ability 
	to plot functions of one or two variables.
	The command line version does not require GNOME, but of course
	does not implement any feature that requires the graphical interface.
    </para> 

    <para>
	This manual describes mostly the graphical version of the calculator,
	but the language is of course the same.  The command line only version
	lacks the graphing capabilities and all other capabilities that require
	the graphical user interface.
    </para>

  </chapter>

<!-- =========== Getting Started ============================== -->
  <chapter id="genius-getting-started"> 
    <title>Getting Started</title> 

    <sect1 id="genius-to-start">
      <title>To Start &app;</title>
      <para>You can start <application>&app;</application> in the following ways:
      </para> 
      <variablelist>
        <varlistentry>
          <term><guimenu>Applications</guimenu> menu</term>
          <listitem>
	    <para>
	      Depending on your operating system and version, the
	      menu item for &app; could appear in a number of different
	      places.  It can be in the 
              <guisubmenu>Education</guisubmenu>, 
              <guisubmenu>Accessories</guisubmenu>, 
              <guisubmenu>Office</guisubmenu>, 
              <guisubmenu>Science</guisubmenu>, or
	      similar submenu, depending on your particular setup.
	      The menu item name you are looking for is
	      <guimenuitem>Genius Math Tool</guimenuitem>.  Once you locate
	      this menu item click on it to start &app;.
            </para>
	      </listitem>
        </varlistentry>
        <varlistentry>
          <term><guilabel>Run</guilabel> dialog</term>
          <listitem>
	    <para>
	      Depending on your system installation the menu item 
	      may not be available.  If it is not, you can open the Run dialog
              and execute <command>gnome-genius</command>.
            </para>
	      </listitem>
        </varlistentry>
        <varlistentry>
    	  <term>Command line</term>
    	  <listitem>
    	    <para>
	      To start the GNOME version of &app; execute
	      <command>gnome-genius</command> from the command line.
	    </para>
	    <para>
	      To start the command line only version,
              execute the following command: <command>genius</command>.
	      This version does not include the graphical environment
	      and some functionality such as plotting will not be available.
            </para> 
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>

    <sect1 id="genius-when-start">
    <title>When You Start &appname;</title>
      <para>When you start the GNOME edition of
	    &app;, the window pictured in <xref
linkend="mainwindow-fig"/> is displayed.</para>

      <figure id="mainwindow-fig"> 
        <title>&app; Window</title> 
        <screenshot> 
          <mediaobject> 
            <imageobject>
              <imagedata fileref="figures/genius_window.png" format="PNG"
scale="50" scalefit="1"/> 
            </imageobject>
            <imageobject>
              <imagedata fileref="figures/genius_window.eps" format="EPS"
scale="50" scalefit="1"/> 
            </imageobject>
            <textobject> 
	      <phrase>Shows &app; main window. Contains titlebar, menubar,
toolbar and working area. Menubar contains <guilabel>File</guilabel>,
<guilabel>Edit</guilabel>, <guilabel>Calculator</guilabel>,
<guilabel>Settings</guilabel>, and <guilabel>Help</guilabel> menus.</phrase> 
            </textobject> 
          </mediaobject>
        </screenshot> 
      </figure>

      <para>The &app; window contains the following elements:
      </para>
      <variablelist>
        <varlistentry>
          <term>Menubar.</term>
          <listitem>
            <para>The menus on the menubar contain all of the commands that you need to work with files in &app;.
	     The <guilabel>File</guilabel> menu contains items for loading and saving items and creating
	     new programs.  The <guilabel>Load and Run...</guilabel> command does not open a new window for
	     the program, but just executes the program directly.  It is equivalent to the <command>load</command>
	     command.</para>
	    <para>
		The <guilabel>Calculator</guilabel> menu controls the
calculator engine.  It allows you to run the currently selected program or to
interrupt the current calculation.  You can also look at the full expression of
the last answer (useful if the last answer was too large to fit onto the
console), or you can view a listing of the values of all user defined
variables.  Finally it allows plotting functions using a user friendly dialog box.
	   </para>
	   <para>
	    The other menus have same familiar functions as in other applications.
	   </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Toolbar.</term>
          <listitem>
            <para>The toolbar contains a subset of the commands that you can access from the menubar.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Working area</term>
          <listitem>
            <para>
		The working area is the primary method of interacting with
		the application.
	    </para>
	    <para>
	    	The working area initially has just the <guilabel>Console</guilabel> tab which is
		the main way of interacting with the calculator.  Here you
		type expressions and the results are immediately returned
		after you hit the Enter key.
	    </para>
	    <para>
	    	Alternatively you can write longer programs and those can
		appear in separate tabs and can be stored in files for later
		retrieval.
	    </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>

  </chapter>

<!-- ================ Usage =================================== -->
  <chapter id="genius-usage"> 
    <title>Basic Usage</title> 

    <sect1 id="genius-usage-workarea"> 
      <title>Using the Work Area</title> 

      <para>
        Normally you interact with the calculator in the <guilabel>Console</guilabel> tab of the
	work area.  If you are running the text only version then the console
	will be the only thing that is available to you.  If you want to use
	&app; as a calculator only, just type in your expression here and it
	willg et evaluated.
      </para>

      <para>
	Type your expression into the <guilabel>Console</guilabel> work area and press enter and
	the expression will be evaluated.  Expressions are written in a
language called GEL.  The most simple GEL expression just looks like
mathematics.  For example
<screen><prompt>genius> </prompt><userinput>30*70 + 67^3.0 + ln(7) * (88.8/100)</userinput>
</screen>
or
<screen><prompt>genius> </prompt><userinput>62734 + 812634 + 77^4 mod 5</userinput>
</screen>
or
<screen><prompt>genius> </prompt><userinput>| sin(37) - e^7 |</userinput>
</screen>
or
<screen><prompt>genius> </prompt><userinput>sum n=1 to 70 do 1/n</userinput>
</screen>
(Last is the harmonic sum from 1 to 70)
</para>
<para>
To get a list of functions and commands, type:
<screen><prompt>genius> </prompt><userinput>help</userinput>
</screen>
If you wish to get more help on a specific function, type:
<screen><prompt>genius> </prompt><userinput>help FunctionName</userinput>
</screen>
To view this manual, type:
<screen><prompt>genius> </prompt><userinput>manual</userinput>
</screen>
</para>
<para>
Suppose you have previously saved some GEL commands as a program to a file and
you now want to execute them.
To load this program from the file <filename>path/to/program.gel</filename>,
type
<screen><prompt>genius> </prompt><userinput>load path/to/program.gel</userinput>
</screen>
&app; keeps track of the current directory.
To list files in the current directory type <command>ls</command>, to change directory
do <userinput>cd directory</userinput> as in the unix command shell.
</para>
    </sect1>

    <sect1 id="genius-usage-create-program"> 
      <title>To Create a New Program </title> 
      <para>
To start writing a new program, choose
<menuchoice><guimenu>File</guimenu><guimenuitem>New
Program</guimenuitem></menuchoice>. A new tab will appear in the work area. You
can write a <link linkend="genius-gel">GEL</link> program in this work area.
Once you have written your program you can run it by 
<menuchoice><guimenu>Calculator</guimenu><guimenuitem>Run</guimenuitem></menuchoice>.
This will execute your program and will display any output on the <guilabel>Console</guilabel> tab.
Executing a program is equivalent of taking the text of the program and
typing it into the console.  The only difference is that this input is done
independent of the console and just the output goes onto the console.
<menuchoice><guimenu>Calculator</guimenu><guimenuitem>Run</guimenuitem></menuchoice>
will always run the currently selected program even if you are on the <guilabel>Console</guilabel>
tab.  The currently selected program has its tab in bold type.  To select a
program, just click on its tab.
      </para>
      <para>
To save the program you've just written, choose <menuchoice><guimenu>File</guimenu><guimenuitem>Save As...</guimenuitem></menuchoice>
      </para>
    </sect1>

    <sect1 id="genius-usage-open-program"> 
      <title>To Open and Run a Program </title> 
      <para>
To open a file, choose
<menuchoice><guimenu>File</guimenu><guimenuitem>Open</guimenuitem></menuchoice>.
A new tab containing the file will appear in the work area. You can use this to
edit the file.
      </para>
      <para>
To run a program from a file, choose
<menuchoice><guimenu>File</guimenu><guimenuitem>Load and
Run...</guimenuitem></menuchoice>.  This will run the program without opening it
in a separate tab.  This is equivalent to the <command>load</command> command.
      </para>
    </sect1>

  </chapter>

  <!-- ============= Plotting ============================== -->
  <chapter id="genius-gel-plotting">
    <title>Plotting</title>

    <para>
      Plotting support is only available in the graphical GNOME version.
      All plotting accessible from the graphical interface is available from
      the <guilabel>Create Plot</guilabel> window.  You can access this window by either clicking
      on the <guilabel>Plot</guilabel> button on the toolbar or selecting <guilabel>Plot</guilabel> from the <guilabel>Calculator</guilabel>
      menu.  You can also access the plotting functionality by using the
      <link linkend="genius-gel-function-list-plotting">plotting
      functions</link> of the GEL language.  See 
      <xref linkend="genius-gel"/> to find out how to
      enter expressions that &appname; understands.
    </para>

    <sect1 id="genius-line-plots">
      <title>Line Plots</title>
      <para>
	To graph real valued functions of one variable open the <guilabel>Create Plot</guilabel>
	window.  You can also use the
        <link linkend="gel-function-LinePlot"><function>LinePlot</function></link> function
	on the command line (see its documentation).
      </para>
      <para>
	Once you click the <guilabel>Plot</guilabel> button, a window opens up with some notebooks in it.
	You want to be in the <guilabel>Function line plot</guilabel> notebook
tab, and inside you want to be on the <guilabel>Functions / Expressions</guilabel> notebook tab.
See <xref linkend="lineplot-fig"/>.
      </para>

      <figure id="lineplot-fig"> 
        <title>Create Plot Window</title> 
        <screenshot> 
          <mediaobject> 
            <imageobject>
              <imagedata fileref="figures/line_plot.png" format="PNG" scale="50" scalefit="1"/> 
            </imageobject>
            <imageobject>
              <imagedata fileref="figures/line_plot.eps" format="EPS" scale="50" scalefit="1"/> 
            </imageobject>
            <textobject> 
              <phrase>Shows the line plotting window.</phrase> 
            </textobject> 
          </mediaobject> 
        </screenshot> 
      </figure>

      <para>
	Into the text boxes just type in expressions where <userinput>x</userinput> is
	the independent variable.  You can also just give names of functions such as
	<userinput>cos</userinput> rather then having to type <userinput>cos(x)</userinput>.
	You can graph up to ten functions.  If you make a mistake and &appname; cannot
	parse the input it will signify this with a warning icon on the right of the text
	input box where the error occurred, as well as giving you an error dialog.
	You can change the ranges of the dependent and independent variables in the bottom
	part of the dialog.
	Pressing the <guilabel>Plot</guilabel> button produces the graph shown in <xref linkend="lineplot2-fig"/>.
      </para>

      <figure id="lineplot2-fig"> 
        <title>Plot Window</title> 
        <screenshot> 
          <mediaobject> 
            <imageobject>
              <imagedata fileref="figures/line_plot_graph.png" format="PNG" scale="50" scalefit="1"/> 
            </imageobject>
            <imageobject>
              <imagedata fileref="figures/line_plot_graph.eps" format="EPS" scale="50" scalefit="1"/> 
            </imageobject>
            <textobject> 
              <phrase>The graph produced.</phrase> 
            </textobject> 
          </mediaobject> 
        </screenshot> 
      </figure>

      <para>
	From here you can print out the plot, create encapsulated postscript
	or a PNG version of the plot or change the zoom.  If the dependent axis was
	not set correctly you can have &appname; fit it by finding out the extrema of
	the graphed functions.
      </para>

      <para>
	For plotting using the command line see the documentation of the
        <link linkend="gel-function-LinePlot"><function>LinePlot</function></link> function.
      </para>
    </sect1>

    <sect1 id="genius-parametric-plots">
      <title>Parametric Plots</title>
      <para>
	In the create plot window, you can also choose the <guilabel>Parametric</guilabel> notebook
        tab to create two dimensional parametric plots.  This way you can
	plot a single parametric function.  You can either specify the
	points as x and y, or giving a single complex number.
	See <xref linkend="paramplot-fig"/>.
      </para>

      <figure id="paramplot-fig"> 
        <title>Parametric Plot Tab</title> 
        <screenshot> 
          <mediaobject> 
            <imageobject>
              <imagedata fileref="figures/parametric.png" format="PNG" scale="50" scalefit="1"/> 
            </imageobject>
            <imageobject>
              <imagedata fileref="figures/parametric.eps" format="EPS" scale="50" scalefit="1"/> 
            </imageobject>
            <textobject> 
              <phrase>Parametric plotting tab in the <guilabel>Create Plot</guilabel> window.</phrase> 
            </textobject> 
          </mediaobject> 
        </screenshot> 
      </figure>

      <para>
	An example of a parametric plot is given in
	<xref linkend="paramplot-fig"/>.
	Similar operations can be
	done on such graphs as can be done on the other line plots.
	For plotting using the command line see the documentation of the
        <link linkend="gel-function-LinePlotParametric"><function>LinePlotParametric</function></link> or
        <link linkend="gel-function-LinePlotCParametric"><function>LinePlotCParametric</function></link> function.
      </para>

      <figure id="paramplot2-fig"> 
        <title>Parametric Plot</title> 
        <screenshot> 
          <mediaobject> 
            <imageobject>
              <imagedata fileref="figures/parametric_graph.png" format="PNG" scale="50" scalefit="1"/> 
            </imageobject>
            <imageobject>
              <imagedata fileref="figures/parametric_graph.eps" format="EPS" scale="50" scalefit="1"/> 
            </imageobject>
            <textobject> 
              <phrase>Parametric plot produced</phrase> 
            </textobject> 
          </mediaobject> 
        </screenshot> 
      </figure>

    </sect1>

    <sect1 id="genius-slopefield-plots">
      <title>Slopefield Plots</title>
      <para>
	In the create plot window, you can also choose the <guilabel>Slope field</guilabel> notebook
        tab to create a two dimensional slope field plot.
	Similar operations can be
	done on such graphs as can be done on the other line plots.
	For plotting using the command line see the documentation of the
        <link linkend="gel-function-SlopefieldPlot"><function>SlopefieldPlot</function></link> function.
      </para>

      <para>
	When a slope field is active, there is an extra <guilabel>Solver</guilabel> menu available,
	through which you can bring up the solver dialog.  Here you can have &appname; plot specific
	solutions for the given initial conditions.  You can either specify initial conditions in the dialog,
	or you can click on the plot directly to specify the initial point.  While the solver dialog
	is active, the zooming by clicking and dragging does not work.  You have to close the dialog first
	if you want to zoom using the mouse.
      </para>

      <para>
	The solver uses the standard Runge-Kutta method.
	The plots will stay on the screen until cleared.  The solver will stop whenever it reaches the boundary
	of the plot window.  Zooming does not change the limits or parameters of the solutions,
	you will have to clear and redraw them with appropriate parameters.
	You can also use the
        <link linkend="gel-function-SlopefieldDrawSolution"><function>SlopefieldDrawSolution</function></link>
	function to draw solutions from the command line or programs.  
      </para>

    </sect1>

    <sect1 id="genius-vectorfield-plots">
      <title>Vectorfield Plots</title>
      <para>
	In the create plot window, you can also choose the <guilabel>Vector field</guilabel> notebook
        tab to create a two dimensional vector field plot.
	Similar operations can be
	done on such graphs as can be done on the other line plots.
	For plotting using the command line see the documentation of the
        <link linkend="gel-function-VectorfieldPlot"><function>VectorfieldPlot</function></link> function.
      </para>

      <para>
	By default the direction and magnitude of the vector field is shown.
	To only show direction and not the magnitude, check the appropriate
	checkbox to normalize the arrow lengths.
      </para>

      <para>
	When a vector field is active, there is an extra <guilabel>Solver</guilabel> menu available,
	through which you can bring up the solver dialog.  Here you can have &appname; plot specific
	solutions for the given initial conditions.  You can either specify initial conditions in the dialog,
	or you can click on the plot directly to specify the initial point.  While the solver dialog
	is active, the zooming by clicking and dragging does not work.  You have to close the dialog first
	if you want to zoom using the mouse.
      </para>

      <para>
	The solver uses the standard Runge-Kutta method.
	The plots will stay on the screen until cleared.
	Zooming does not change the limits or parameters of the solutions,
	you will have to clear and redraw them with appropriate parameters.
	You can also use the
        <link linkend="gel-function-VectorfieldDrawSolution"><function>VectorfieldDrawSolution</function></link>
	function to draw solutions from the command line or programs.  
      </para>

    </sect1>

    <sect1 id="genius-surface-plots">
      <title>Surface Plots</title>
      <para>
	&appname; can also plot surfaces.  Select the <guilabel>Surface plot</guilabel> tab in the
	main notebook of the <guilabel>Create Plot</guilabel> window.  Here you can specify a single
	expression which should use either <varname>x</varname> and <varname>y</varname> as real independent variables
	or <varname>z</varname> as a complex variable (where <varname>x</varname> is the real part of <varname>z</varname> and <varname>y</varname> is the
	imaginary part).  For example to plot the modulus of the cosine
	function for complex parameters,
	you could enter <userinput>|cos(z)|</userinput>.  This would be
	equivalent to <userinput>|cos(x+1i*y)|</userinput>.
	See <xref linkend="surfaceplot-fig"/>.
	For plotting using the command line see the documentation of the
        <link linkend="gel-function-SurfacePlot"><function>SurfacePlot</function></link> function.
      </para>

      <figure id="surfaceplot-fig"> 
        <title>Surface Plot</title> 
        <screenshot> 
          <mediaobject> 
            <imageobject>
              <imagedata fileref="figures/surface_graph.png" format="PNG" scale="50" scalefit="1"/> 
            </imageobject>
            <imageobject>
              <imagedata fileref="figures/surface_graph.eps" format="EPS" scale="50" scalefit="1"/> 
            </imageobject>
            <textobject> 
              <phrase>Modulus of the complex cosine function.</phrase> 
            </textobject> 
          </mediaobject> 
        </screenshot> 
      </figure>

    </sect1>

  </chapter>

  <!-- ============= GEL ====================================== -->
  <chapter id="genius-gel"> 
    <title>GEL Basics</title> 

	<para>
	  GEL stands for Genius Extension Language.  <!-- Alternatively it also
	  stands for George's Ego Leverage. -->  It is the language you use
	  to write programs in &appname;. A program in GEL is simply an
	  expression that evaluates to a number.
	  &app; can therefore be used as a simple calculator, or as a
	  powerful theoretical research tool.  The syntax is meant to
	  have as shallow of a learning curve as possible, especially for use
	  as a calculator.
	</para>

    <sect1 id="genius-gel-values">
      <title>Values</title>

      <para>
Values in GEL can be <link linkend="genius-gel-values-numbers">numbers</link>, <link linkend="genius-gel-values-booleans">Booleans</link> or <link linkend="genius-gel-values-strings">strings</link>. Values can be used in calculations, assigned to variables and returned from functions, among other uses.
      </para>

      <sect2 id="genius-gel-values-numbers">
        <title>Numbers</title>
        <para>
Integers are the first type of number in GEL. Integers are written in the normal way.
<programlisting>1234
</programlisting>
Hexidecimal and octal numbers can be written using C notation. For example:
<programlisting>0x123ABC
01234
</programlisting>
Or you can type numbers in an arbitrary base using <literal>&lt;base&gt;\&lt;number&gt;</literal>. Digits higher than 10 use letters in a similar way to hexadecimal. For example, a number in base 23 could be written:
<programlisting>23\1234ABCD
</programlisting>
        </para>

        <para>
The second type of GEL number is rationals. Rationals are simply achieved by dividing two integers. So one could write:
<programlisting>3/4
</programlisting>
to get three quarters. Rationals also accept mixed fraction notation. So in order to get one and three tenths you could write:
<programlisting>1 3/10
</programlisting>
        </para>

        <para>
The next type if number is floating point. These are entered in a similar fashion to C notation. You can use <literal>E</literal>, <literal>e</literal> or <literal>@</literal> as the exponent delimiter. Note that using the exponent delimiter gives a float even if there is no decimal point in the number. Examples:
<programlisting>1.315
7.887e77
7.887e-77
.3
0.3
77e5
</programlisting>
	When &appname; prints a floating point number it will always append a
	<computeroutput>.0</computeroutput> even if the number is whole.  This is to indicate that
	floating point numbers are taken as imprecise quantities.  When a number is written in the
	scientific notation, it is always a floating point number and thus &appname; does not
	print the <computeroutput>.0</computeroutput>.
        </para>

        <para>
The final type of number in gel is the complex numbers. You can enter a complex number as a sum of real and imaginary parts. The imaginary part ends with an <literal>i</literal>.  Here are examples of entering complex numbers:
<programlisting>1+2i
8.01i
77*e^(1.3i)
</programlisting>
        </para>

        <important>
          <para>
When entering imaginary numbers, a number must be in front of the <literal>i</literal>. If you use <literal>i</literal> by itself, &appname; will interpret this as referring to the variable <varname>i</varname>. If you need to refer to <literal>i</literal> by itself, use <literal>1i</literal> instead.
          </para>

          <para>
In order to use mixed fraction notation with imaginary numbers you must have the mixed fraction in parentheses. (i.e., <userinput>(1 2/5)i</userinput>)
          </para>
        </important>

      </sect2>


      <sect2 id="genius-gel-values-booleans">
        <title>Booleans</title>
        <para>
&appname; also supports native Boolean values. The two Boolean constants are
defined as <constant>true</constant> and <constant>false</constant>; these
identifiers can be used like any other variable. You can also use the
identifiers <constant>True</constant>, <constant>TRUE</constant>,
<constant>False</constant> and <constant>FALSE</constant> as aliases for the
above.
        </para>
        <para>
At any place where a Boolean expression is expected, you can use a Boolean
value or any expression that produces either a number or a Boolean. If
&appname; needs to evaluate a number as a Boolean it will interpret
0 as <constant>false</constant> and any other number as
<constant>true</constant>.
         </para>
        <para>
In addition, you can do arithmetic with Boolean values. For example:
<programlisting>( (1 + true) - false ) * true
</programlisting>
is the same as:
<programlisting>( (true or true) or not false ) and true
</programlisting>
Only addition, subtraction and multiplication are supported. If you mix numbers with Booleans in an expression then the numbers are converted to Booleans as described above. This means that, for example:
<programlisting>1 == true
</programlisting>
always evaluates to <constant>true</constant> since 1 will be converted to <constant>true</constant> before being compared to <constant>true</constant>.
        </para>
      </sect2>


      <sect2 id="genius-gel-values-strings">
        <title>Strings</title>
        <para>
Like numbers and Booleans, strings in GEL can be stored as values inside variables and passed to functions. You can also concatenate a string with another value using the plus operator. For example:
<programlisting>a=2+3;"The result is: "+a
</programlisting>
will create the string:
<programlisting>The result is: 5
</programlisting>
You can also use C-like escape sequences such as <literal>\n</literal>,<literal>\t</literal>,<literal>\b</literal>,<literal>\a</literal> and <literal>\r</literal>. To get a <literal>\</literal> or <literal>"</literal> into the string you can quote it with a <literal>\</literal>. For example:
<programlisting>"Slash: \\ Quotes: \" Tabs: \t1\t2\t3"
</programlisting>
will make a string:
<programlisting>Slash: \ Quotes: " Tabs: 	1	2	3
</programlisting>
        </para>
        <para>
In addition, you can use the library function <function>string</function> to convert anything to a string. For example:
<programlisting>string(22)
</programlisting>
will return
<programlisting>"22"
</programlisting>
Strings can also be compared with <literal>==</literal> (equal), <literal>!=</literal> (not equal) and <literal>&lt;=&gt;</literal> (comparison) operators
        </para>
      </sect2>


      <sect2 id="genius-gel-values-null">
        <title>Null</title>
        <para>
There is a special value called
<constant>null</constant>. No operations can be performed on
it, and nothing is printed when it is returned. Therefore,
<constant>null</constant> is useful when you do not want output from an
expression.  The value <constant>null</constant> can be obtained as an expression when you
type <literal>.</literal>, the contant <constant>null</constant> or nothing.
By nothing we mean that if you end an expression with
a separator <literal>;</literal>, it is equivalent to ending it with a
separator followed by a <constant>null</constant>.
        </para>
        <para>
Example:
<programlisting>x=5;.
x=5;
</programlisting>
        </para>
<para>
Some functions return <constant>null</constant> when no value can be returned
or an error happened.  Also <constant>null</constant> is used as an empty vector
or matrix, or an empty reference.
</para>
      </sect2>

    </sect1>

    <sect1 id="genius-gel-variables">
      <title>Using Variables</title>

      <para>
Syntax:
<programlisting>VariableName
</programlisting>
Example:
<screen><prompt>genius> </prompt><userinput>e</userinput>
= 2.71828182846
</screen>
      </para>

      <para>
To evaluate a variable by itself, just enter the name of the variable. This will return the value of the variable. You can use a variable anywhere you would normally use a number or string. In addition, variables are necessary when defining functions that take arguments (see <xref linkend="genius-gel-functions-defining"/>).
      </para>

      <tip>
        <title>Using Tab completion</title>
        <para>
You can use Tab completion to get &appname; to complete variable names for you. Try typing the first few letters of the name and pressing <userinput>Tab</userinput>.
        </para>
      </tip>

      <important>
        <title>Variable names are case sensitive</title>
        <para>
The names of variables are case sensitive. That means that variables named <varname>hello</varname>, <varname>HELLO</varname> and <varname>Hello</varname> are all different variables.
        </para>
      </important>


      <sect2 id="genius-gel-variables-setting">
        <title>Setting Variables</title>
        <para>
Syntax:
<programlisting><![CDATA[<identifier> = <value>
<identifier> := <value>]]>
</programlisting>
Example:
<programlisting>x = 3
x := 3
</programlisting>
        </para>

        <para>
To assign to a variable, use the <literal>=</literal> or <literal>:=</literal> operators. These operators set the value of the variable and return the number you set, so you can do things like
<programlisting>a = b = 5
</programlisting>
        </para>

        <para>
The <literal>=</literal> and <literal>:=</literal> operators can both be used to set variables. The difference between them is that the <literal>:=</literal> operator always acts as an assignment operator, whereas the <literal>=</literal> operator may be interpreted as testing for equality when used in a context where a Boolean expression is expected.
       </para>

	<para>
	  For issues regarding the scope of variables, see <xref
linkend="genius-gel-variables-global"/>.
	</para>
      </sect2>

      <sect2 id="genius-gel-variables-built-in">
        <title>Built-in Variables</title>
        <para>
GEL has a number of built-in &lsquo;variables&rsquo;, such as
<varname>e</varname>, <varname>pi</varname> or <varname>GoldenRatio</varname>.  These are widely used constants with a preset value, and
they cannot be assigned new values.
There are a number of other built-in variables.
See <xref linkend="genius-gel-function-list-constants" /> for a full list.
        </para>
      </sect2>


      <sect2 id="genius-gel-previous-result">
        <title>Previous Result Variable</title>
        <para>
The <varname>Ans</varname> and <varname>ans</varname> variables can be used to get the result of the last expression. For example, if you had performed some calculation, to add 389 to the result you could do:
<programlisting>Ans+389
</programlisting>
        </para>
      </sect2>
    </sect1>

    <sect1 id="genius-gel-functions">
      <title>Using Functions</title>

      <para>
Syntax:
<programlisting>FunctionName(argument1, argument2, ...)
</programlisting>
Example:
<programlisting>Factorial(5)
cos(2*pi)
gcd(921,317)
</programlisting>

To evaluate a function, enter the name of the function, followed by the arguments (if any) to the function in parentheses. This will return the result of applying the function to its arguments. The number of arguments to the function is, of course, different for each function.
      </para>

      <para>
There are many built-in functions, such as <function>sin</function>, <function>cos</function> and <function>tan</function>. You can use the <function>help</function> built-in function to get a list of available functions, or see <xref linkend="genius-gel-function-list" /> for a full listing.
      </para>

      <tip>
        <title>Using Tab completion</title>
        <para>
You can use Tab completion to get &appname; to complete function names for you. Try typing the first few letters of the name and pressing <userinput>Tab</userinput>.
        </para>
      </tip>

      <important>
        <title>Function names are case sensitive</title>
        <para>
The names of functions are case sensitive. That means that functions named <function>dosomething</function>, <function>DOSOMETHING</function> and <function>DoSomething</function> are all different functions.
        </para>
      </important>


      <sect2 id="genius-gel-functions-defining">
        <title>Defining Functions</title>
        <para>
Syntax:
<programlisting><![CDATA[function <identifier>(<comma separated arguments>) = <function body>
<identifier> = (`() = <function body>)
]]></programlisting>
The <literal>`</literal> is the backquote character, and signifies an anonymous function. By setting it to a variable name you effectively define a function.
        </para>

        <para>
A function takes zero or more comma separated arguments, and returns the result of the function body. Defining your own functions is primarily a matter of convenience; one possible use is to have sets of functions defined in GEL files which &appname; can load in order to make available.
Example:
<programlisting>function addup(a,b,c) = a+b+c
</programlisting>
then <userinput>addup(1,4,9)</userinput> yields 14
        </para>
      </sect2>

      <sect2 id="genius-gel-functions-variable-argument-lists">
        <title>Variable Argument Lists</title>
        <para>
If you include <literal>...</literal> after the last argument name in the function declaration, then &appname; will allow any number of arguments to be passed in place of that argument. If no arguments were passed then that argument will be set to <constant>null</constant>. Otherwise, it will be a horizontal vector containing all the arguments. For example:
<programlisting>function f(a,b...) = b
</programlisting>
Then <userinput>f(1,2,3)</userinput> yields <computeroutput>[2,3]</computeroutput>, while <userinput>f(1)</userinput> yields a <constant>null</constant>.
        </para>
      </sect2>


      <sect2 id="genius-gel-functions-passing-functions">
        <title>Passing Functions to Functions</title>

        <para>
In &appname;, it is possible to pass a function as an argument to another function. This can be done using either &lsquo;function nodes&rsquo; or anonymous functions.
        </para>

        <para>
If you do not enter the parentheses after a function name, instead of being evaluated, the function will instead be returned as a &lsquo;function node&rsquo;. The function node can then be passed to another function.
Example:
<programlisting>function f(a,b) = a(b)+1;
function b(x) = x*x;
f(b,2)
</programlisting>

If you want to pass a function that doesn&rsquo;t exist yet, you can use an anonymous function (see <xref linkend="genius-gel-functions-defining" />).
        </para>
        <para>
Syntax:
<programlisting><![CDATA[function(<comma separated arguments>) = <function body>
`(<comma separated arguments>) = <function body>
]]></programlisting>
Example:
<programlisting>function f(a,b) = a(b)+1;
f(`(x) = x*x,2)
</programlisting>
        </para>
      </sect2>


    <sect2 id="genius-gel-functions-operations">
      <title>Operations on Functions</title>
      <para>
Some functions allow arithmetic operations, and some single argument functions such as <function>exp</function> or <function>ln</function>, to operate on the function. For example,
<programlisting>exp(sin*cos+4)
</programlisting>
will return a function that does
<programlisting>exp(sin(x)*cos(x)+4)
</programlisting>
This can be useful when quickly defining functions. For example to create a function to perform the above operation, you can just type:
<programlisting>f = exp(sin*cos+4)
</programlisting>
This can also be used in plotting. For example, to plot sin squared you can enter:
<programlisting>LinePlot(sin^2)
</programlisting>
      </para>

      <warning>
        <para>
Not all functions can be used in this way. In addition, when you use a binary operation the functions must take the same arguments. 
        </para>
      </warning>
    </sect2>


    </sect1>

    <sect1 id="genius-gel-absolute-value-modulus">
      <title>Absolute Value / Modulus</title>
      <para>
You can make an absolute value of something by putting the
<literal>|</literal>'s around it.  For example:
<programlisting>|a-b|</programlisting>
</para>
<para>
In case the expression is a complex number the result will be the modulus
(distance from the origin).  For example:
<userinput>|3 * e^(1i*pi)|</userinput>
returns 3.
      </para>
    </sect1>

    <sect1 id="genius-gel-separator">
      <title>Separator</title>
      <para>
In GEL if you want to type more than one command you have to use
the <literal>;</literal> operator, which is a way to separate expressions,
such a combined expression will return whatever is the result of the last
one, so suppose you type the following:
<programlisting>3 ; 5
</programlisting>
This expression will yield 5.
      </para>
      <para>
This will require some parenthesizing to make it unambiguous sometimes,
especially if the <literal>;</literal> is not the top most primitive. This slightly differs from
other programming languages where the <literal>;</literal> is a terminator of statements, whereas
in GEL it&rsquo;s actually a binary operator. If you are familiar with pascal
this should be second nature. However genius can let you pretend it is a
terminator somewhat, if a <literal>;</literal> is found at the end of a parenthesis or a block,
genius will itself append a null node to it as if you would have written
<userinput>;null</userinput>.
This is usefull in case you do not want to return a value from say a loop,
or if you handle the return differently. Note that it will slightly slow down
the code if it is executed too often as there is one more operator involved.
      </para>
    </sect1>

    <sect1 id="genius-gel-modular-evaluation">
      <title>Modular Evaluation</title>
      <para>
Sometimes when working with large numbers, it might be faster if results are
modded after each calculation.  To use it you just add "mod &lt;integer&gt;" after
the expression.  Example:
<programlisting>2^(5!) * 3^(6!) mod 5</programlisting>
You can calculate the inverses of numbers mod some integer by just using
rational numbers (of course the inverse has to exist).
Examples:
<programlisting>10^-1 mod 101
1/10 mod 101</programlisting>
You can also do modular evaluation with matrices including taking inverses,
powers and dividing.
Example:
<programlisting>A = [1,2;3,4]
B = A^-1 mod 5
A*B mod 5</programlisting>
This should yield the identity matrix as B will be the inverse of A mod 5.
      </para>
      <para>
Some functions such as
<link linkend='gel-function-sqrt'><function>sqrt</function></link> or
<link linkend='gel-function-log'><function>log</function></link>
work in a different way when in modulo mode.  These will then work like their
discrete versions working within the ring of integers you selected.  For
example:
<programlisting>genius> sqrt(4) mod 7
=
[2, 5]
genius> 2*2 mod 7
= 4</programlisting>
	<function>sqrt</function> will actually return all the possible square
	roots.
      </para>
    </sect1>

    <sect1 id="genius-gel-operator-list">
      <title>List of GEL Operators</title>

      <para>
	As everything in gel is really just an expression, it is really just
	all connected together with operators.  Here is a list of the
	operators in GEL. 
      </para>

      <variablelist>
        <varlistentry>
         <term><synopsis>a;b</synopsis></term>
         <listitem>
           <para>
             The separator, just evaluates both
	     <varname>a</varname> and
	     <varname>b</varname>,
	     but returns only the result of
	     <varname>b</varname>.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a=b</synopsis></term>
         <listitem>
           <para>
	     The assignment operator.  This assigns <varname>b</varname> to
<varname>a</varname> (<varname>a</varname> must be a valid <link
linkend='genius-gel-lvalues'>lvalue</link>) (note however that this operator
may be translated to <literal>==</literal> if used in a place where boolean
expression is expected)
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a:=b</synopsis></term>
         <listitem>
           <para>
	     The assignment operator.  Assigns <varname>b</varname> to
<varname>a</varname> (<varname>a</varname> must be a valid <link linkend='genius-gel-lvalues'>lvalue</link>).  This is
different from <literal>=</literal> because it never gets translated to a
<literal>==</literal>.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>|a|</synopsis></term>
         <listitem>
           <para>
             Absolute value or modulus (if <varname>a</varname>
	     is a complex number).
           </para>
          <para>
	    See
	    <ulink url="http://mathworld.wolfram.com/AbsoluteValue.html">Mathworld</ulink> for more information.
	  </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a^b</synopsis></term>
         <listitem>
           <para>
             Exponentiation, raises <varname>a</varname> to the <varname>b</varname>th power.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a.^b</synopsis></term>
         <listitem>
           <para>
	     Element by element exponentiation.  Raise each element of a matrix
	     <varname>a</varname> to the <varname>b</varname>th power.  Or if
	     <varname>b</varname> is a matrix of the same size as
	     <varname>a</varname>, then do the operation element by element.
	     If <varname>a</varname> is a number and <varname>b</varname> is a
	     matrix then it creates matrix of the same size as
	     <varname>b</varname> with <varname>a</varname> raised to all the
	     different powers in <varname>b</varname>.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a+b</synopsis></term>
         <listitem>
           <para>
             Addition.  Adds two numbers, matrices, functions or strings.  If
	     you add a string to anything the result will just be a string.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a-b</synopsis></term>
         <listitem>
           <para>
             Subtraction.  Subtract two numbers, matrices or functions.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a*b</synopsis></term>
         <listitem>
           <para>
             Multiplication.  This is the normal matrix multiplication.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a.*b</synopsis></term>
         <listitem>
           <para>
	     Element by element multiplication if <varname>a</varname> and
	     <varname>b</varname> are matrices.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a/b</synopsis></term>
         <listitem>
           <para>
             Division.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a./b</synopsis></term>
         <listitem>
           <para>
             Element by element division.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a\b</synopsis></term>
         <listitem>
           <para>
             Back division.  That is this is the same as <userinput>b/a</userinput>.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a.\b</synopsis></term>
         <listitem>
           <para>
             Element by element back division.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a%b</synopsis></term>
         <listitem>
           <para>
	     The mod operator.  This does not turn on the <link
	     linkend='genius-gel-modular-evaluation'>modular mode</link>, but
	     just returns the remainder of <userinput>a/b</userinput>.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a.%b</synopsis></term>
         <listitem>
           <para>
             Element by element the mod operator.  Returns the remaineder
	     after element by element <userinput>a./b</userinput>.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a mod b</synopsis></term>
         <listitem>
           <para>
             Modular evaluation operator.  The expression <varname>a</varname>
	     is evaluated modulo <varname>b</varname>.  See <xref
	     linkend='genius-gel-modular-evaluation' />.
	     Some functions and operators behave differently modulo an integer.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a!</synopsis></term>
         <listitem>
           <para>
             Factorial operator.  This is like
	     <userinput>1*...*(n-2)*(n-1)*n</userinput>.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a!!</synopsis></term>
         <listitem>
           <para>
             Double factorial operator.  This is like
	     <userinput>1*...*(n-4)*(n-2)*n</userinput>.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a==b</synopsis></term>
         <listitem>
           <para>
	     Equality operator
	     (returns <constant>true</constant> or <constant>false</constant>).
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a!=b</synopsis></term>
         <listitem>
           <para>
             Inequality operator,
	     returns <constant>true</constant> if <varname>a</varname> does not
	     equal <varname>b</varname> else returns <constant>false</constant>.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a&lt;&gt;b</synopsis></term>
         <listitem>
           <para>
             Alternative inequality operator,
	     returns <constant>true</constant> if <varname>a</varname> does not
	     equal <varname>b</varname> else returns <constant>false</constant>.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a&lt;=b</synopsis></term>
         <listitem>
           <para>
             Less than or equal operator,
	     returns <constant>true</constant> if <varname>a</varname> is
	     less than or equal to 
	     <varname>b</varname> else returns <constant>false</constant>.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a&gt;=b</synopsis></term>
         <listitem>
           <para>
             Greater than or equal operator,
	     returns <constant>true</constant> if <varname>a</varname> is
	     greater than or equal to 
	     <varname>b</varname> else returns <constant>false</constant>.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a&lt;=&gt;b</synopsis></term>
         <listitem>
           <para>
	     Comparison operator.  If <varname>a</varname> is equal to
	     <varname>b</varname> it returns 0, if <varname>a</varname> is less
	     than <varname>b</varname> it returns -1 and if
	     <varname>a</varname> is greater than <varname>b</varname> it
	     returns 1.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a and b</synopsis></term>
         <listitem>
           <para>
             Logical and.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a or b</synopsis></term>
         <listitem>
           <para>
             Logical or.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a xor b</synopsis></term>
         <listitem>
           <para>
             Logical xor.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>not a</synopsis></term>
         <listitem>
           <para>
             Logical not.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>-a</synopsis></term>
         <listitem>
           <para>
             Negation operator.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>&amp;a</synopsis></term>
         <listitem>
           <para>
             Variable referencing (to pass a reference to something).
	     See <xref linkend='genius-gel-references' />.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>*a</synopsis></term>
         <listitem>
           <para>
             Variable dereferencing (to access a referenced varible).
	     See <xref linkend='genius-gel-references' />.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a'</synopsis></term>
         <listitem>
           <para>
             Matrix conjugate transpose.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a.'</synopsis></term>
         <listitem>
           <para>
             Matrix transpose, does not conjugate the entries.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a@(b,c)</synopsis></term>
         <listitem>
           <para>
	     Get element of a matrix in row <varname>b</varname> and column
	     <varname>c</varname>.   If <varname>b</varname>,
	     <varname>c</varname> are vectors, then this gets the corresponding
	     rows columns or submatrices.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a@(b,)</synopsis></term>
         <listitem>
           <para>
             Get row of a matrix (or rows if <varname>b</varname> is a vector).
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a@(b,:)</synopsis></term>
         <listitem>
           <para>
             Same as above.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a@(,c)</synopsis></term>
         <listitem>
           <para>
	     Get column of a matrix (or columns if <varname>c</varname> is a
	     vector).
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a@(:,c)</synopsis></term>
         <listitem>
           <para>
             Same as above.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a@(b)</synopsis></term>
         <listitem>
           <para>
             Get an element from a matrix treating it as a vector.  This will
	     traverse the matrix row-wise.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a:b</synopsis></term>
         <listitem>
           <para>
             Build a vector from <varname>a</varname> to <varname>b</varname> (or specify a row, column region for the <literal>@</literal> operator).  For example to get rows 2 to 4 of mamtrix <varname>A</varname> we could do
	     <programlisting>A@(2:4,)
	     </programlisting>
	     as <userinput>2:4</userinput> will return a vector
	     <userinput>[2,3,4]</userinput>.
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>a:b:c</synopsis></term>
         <listitem>
           <para>
	     Build a vector from <varname>a</varname> to <varname>c</varname>
	     with <varname>b</varname> as a step.  That is for example
	     <programlisting>genius> 1:2:9
=
`[1, 3, 5, 7, 9]
</programlisting>
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>(a)i</synopsis></term>
         <listitem>
           <para>
	     Make a imaginary number (multiply <varname>a</varname> by the
	     imaginary).  Note that normally the number <varname>i</varname> is
	     written as <userinput>1i</userinput>.  So the above is equal to
	     <programlisting>(a)*1i
	     </programlisting>
           </para>
         </listitem>
        </varlistentry>


        <varlistentry>
         <term><synopsis>`a</synopsis></term>
         <listitem>
           <para>
             Quote an identifier so that it doesn't get evaluated.  Or
	     quote a matrix so that it doesn't get expanded.
           </para>
         </listitem>
        </varlistentry>


      </variablelist>

<note>
<para>
The @() operator makes the : operator most useful.  With this you can specify regions of a matrix.  So that a@(2:4,6) is the rows 2,3,4 of the column 6. Or a@(,1:2) will get you the first two columns of a matrix. You can also assign to the @() operator, as long as the right value is a matrix that matches the region in size, or if it is any other type of value.
</para>
</note>

<note>
<para>
The comparison operators (except for the &lt;=&gt; operator which behaves normally), are not strictly binary operators, they can in fact be grouped in the normal mathematical way, e.g.: (1&lt;x&lt;=y&lt;5) is a legal boolean expression and means just what it should, that is (1&lt;x and x&le;y and y&lt;5)
</para>
</note>

<note>
<para>
The unitary minus operates in a different fashion depending on where it
appears.  If it appears before a number it binds very closely, if it appears in
front of an expression it binds less than the power and factorial operators.
So for example <userinput>-1^k</userinput> is really <userinput>(-1)^k</userinput>,
but <userinput>-foo(1)^k</userinput> is really <userinput>-(foo(1)^k)</userinput>.  So
be careful how you use it and if in doubt, add parentheses.
</para>
</note>
    </sect1>

  </chapter>

  <!-- ============= GEL Programming ========================== -->
  <chapter id="genius-gel-programming">
    <title>Programming with GEL</title>

    <sect1 id="genius-gel-conditionals">
      <title>Conditionals</title>
      <para>
Syntax:
<programlisting><![CDATA[if <expression1> then <expression2> [else <expression3>]
]]></programlisting>
If <literal>else</literal> is omitted, then if the <literal>expression1</literal> yields <constant>false</constant> or 0, <literal>NULL</literal> is returned.
      </para>
      <para>
Examples:
<programlisting><![CDATA[if(a==5)then(a=a-1)
if b<a then b=a
if c>0 then c=c-1 else c=0
a = ( if b>0 then b else 1 )
]]></programlisting>
Note that <literal>=</literal> will be translated to <literal>==</literal> if used inside the expression for <literal>if</literal>, so
<programlisting>if a=5 then a=a-1
</programlisting>
will be interpreted as:
<programlisting>if a==5 then a:=a-1
</programlisting>
      </para>
    </sect1>

    <sect1 id="genius-gel-loops">
      <title>Loops</title>

      <sect2 id="genius-gel-loops-while">
        <title>While Loops</title>
        <para>
Syntax:
<programlisting><![CDATA[while <expression1> do <expression2>
until <expression1> do <expression2>
do <expression2> while <expression1>
do <expression2> until <expression1>]]></programlisting>

These are similiar to other languages, however they return the result of the last iteration or <literal>NULL</literal> if no iteration was done.  In the boolean expression, <literal>=</literal> is translated into <literal>==</literal> just as for the <literal>if</literal> statement.
        </para>
      </sect2>

      <sect2 id="genius-gel-loops-for">
        <title>For Loops</title>
        <para>
Syntax:
<programlisting><![CDATA[for <identifier> = <from> to <to> do <body>
for <identifier> = <from> to <to> by <increment> do <body>]]></programlisting>

Loop with identifier being set to all values from <literal>&lt;from&gt;</literal> to <literal>&lt;to&gt;</literal>, optionally using an increment other than 1. These are faster, nicer and more compact than the normal loops such as above, but less flexible. The identifier must be an identifier and can't be a dereference. The value of identifier is the last value of identifier, or <literal>&lt;from&gt;</literal> if body was never evaluated. The variable is guaranteed to be initialized after a loop, so you can safely use it.  Also the <literal>&lt;from&gt;</literal>, <literal>&lt;to&gt;</literal> and <literal>&lt;increment&gt;</literal> must be non complex values. The <literal>&lt;to&gt;</literal> is not guaranteed to be hit, but will never be overshot, for example the following prints out odd numbers from 1 to 19:
<programlisting>for i = 1 to 20 by 2 do print(i)
</programlisting>
        </para>
      </sect2>

      <sect2 id="genius-gel-loops-foreach">
        <title>Foreach Loops</title>
        <para>
Syntax:
<programlisting><![CDATA[for <identifier> in <matrix> do <body>]]></programlisting>

For each element, going row by row from left to right do the body. To
print numbers 1,2,3 and 4 in this order you could do:
<programlisting>for n in [1,2:3,4] do print(n)
</programlisting>
If you wish to run through the rows and columns of a matrix, you can use
the RowsOf and ColumnsOf functions which return a vector of the rows or
columns of the matrix.  So,
<programlisting>for n in RowsOf ([1,2:3,4]) do print(n)
</programlisting>
will print out [1,2] and then [3,4].
        </para>
      </sect2>

      <sect2 id="genius-gel-loops-break-continue">
        <title>Break and Continue</title>
        <para>
You can also use the <literal>break</literal> and <literal>continue</literal> commands in loops. The continue <literal>continue</literal> command will restart the current loop at its next iteration, while the <literal>break</literal> command exits the current loop.
<programlisting><![CDATA[while(<expression1>) do (
  if(<expression2>) break
  else if(<expression3>) continue;
  <expression4>
)
]]></programlisting>
        </para>
      </sect2>
    </sect1>

    <sect1 id="genius-gel-sums-products">
      <title>Sums and Products</title>
      <para>
Syntax:
<programlisting><![CDATA[sum <identifier> = <from> to <to> do <body>
sum <identifier> = <from> to <to> by <increment> do <body>
sum <identifier> in <matrix> do <body>
prod <identifier> = <from> to <to> do <body>
prod <identifier> = <from> to <to> by <increment> do <body>
prod <identifier> in <matrix> do <body>]]></programlisting>

If you substitute <literal>for</literal> with <literal>sum</literal> or <literal>prod</literal>, then you will get a sum or a product instead of a <literal>for</literal> loop. Instead of returning the last value, these will return the sum or the product of the values respectively.
      </para>
      <para>
If no body is executed (for example <userinput>sum i=1 to 0 do ...</userinput>) then <literal>sum</literal> returns 0 and <literal>prod</literal> returns 1 as is the standard convention.
      </para>
    </sect1>

    <sect1 id="genius-gel-comparison-operators">
      <title>Comparison Operators</title>
      <para>
	The following standard comparison operators are supported in GEL and have the obvious meaning:
	<literal>==</literal>, <literal>&gt;=</literal>,
	<literal>&lt;=</literal>, <literal>!=</literal>,
	<literal>&lt;&gt;</literal>, <literal>&lt;</literal>,
	<literal>&gt;</literal>.  They return <constant>true</constant> or
	<constant>false</constant>.
	The operators
	<literal>!=</literal> and <literal>&lt;&gt;</literal> are the same
	thing and mean "is not equal to".
	GEL also supports the operator
	<literal>&lt;=&gt;</literal>, which returns -1 if left side is
	smaller, 0 if both sides are equal, 1 if left side is larger.
      </para>

      <para>
	Normally <literal>=</literal> is translated to <literal>==</literal> if
	it happens to be somewhere where GEL is expecing a condition such as
	in the if condition.  For example
	<programlisting>if a=b then c
if a==b then c
</programlisting>
	are the same thing in GEL.  However you should really use
	<literal>==</literal> or <literal>:=</literal> when you want to compare
	or assign respectively if you want your code to be easy to read and
	to avoid mistakes.
      </para>

      <para>
	All the comparison operators (except for the
	<literal>&lt;=&gt;</literal> operator which
	behaves normally), are not strictly binary operators, they can in fact
	be grouped in the normal mathematical way, e.g.:
	(<literal>1&lt;x&lt;=y&lt;5</literal>) is
	a legal boolean expression and means just what it should, that is
	(1&lt;x and x&le;y and y&lt;5)
      </para>
      <para>
	To build up logical expressions use the words <literal>not</literal>,
	<literal>and</literal>, <literal>or</literal>, <literal>xor</literal>.
	The operators <literal>or</literal> and <literal>and</literal> are
special beasts as they evaluate their arguemnts one by one, so the usual trick
for conditional evaluation works here as well. For example, <literal>1 or a=1</literal> will not set
<literal>a=1</literal> since the first argument was true.
      </para>
    </sect1>

      <sect1 id="genius-gel-variables-global">
        <title>Global Variables and Scope of Variables</title>
	<para>
	  Like most programming languages, GEL has two different types
	  of variables: local and global.  A local variable only exists
	  in the context of the function where it is set and all functions
	  called from inside this function.  A global variable
	  exists in all contexts.  When you set a variable on the toplevel
	  command line, outside of any function, then it will be a global.
	  All functions will see it.
        </para>
        <para>
          When you set a variable inside a function, it will only be seen
	  inside the function, including all function calls that are made
	  inside this function.  This is where GEL differs from a language
	  such as C.  One could describe local variables as being semi global
	  in this sense.  For example the following code will print out 5.
	  but the function <function>g</function> cannot be called on the
	  top level as <varname>a</varname> will not be defined.
<programlisting>function f() = (a:=5; g());
function g() = print(a);
f();
</programlisting>
	</para>
        <para>
	  Suppose you assign a value to an identifier inside a function,
	  and this identifier is also used for a global variable, or a
	  variable set in a calling function.  Then this has the effect of
	  creating a new local variable inside the function.  For example
	  the following code will print out 6 and not 5.
<programlisting>a=6;
function f() = (a:=5);
print(a);
</programlisting>
	</para>
        <para>
	  Sometimes however it is neccessary to set
a global variable from inside a function. For this, use the
<function>set</function> function. Passing a string or a quoted identifier to
this function sets the variable globally. For example, to set
<varname>a</varname> to the value 3 you could call:
<programlisting>set(`a,3)
</programlisting>
or:
<programlisting>set("a",3)
</programlisting>
        </para>
        <para>
	  The <function>set</function> function always sets the toplevel
	  global.  There is no way to set a local variable in some function
	  from a subroutine.  For this you must use passing by reference.
        </para>
      </sect1>

    <sect1 id="genius-gel-returning">
      <title>Returning</title>
	<para>
	  Normally a function is one or several expressions separated by a
semicolon, and the value of the last expression is returned.  This is fine for
simple functions, but
sometimes you do not want a function to return the last thing calculated. You may, for example, want to return from a middle of a function. In this case, you can use the <literal>return</literal> keyword. <literal>return</literal> takes one argument, which is the value to be returned.
      </para>
      <para>
Example:
<programlisting><![CDATA[function f(x) = (
  y=1;
  while true do (
    if x>50 then return y;
    y=y+1;
    x=x+1
  )
)
]]></programlisting>
      </para>
    </sect1>


    <sect1 id="genius-gel-references">
      <title>References</title>
      <para>
	It may be neccessary for some functions to return more than one value.
	This may be accomplished by returning a vector of values, but many
	times it is convenient to use passing a reference to a variable.
	You pass a reference to a variable to a function, and the function
	will set the variable for you using a dereference.  You do not have
	to use references only for this purpose, but this is their main use.
      </para>
      <para>
	When using functions which return values through references
	in the argument list, just pass the variable name with an ampersand.
	For example the following code will compute an eigenvalue of a matrix
	<varname>A</varname> with initial eigenvector guess
	<varname>x</varname>, and store the computed eigenvector
	into the variable named <varname>v</varname>:
<programlisting><![CDATA[RayleighQuotientIteration (A,x,0.001,100,&v)
]]></programlisting>
      </para>
      <para>
The details of how references work and the syntax is similar to the C language.
The operator
<literal>&amp;</literal> references a variable
and <literal>*</literal> dereferences a variable. Both can only be applied to an identifier,
so <literal>**a</literal> is not a legal expression in GEL.
      </para>
      <para>
References are best explained by an example:
<programlisting><![CDATA[a=1;
b=&a;
*b=2;
]]></programlisting>
now <varname>a</varname> contains 2.  You can also reference functions:
<programlisting><![CDATA[function f(x) = x+1;
t=&f;
*t(3)
]]></programlisting>
gives us 4.
      </para>
    </sect1>

    <sect1 id="genius-gel-lvalues">
      <title>Lvalues</title>
      <para>
	An lvalue is the left hand side of an assignment. In other words, an
	lvalue is what you assign something to.  Valid lvalues are:
<variablelist>
  <varlistentry>
    <term><userinput>a</userinput></term>
    <listitem>
      <para>
	Identifier.  Here we would be setting the varable of name
	<varname>a</varname>.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><userinput>*a</userinput></term>
    <listitem>
      <para>
	Dereference of an identifier.  This will set whatever variable
	<varname>a</varname> points to.
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><userinput>a@(&lt;region&gt;)</userinput></term>
    <listitem>
      <para>
	A region of a matrix.  Here the region is specified normally as with
	the regular @() operator, and can be a single entry, or an entire
	region of the matrix.
      </para>
    </listitem>
  </varlistentry>
</variablelist>
      </para>
      <para>
Examples:
<programlisting>a:=4
*tmp := 89
a@(1,1) := 5
a@(4:8,3) := [1,2,3,4,5]'
</programlisting>
Note that both <literal>:=</literal> and <literal>=</literal> can be used
interchangably.  Except if the assignment appears in a condition.
It is thus always safer to just use
<literal>:=</literal> when you mean assignment, and <literal>==</literal>
when you mean comparison.
      </para>
    </sect1>

  </chapter>

  <chapter id="genius-gel-programming-advanced">
    <title>Advanced Programming with GEL</title>

    <sect1 id="genius-gel-error-handling">
      <title>Error Handling</title>
      <para>
If you detect an error in your function, you can bail out of it. For normal
errors, such as wrong types of arguments, you can fail to compute the function
by adding the statement <literal>bailout</literal>. If something went
really wrong and you want to completely kill the current computation, you can
use <literal>exception</literal>.
      </para>
      <para>
	For example if you want to check for arguments in your function.  You
could use the following code.
<programlisting>function f(M) = (
  if not IsMatrix (M) then (
    error ("M not a matrix!");
    bailout
  );
  ...
)
</programlisting>
      </para>
    </sect1>

    <sect1 id="genius-gel-toplevel-syntax">
      <title>Toplevel Syntax</title>
      <para>
	The synatax is slightly different if you enter statements on
	the top level versus when they are inside parentheses or
	inside functions.  On the top level, enter acts the same as if
	you press return on the command line.  Therefore think of programs
	as just sequence of lines as if were entered on the command line.
	In particular, you do not need to enter the separator at the end of the
	line (unless it is of course part of several statements inside
	parenteses).
      </para>
      <para>
	The following code will produce an error when entered on the top
	level of a program, while it will work just fine in a function.
<programlisting>if Something() then
  DoSomething()
else
  DoSomethingElse()
</programlisting>
      </para>
      <para>
	The problem is that after &app; sees the end of line after the
	second line, it will decide that we have whole statement and
	it will execute it.  After the execution is done, &app; will
	go on to the next
	line, it will see <literal>else</literal>, and it will produce
	a parsing error.  To fix this, use parentheses.  &app; will not
	be satisfied until it has found that all parenteses are closed.
<programlisting>if Something() then (
  DoSomething()
) else (
  DoSomethingElse()
)
</programlisting>
      </para>
    </sect1>

     <sect1 id="genius-gel-returning-functions">
       <title>Returning Functions</title>
	<para>
	  It is possible to return functions as value.  This way you can
	  build functions which construct special purpose functions according
	  to some parameters.  The tricky bit is what variables does the
	  function see.  The way this works in GEL is that when a function
	  returns another function, all identifiers referenced in the
	  function body are prepended a private dictionary of the returned
	  function.  So the function will see all variables that were in scope
	  when it was defined.  For example we define a function which
	  returns a function which adds 5 to its argument.
<programlisting>function f() = (
  k = 5;
  `(x) = (x+k)
)
</programlisting>
	  Notice that the function adds <varname>k</varname> to
	  <varname>x</varname>.  You could use this as follows.
<programlisting>g = f();
g(5)
</programlisting>
	  And <userinput>g(5)</userinput> should return 10.
        </para>
	<para>
	  One thing to note is that the value of <varname>k</varname>
	  that is used is the one that's in effect when the
	  <function>f</function> returns.  So for example
<programlisting>function f() = (
  k = 5;
  r = `(x) = (x+k);
  k = 10;
  r
)
</programlisting>
	  will return a function that adds 10 to its argument rather than 5.
	  This is because the extra dictionary is created only when the context
	  in which the function was defined ends, which is when the function
	  <function>f</function> returns.  This is consistent with how you
	  would expect the function <function>r</function> to work inside
	  the function <function>f</function> according to the rules of
	  scope of variables in GEL.  Only those variables are added to the
	  extra dictionary that are in the context that just ended and
	  no longer exists.  Variables
	  used in the function that are in still valid contexts will work
	  as usual, using the current value of the variable.
	</para>
    </sect1>

    <sect1 id="genius-gel-startup-procedure">
      <title>GEL Startup Procedure</title>
      <para>
First the program looks for the installed library file (the compiled version <filename>lib.cgel</filename>) in the installed directory, then it looks into the current directory, and then it tries to load an uncompiled file called
<filename>~/.geniusinit</filename>.
      </para>
      <para>
If you ever change the the library its installed place, you&rsquo;ll have to
first compile it with <command>genius --compile loader.gel &gt; lib.cgel</command>
      </para>
    </sect1>

    <sect1 id="genius-gel-loading-programs">
      <title>Loading Programs</title>
      <para>
Sometimes you have a larger program that you wrote into a file and want to read in that file. In these situations, you have two options. You can keep the functions you use most inside the <filename>~/.geniusinit</filename> file. Or if you want to load up a file in a middle of a session (or from within another file), you can type <command>load &lt;list of filenames&gt;</command> at the prompt. This has to be done on the top level and not inside any function or whatnot, and it cannot be part of any expression. It also has a slightly different syntax than the rest of genius, more similiar to a shell. You can enter the file in quotes. If you use the '' quotes, you will get exactly the string that you typed, if you use the "" quotes, special characters will be unescaped as they are for strings. Example:
<programlisting>load program1.gel program2.gel
load "Weird File Name With SPACES.gel"
</programlisting>
There are also <command>cd</command>, <command>pwd</command> and <command>ls</command> commands built in. <command>cd</command> will take one argument, <command>ls</command> will take an argument which is like the glob in the unix shell (i.e., you can use wildcards). <command>pwd</command> takes no arguments. For example:
<programlisting>cd directory_with_gel_programs
ls *.gel
</programlisting>
      </para>
    </sect1>

  </chapter>

  <!-- ============= Matrices ================================= -->
  <chapter id="genius-gel-matrices">
    <title>Matrices in GEL</title>

    <para>
      Genius has support for vectors and matrices and a sizable library of
      matrix manipulation and linear algebra functions.
    </para>

    <sect1 id="genius-gel-matrix-support">
      <title>Entering Matrices</title>
      <para>
To enter matrixes, you can use one of the following two syntaxes. You can either enter
the matrix on one line, separating values by commas and rows by semicolons.  Or you
can enter each row on one line, separating
values by commas.
You can also just combine the two methods.
So to enter a 3x3 matrix
of numbers 1-9 you could do
<programlisting>[1,2,3;4,5,6;7,8,9]
</programlisting>
or
<programlisting>[1, 2, 3
 4, 5, 6
 7, 8, 9]
</programlisting>
Do not use both ';' and return at once on the same line though.
      </para>

      <para>
You can also use the matrix expansion functionality to enter matricies.
For example you can do:
<programlisting>a = [ 1, 2, 3
      4, 5, 6
      7, 8, 9]
b = [ a,  10
      11, 12]
</programlisting>
and you should get
<programlisting>[1,   2,  3, 10
 4,   5,  6, 10
 7,   8,  9, 10
 11, 11, 11, 12]
</programlisting>
similiarly you can build matricies out of vectors and other stuff like that.
      </para>

      <para>
Another thing is that non-specified spots are initialized to 0, so
<programlisting>[1, 2, 3
 4, 5
 6]
</programlisting>
will end up being
<programlisting>
[1, 2, 3
 4, 5, 0
 6, 0, 0]
</programlisting>
      </para>

      <para>
	When matrices are evaluated, they are evaluated and traversed row-wise.  This is just
	like the <literal>M@(j)</literal> operator which traverses the matrix row-wise.
      </para>

      <note>
        <para>
Be careful about using returns for expressions inside the
<literal>[ ]</literal> brackets, as they have a slightly different meaning
there.  You will start a new row.
        </para>
      </note>

    </sect1>

    <sect1 id="genius-gel-matrix-transpose">
      <title>Conjugate Transpose and Transpose Operator</title>
      <para>
You can conjugate transpose a matrix by using the <literal>'</literal> operator.  That is
the entry in the
<varname>i</varname>th column and the <varname>j</varname>th row will be
the complex conjugate of the entry in the
<varname>j</varname>th column and the <varname>i</varname>th row of the original matrix.
 For example:
<programlisting>[1,2,3]*[4,5,6]'
</programlisting>
We transpose the second vector to make matrix multiplication possible.
If you just want to transpose a matrix without conjugating it, you would
use the <literal>.'</literal> operator.  For example:
<programlisting>[1,2,3]*[4,5,6i].'
</programlisting>
      </para>
	<para>
	  Note that normal transpose, that is the <literal>.'</literal> operator, is much faster
	  and will not create a new copy of the matrix in memory.  The conjugate transpose does
	  create a new copy unfortunately.
	  It is recommended to always use the <literal>.'</literal> operator when working with real
	  matrices and vectors.
	</para>
    </sect1>

    <sect1 id="genius-gel-matrix-linalg">
      <title>Linear Algebra</title>
      <para>
	&appname; implements many useful linear algebra and matrix manipulation
routines.  See the <link
linkend="genius-gel-function-list-linear-algebra">Linear Algebra</link> and
<link linkend="genius-gel-function-list-matrix">Matrix Manipulation</link>
sections of the GEL function listing.
      </para>
      <para>
	The linear algebra routines implemented in GEL do not currently come
from a well tested numerical package, and thus should not be used for critical
numerical computation.  On the other hand, Genius implements very well many
linear algebra operations with rational and integer coefficients.  These are
inherently exact and in fact will give you much better results than common
double precision routines for linear algebra.
      </para>
      <para>
	For example, it is pointless to compute the rank and nullspace of a
floating point matrix since for all practical purposes, we need to consider the
matrix as having some slight errors.  You are likely to get a different result
than you expect.  The problem is that under a small perturbation every matrix
is of full rank and invertible.  If the matrix however is of rational numbers,
then the rank and nullspace are always exact.
      </para>
      <para>
	In general when &appname; computes the basis of a certain vectorspace
(for example with the <function>NullSpace</function>) it will give the basis as
a matrix, in which the columns are the vectors of the basis.  That is, when
&appname; talks of a linear subspace it means a matrix whose column space is
the given linear subspace.
      </para>
      <para>
	It should be noted that &appname; can remember certain properties of a
matrix.  For example, it will remember that a matrix is in row reduced form.
If many calls are made to functions which internally use row reduced form of
the matrix, we can just row reduce the matrix beforehand once.  Successive
calls to <function>rref</function> will be very fast.
      </para>
    </sect1>

  </chapter>

  <!-- ============= Polynomials ============================== -->
  <chapter id="genius-gel-polynomials">
    <title>Polynomials in GEL</title>

    <para>
      Currently &appname; can handle polynomials of one variable written out
      as vectors, and do some basic operations with these.  It is planned to
      expand this support further.
    </para>

    <sect1 id="genius-gel-polynomials-using">
      <title>Using Polynomials</title>
      <para>
Currently
polynomials in one variable are just horizontal vectors with value only nodes.
The power of the term is the position in the vector, with the first position
being 0. So,
<programlisting>[1,2,3]
</programlisting>
translates to a polynomial of
<programlisting>1 + 2*x + 3*x^2
</programlisting>
      </para>
      <para>
You can add, subtract and multiply polynomials using the
<link linkend="gel-function-AddPoly"><function>AddPoly</function></link>,
<link linkend="gel-function-SubtractPoly"><function>SubtractPoly</function></link>, and
<link linkend="gel-function-MultiplyPoly"><function>MultiplyPoly</function></link> functions respectively.
You can print a polynomial using the
<link linkend="gel-function-PolyToString"><function>PolyToString</function></link>
function.
For example,
<programlisting>PolyToString([1,2,3],"y")
</programlisting>
gives
<programlisting>3*y^2 + 2*y + 1
</programlisting>
You can also get a function representation of the polynomial so that you can
evaluate it. This is done by using
<link linkend="gel-function-PolyToFunction"><function>PolyToFunction</function></link>,
which
returns an anonymous function which you can assign to something.
<programlisting>f = PolyToFunction([0,1,1])
f(2)
</programlisting>
      </para>
      <para>
	It is also possible to find roots of polynomials of degrees 1 through 4 by using the
function
<link linkend="gel-function-PolynomialRoots"><function>PolynomialRoots</function></link>,
which calls the appropriate formula function.  Higher degree polynomials must be converted to
functions and solved
numerically using a function such as
<link linkend="gel-function-FindRootBisection"><function>FindRootBisection</function></link>,
<link linkend="gel-function-FindRootFalsePosition"><function>FindRootFalsePosition</function></link>,
<link linkend="gel-function-FindRootMullersMethod"><function>FindRootMullersMethod</function></link>, or
<link linkend="gel-function-FindRootSecant"><function>FindRootSecant</function></link>.
      </para>
      <para>
See <xref linkend="genius-gel-function-list-polynomials" /> in the function list
for the rest of functions acting on polynomials.
      </para>
    </sect1>

  </chapter>

  <!-- ============= Set Theory ============================== -->
  <chapter id="genius-gel-settheory">
    <title>Set Theory in GEL</title>

    <para>
      &appname; has some basic set theoretic functionality built in.  Currently a set is
      just a vector (or a matrix).  Every distinct object is treated as a different element.
    </para>

    <sect1 id="genius-gel-sets-using">
      <title>Using Sets</title>
      <para>
	Just like vectors, objects
      in sets can include numbers, strings, <constant>null</constant>, matrices and vectors.  It is
      planned in the future to have a dedicated type for sets, rather than using vectors.
      Note that floating point numbers are distinct from integers, even if they appear the same.
      That is, &appname; will treat <constant>0</constant> and <constant>0.0</constant>
      as two distinct elements.  The <constant>null</constant> is treated as an empty set.
    </para>
      <para>
	To build a set out of a vector, use the 
	<link linkend="gel-function-MakeSet"><function>MakeSet</function></link> function.
	Currently, it will just return a new vector where every element is unique.
<screen><prompt>genius> </prompt><userinput>MakeSet([1,2,2,3])</userinput>
= [1, 2, 3]
</screen>
</para>

	<para>
	Similarly there are functions 
	<link linkend="gel-function-Union"><function>Union</function></link>,
	<link linkend="gel-function-Intersection"><function>Intersection</function></link>,
	<link linkend="gel-function-SetMinus"><function>SetMinus</function></link>, which
	are rather self explanatory.  For example:
<screen><prompt>genius> </prompt><userinput>Union([1,2,3], [1,2,4])</userinput>
= [1, 2, 4, 3]
</screen>
	Note that no order is guaranteed for the return values.  If you wish to sort the vector you
should use the
	<link linkend="gel-function-SortVector"><function>SortVector</function></link> function.
	</para>

	<para>
	  For testing membership, there are functions
	<link linkend="gel-function-IsIn"><function>IsIn</function></link> and
	<link linkend="gel-function-IsSubset"><function>IsSubset</function></link>,
	which return a boolean value.  For example:
<screen><prompt>genius> </prompt><userinput>IsIn (1, [0,1,2])</userinput>
= true
</screen>
	The input <userinput>IsIn(x,X)</userinput> is of course equivalent to
	<userinput>IsSubset([x],X)</userinput>.  Note that since the empty set is a subset
	of every set, <userinput>IsSubset(null,X)</userinput> is always true.
	</para>

    </sect1>

  </chapter>

  <!-- ============= GEL function list ======================== -->
  <chapter id="genius-gel-function-list">
    <title>List of GEL functions</title>

    &gel-function-list;

  </chapter>

  <!-- ============= GEL examples ============================= -->
  <chapter id="genius-gel-example-programs">
    <title>Example Programs in GEL</title>

    <para>
Here is a function that calculates factorials:
<programlisting><![CDATA[function f(x) = if x <= 1 then 1 else (f(x-1)*x)
]]></programlisting>
    </para>
    <para>
With indentation it becomes:
<programlisting><![CDATA[function f(x) = (
  if x <= 1 then
    1
  else
    (f(x-1)*x)
)
]]></programlisting>
    </para>
    <para>
This is a direct port of the factorial function from the <application>bc</application> manpage. The syntax seems similar to <application>bc</application>, but different in that in GEL, the last expression is the one that is returned. Using the <literal>return</literal> function instead, it would be:
<programlisting><![CDATA[function f(x) = (
  if (x <= 1) then return (1);
  return (f(x-1) * x)
)
]]></programlisting>
    </para>

    <para>
By far the easiest way to define a factorial function would be using
the product loop as follows.  This is not only the shortest and fastest,
but also probably the most readable version.
<programlisting>function f(x) = prod k=1 to x do k
</programlisting>
    </para>

    <para>
Here is a larger example, this basically redefines the internal
<function>ref</function> function to calculate the row echelon form of a
matrix.  The function <function>ref</function> is built in and much faster,
but this example demonstrates some of the more complex features of GEL.
<programlisting><![CDATA[# Calculate the row-echelon form of a matrix
function MyOwnREF(m) = (
  if not IsMatrix(m) or not IsValueOnly(m) then
    (error("ref: argument not a value only matrix");bailout);
  s := min(rows(m), columns(m));
  i := 1;
  d := 1;
  while d <= s and i <= columns(m) do (

    # This just makes the anchor element non-zero if at
    # all possible
    if m@(d,i) == 0 then (
      j := d+1;
      while j <= rows(m) do (
        if m@(j,i) == 0 then
          (j=j+1;continue);
        a := m@(j,);
        m@(j,) := m@(d,);
        m@(d,) := a;
        j := j+1;
        break
      )
    );
    if m@(d,i) == 0 then
      (i:=i+1;continue);
    
    # Here comes the actual zeroing of all but the anchor
    # element rows
    j := d+1;
    while j <= rows(m)) do (
      if m@(j,i) != 0 then (
        m@(j,) := m@(j,)-(m@(j,i)/m@(d,i))*m@(d,)
      );
      j := j+1
    );
    m@(d,) := m@(d,) * (1/m@(d,i));
    d := d+1;
    i := i+1
  );
  m
)
]]></programlisting>
    </para>

  </chapter>

  <!-- ============= Customization ============================ -->
  <chapter id="genius-prefs"> 
    <title>Settings</title> 

    <para>
      To configure &app;, choose
      <menuchoice><guimenu>Settings</guimenu>
      <guimenuitem>Preferences</guimenuitem></menuchoice>.
      There are several basic parameters provided by the calculator in addition
      to the ones provided by the standard library.  These control how the
      calculator behaves.
    </para>

    <note>
      <title>Changing Settings with GEL</title>
      <para>
	Many of the settings in &appname; are simply global variables, and can
	be evaluated and assigned to in the same way as normal variables. See
	<xref linkend="genius-gel-variables" /> about evaluating and assigning
	to variables, and <xref linkend="genius-gel-function-parameters" /> for
	a list of settings that can be modified in this way.
      </para>
      <para>
As an example, you can set the maximum number of digits in a result to 12 by typing:
<programlisting>MaxDigits = 12
</programlisting>
      </para>
    </note>

    <sect1 id="genius-prefs-output"> 
      <title>Output</title> 
      <variablelist> 
	<varlistentry>
	  <term> 
	    <guilabel>Maximum digits to output</guilabel>
      </term> 
	  <listitem>
        <para>The maximum digits in a result (<function>MaxDigits</function>)</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term> 
	    <guilabel>Results as floats</guilabel>
      </term> 
	  <listitem>
        <para>If the results should be always printed as floats (<function>ResultsAsFloats</function>)</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term> 
	    <guilabel>Floats in scientific notation</guilabel>
      </term> 
	  <listitem>
        <para>If floats should be in scientific notation (<function>ScientificNotation</function>)</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term> 
	    <guilabel>Always print full expressions</guilabel>
      </term> 
	  <listitem>
        <para>Should we print out full expressions for non-numeric return values (longer than a line) (<function>FullExpressions</function>)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term> 
	    <guilabel>Use mixed fractions</guilabel>
      </term> 
	  <listitem>
        <para>If fractions should be printed as mixed fractions such as "1 1/3" rather than "4/3". (<function>MixedFractions</function>)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term> 
	    <guilabel>Display 0.0 when floating point number is less than 10^-x (0=never chop)</guilabel>
      </term> 
	  <listitem>
	  <para>How to chop output.  But only when other numbers nearby are large.
	   See the documentation of the paramter
          <link linkend="gel-function-OutputChopExponent"><function>OutputChopExponent</function></link>. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term> 
            <guilabel>Only chop numbers when another number is greater than 10^-x</guilabel>
      </term> 
	  <listitem>
	  <para>When to chop output.  This is set by the paramter <function>OutputChopWhenExponent</function>.
	   See the documentation of the paramter
          <link linkend="gel-function-OutputChopExponent"><function>OutputChopExponent</function></link>. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term> 
	    <guilabel>Remember output settings across sessions</guilabel>
      </term> 
	  <listitem>
        <para>Should the output settings in the <guilabel>Number/Expression output options</guilabel> frame
	      be remembered for next session.  Does not apply to the <guilabel>Error/Info output options</guilabel> frame.</para>
	      <para>
		 If unchecked,
	   either the default or any previously saved settings are used each time &appname; starts
	   up.  Note that
	   settings are saved at the end of the session, so if you wish to change the defaults
	   check this box, restart &app; and then uncheck it again.
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term> 
	    <guilabel>Display errors in a dialog</guilabel>
      </term> 
	  <listitem>
        <para>If set the errors will be displayed in a seprate dialog, if
	unset the errors will be printed on the console.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term> 
	    <guilabel>Display information messages in a dialog</guilabel>
      </term> 
	  <listitem>
	<para>If set the information messages will be displayed in a seprate
	dialog, if unset the information messages will be printed on the
	console.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term> 
	    <guilabel>Maximum errors to display</guilabel>
      </term> 
	  <listitem>
        <para>
	  The maximum number of errors to return on one evaluation
	  (<function>MaxErrors</function>).  If you set this to 0 then
	  all errors are always returned.  Usually if some loop causes
	  many errors, then it is unlikely that you will be able to make
	  sense out of more than a few of these, so seeing a long list
	  of errors is usually not helpful.
	  </para>
	  </listitem>
	</varlistentry>
      </variablelist> 

      <para>
	In addition to these preferences, there are some preferences that can
	only be changed by setting them in the workspace console.  For others
	that may affect the output see <xref
	linkend='genius-gel-function-parameters' />.
      </para>

      <variablelist> 
	<varlistentry>
	  <term> 
	    <function>IntegerOutputBase</function>
      </term> 
	  <listitem>
        <para>The base that will be used to output integers</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term> 
	    <function>OutputStyle</function>
      </term> 
	  <listitem>
	<para>A string, can be <literal>"normal"</literal>,
<literal>"latex"</literal>, <literal>"mathml"</literal> or
<literal>"troff"</literal> and it will effect how matrices (and perhaps other
stuff) is printed, useful for pasting into documents.  Normal style is the
default human readable printing style of &app;.  The other styles are for
typsetting in LaTeX, MathML (XML), or in Troff.</para>
	  </listitem>
	</varlistentry>
      </variablelist> 
   </sect1> 

    <sect1 id="genius-prefs-precision"> 
      <title>Precision</title> 
      <variablelist> 
	<varlistentry>
	  <term> 
	    <guilabel>Floating point precision</guilabel>
      </term> 
	  <listitem>
        <para>
	  The floating point precision in bits
	  (<function>FloatPrecision</function>).
	  Note that changing this only affects newly computed quantities.
	  Old values stored in variables are obviously still in the old
	  precision and if you want to have them more precise you will have
	  to recompute them.  Exceptions to this are the system constants
	  such as <function>pi</function> or
	  <function>e</function>.
	  </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term> 
	    <guilabel>Remember precision setting across sessions</guilabel>
      </term> 
	  <listitem>
        <para>
	   Should the precision setting be remembered for the next session.  If unchecked,
	   either the default or any previously saved setting is used each time &appname; starts
	   up.  Note that
	   settings are saved at the end of the session, so if you wish to change the default
	   check this box, restart genius and then uncheck it again.
	  </para>
	  </listitem>
	</varlistentry>
      </variablelist> 
    </sect1> 

    <sect1 id="genius-prefs-terminal"> 
      <title>Terminal</title> 

      <para>
      	Terminal refers to the console in the work area.
      </para>

      <variablelist> 
	<varlistentry>
	  <term> 
	    <guilabel>Scrollback lines</guilabel>
      </term> 
	  <listitem>
        <para>Lines of scrollback in the terminal.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term> 
	    <guilabel>Font</guilabel>
      </term> 
	  <listitem>
        <para>The font to use on the terminal.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term> 
	    <guilabel>Black on white</guilabel>
      </term> 
	  <listitem>
        <para>If to use black on white on the terminal.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term> 
	    <guilabel>Blinking cursor</guilabel>
      </term> 
	  <listitem>
        <para>If the cursor in the terminal should blink when the terminal is in focus.  This can sometimes be annoying and it generates idle traffic if you are using &appname; remotely.</para>
	  </listitem>
	</varlistentry>
      </variablelist> 
    </sect1> 

    <sect1 id="genius-prefs-memory"> 
      <title>Memory</title> 
      <variablelist> 
	<varlistentry>
	  <term> 
	    <guilabel>Maximum number of nodes to allocate</guilabel>
      </term> 
	  <listitem>
        <para>
	   Internally all data is put onto small nodes in memory.  This gives
	   a limit on the maximum number of nodes to allocate for
	   computations.  This avoids the problem of running out of memory
	   if you do something by mistake which uses too much memory, such
	   as a recursion without end.  This could slow your computer and make
	   it hard to even interrupt the program.
	  </para>
        <para>
	   Once the limit is reached, &app; asks if you wish to interrupt
	   the computation or if you wish to continue.  If you continue, no
	   limit is applied and it will be possible to run your computer
	   out of memory.  The limit will be applied again next time you
	   execute a program or an expression on the Console regardless of how
	   you answered the question.
        </para>
        <para>
	   Setting the limit to zero means there is no limit to the amount of
	   memory that genius uses.
        </para>
	  </listitem>
	</varlistentry>

      </variablelist> 
    </sect1> 

  </chapter>

<!-- ============= About ====================================== -->
  <chapter id="genius-about"> 
    <title>About &app;</title> 

    <para> &app; was written by Ji&#345;&iacute; (George) Lebl (<email>jirka@5z.com</email>).  The history of &app; goes back to late 1997.  It was the first
calculator program for GNOME, but it then grew beyond being just a desktop calculator.  To find more information about &app;, please visit the <ulink url="http://www.jirka.org/genius.html" type="http">Genius Web
	page</ulink>.
    </para>
    <para>
      To report a bug or make a suggestion regarding this application or
      this manual, follow the directions in this 
      <ulink url="ghelp:gnome-feedback"   type="help">document</ulink>.
    </para>

    <para> This program is distributed under the terms of the GNU
      General Public license as published by the Free Software
      Foundation; either version 2 of the License, or (at your option)
      any later version. A copy of this license can be found at this
      <ulink url="ghelp:gpl" type="help">link</ulink>, or in the file
      COPYING included with the source code of this program. </para>

  </chapter>

</book>
